
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Buyer
 * 
 */
export type Buyer = $Result.DefaultSelection<Prisma.$BuyerPayload>
/**
 * Model CommunicationPreferences
 * 
 */
export type CommunicationPreferences = $Result.DefaultSelection<Prisma.$CommunicationPreferencesPayload>
/**
 * Model CustomerDevice
 * 
 */
export type CustomerDevice = $Result.DefaultSelection<Prisma.$CustomerDevicePayload>
/**
 * Model ProductInteraction
 * 
 */
export type ProductInteraction = $Result.DefaultSelection<Prisma.$ProductInteractionPayload>
/**
 * Model BrowsingEvent
 * 
 */
export type BrowsingEvent = $Result.DefaultSelection<Prisma.$BrowsingEventPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderDetail
 * 
 */
export type OrderDetail = $Result.DefaultSelection<Prisma.$OrderDetailPayload>
/**
 * Model POSSale
 * 
 */
export type POSSale = $Result.DefaultSelection<Prisma.$POSSalePayload>
/**
 * Model POSSaleDetail
 * 
 */
export type POSSaleDetail = $Result.DefaultSelection<Prisma.$POSSaleDetailPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Cashflow
 * 
 */
export type Cashflow = $Result.DefaultSelection<Prisma.$CashflowPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InteractionType: {
  VIEW: 'VIEW',
  ADD_TO_CART: 'ADD_TO_CART',
  REMOVE_FROM_CART: 'REMOVE_FROM_CART',
  PURCHASE: 'PURCHASE',
  WISHLIST: 'WISHLIST',
  SEARCH: 'SEARCH'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const FeedbackType: {
  ORDER: 'ORDER',
  SERVICE: 'SERVICE',
  WEBSITE: 'WEBSITE',
  PRODUCT: 'PRODUCT',
  OTHER: 'OTHER'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const CommunicationChannel: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  PHONE: 'PHONE',
  PUSH_NOTIFICATION: 'PUSH_NOTIFICATION'
};

export type CommunicationChannel = (typeof CommunicationChannel)[keyof typeof CommunicationChannel]


export const DeviceStatus: {
  FUNCIONANDO: 'FUNCIONANDO',
  CON_FALLAS: 'CON_FALLAS',
  NO_ENCIENDE: 'NO_ENCIENDE',
  PANTALLA_ROTA: 'PANTALLA_ROTA',
  BATERIA_DAÑADA: 'BATERIA_DAÑADA',
  MOJADO: 'MOJADO',
  OTROS: 'OTROS'
};

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus]


export const CustomerSegment: {
  VIP: 'VIP',
  FRECUENTE: 'FRECUENTE',
  OCASIONAL: 'OCASIONAL',
  NUEVO: 'NUEVO',
  INACTIVO: 'INACTIVO'
};

export type CustomerSegment = (typeof CustomerSegment)[keyof typeof CustomerSegment]

}

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type CommunicationChannel = $Enums.CommunicationChannel

export const CommunicationChannel: typeof $Enums.CommunicationChannel

export type DeviceStatus = $Enums.DeviceStatus

export const DeviceStatus: typeof $Enums.DeviceStatus

export type CustomerSegment = $Enums.CustomerSegment

export const CustomerSegment: typeof $Enums.CustomerSegment

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Products
 * const products = await prisma.product.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buyer`: Exposes CRUD operations for the **Buyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buyers
    * const buyers = await prisma.buyer.findMany()
    * ```
    */
  get buyer(): Prisma.BuyerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communicationPreferences`: Exposes CRUD operations for the **CommunicationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunicationPreferences
    * const communicationPreferences = await prisma.communicationPreferences.findMany()
    * ```
    */
  get communicationPreferences(): Prisma.CommunicationPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerDevice`: Exposes CRUD operations for the **CustomerDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDevices
    * const customerDevices = await prisma.customerDevice.findMany()
    * ```
    */
  get customerDevice(): Prisma.CustomerDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productInteraction`: Exposes CRUD operations for the **ProductInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductInteractions
    * const productInteractions = await prisma.productInteraction.findMany()
    * ```
    */
  get productInteraction(): Prisma.ProductInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.browsingEvent`: Exposes CRUD operations for the **BrowsingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BrowsingEvents
    * const browsingEvents = await prisma.browsingEvent.findMany()
    * ```
    */
  get browsingEvent(): Prisma.BrowsingEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderDetail`: Exposes CRUD operations for the **OrderDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDetails
    * const orderDetails = await prisma.orderDetail.findMany()
    * ```
    */
  get orderDetail(): Prisma.OrderDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSSale`: Exposes CRUD operations for the **POSSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSSales
    * const pOSSales = await prisma.pOSSale.findMany()
    * ```
    */
  get pOSSale(): Prisma.POSSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSSaleDetail`: Exposes CRUD operations for the **POSSaleDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSSaleDetails
    * const pOSSaleDetails = await prisma.pOSSaleDetail.findMany()
    * ```
    */
  get pOSSaleDetail(): Prisma.POSSaleDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashflow`: Exposes CRUD operations for the **Cashflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cashflows
    * const cashflows = await prisma.cashflow.findMany()
    * ```
    */
  get cashflow(): Prisma.CashflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    Customer: 'Customer',
    Sale: 'Sale',
    Expense: 'Expense',
    Buyer: 'Buyer',
    CommunicationPreferences: 'CommunicationPreferences',
    CustomerDevice: 'CustomerDevice',
    ProductInteraction: 'ProductInteraction',
    BrowsingEvent: 'BrowsingEvent',
    Feedback: 'Feedback',
    Order: 'Order',
    OrderDetail: 'OrderDetail',
    POSSale: 'POSSale',
    POSSaleDetail: 'POSSaleDetail',
    Service: 'Service',
    Cashflow: 'Cashflow',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "product" | "productVariant" | "customer" | "sale" | "expense" | "buyer" | "communicationPreferences" | "customerDevice" | "productInteraction" | "browsingEvent" | "feedback" | "order" | "orderDetail" | "pOSSale" | "pOSSaleDetail" | "service" | "cashflow" | "user"
      txIsolationLevel: never
    }
    model: {
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductVariantFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductVariantAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SaleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SaleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExpenseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExpenseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Buyer: {
        payload: Prisma.$BuyerPayload<ExtArgs>
        fields: Prisma.BuyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          findFirst: {
            args: Prisma.BuyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          findMany: {
            args: Prisma.BuyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>[]
          }
          create: {
            args: Prisma.BuyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          createMany: {
            args: Prisma.BuyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          update: {
            args: Prisma.BuyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          deleteMany: {
            args: Prisma.BuyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPayload>
          }
          aggregate: {
            args: Prisma.BuyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuyer>
          }
          groupBy: {
            args: Prisma.BuyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuyerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BuyerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BuyerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BuyerCountArgs<ExtArgs>
            result: $Utils.Optional<BuyerCountAggregateOutputType> | number
          }
        }
      }
      CommunicationPreferences: {
        payload: Prisma.$CommunicationPreferencesPayload<ExtArgs>
        fields: Prisma.CommunicationPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          findFirst: {
            args: Prisma.CommunicationPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          findMany: {
            args: Prisma.CommunicationPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>[]
          }
          create: {
            args: Prisma.CommunicationPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          createMany: {
            args: Prisma.CommunicationPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunicationPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          update: {
            args: Prisma.CommunicationPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunicationPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPreferencesPayload>
          }
          aggregate: {
            args: Prisma.CommunicationPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunicationPreferences>
          }
          groupBy: {
            args: Prisma.CommunicationPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationPreferencesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommunicationPreferencesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommunicationPreferencesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommunicationPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationPreferencesCountAggregateOutputType> | number
          }
        }
      }
      CustomerDevice: {
        payload: Prisma.$CustomerDevicePayload<ExtArgs>
        fields: Prisma.CustomerDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          findFirst: {
            args: Prisma.CustomerDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          findMany: {
            args: Prisma.CustomerDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>[]
          }
          create: {
            args: Prisma.CustomerDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          createMany: {
            args: Prisma.CustomerDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          update: {
            args: Prisma.CustomerDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDevicePayload>
          }
          aggregate: {
            args: Prisma.CustomerDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerDevice>
          }
          groupBy: {
            args: Prisma.CustomerDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerDeviceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerDeviceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerDeviceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerDeviceCountAggregateOutputType> | number
          }
        }
      }
      ProductInteraction: {
        payload: Prisma.$ProductInteractionPayload<ExtArgs>
        fields: Prisma.ProductInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          findFirst: {
            args: Prisma.ProductInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          findMany: {
            args: Prisma.ProductInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>[]
          }
          create: {
            args: Prisma.ProductInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          createMany: {
            args: Prisma.ProductInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          update: {
            args: Prisma.ProductInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          deleteMany: {
            args: Prisma.ProductInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInteractionPayload>
          }
          aggregate: {
            args: Prisma.ProductInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductInteraction>
          }
          groupBy: {
            args: Prisma.ProductInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductInteractionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductInteractionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductInteractionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductInteractionCountAggregateOutputType> | number
          }
        }
      }
      BrowsingEvent: {
        payload: Prisma.$BrowsingEventPayload<ExtArgs>
        fields: Prisma.BrowsingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrowsingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrowsingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          findFirst: {
            args: Prisma.BrowsingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrowsingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          findMany: {
            args: Prisma.BrowsingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>[]
          }
          create: {
            args: Prisma.BrowsingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          createMany: {
            args: Prisma.BrowsingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BrowsingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          update: {
            args: Prisma.BrowsingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          deleteMany: {
            args: Prisma.BrowsingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrowsingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BrowsingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrowsingEventPayload>
          }
          aggregate: {
            args: Prisma.BrowsingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrowsingEvent>
          }
          groupBy: {
            args: Prisma.BrowsingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrowsingEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BrowsingEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BrowsingEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BrowsingEventCountArgs<ExtArgs>
            result: $Utils.Optional<BrowsingEventCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FeedbackFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FeedbackAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderDetail: {
        payload: Prisma.$OrderDetailPayload<ExtArgs>
        fields: Prisma.OrderDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          findFirst: {
            args: Prisma.OrderDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          findMany: {
            args: Prisma.OrderDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>[]
          }
          create: {
            args: Prisma.OrderDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          createMany: {
            args: Prisma.OrderDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          update: {
            args: Prisma.OrderDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          deleteMany: {
            args: Prisma.OrderDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailPayload>
          }
          aggregate: {
            args: Prisma.OrderDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderDetail>
          }
          groupBy: {
            args: Prisma.OrderDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderDetailFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderDetailAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderDetailCountArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailCountAggregateOutputType> | number
          }
        }
      }
      POSSale: {
        payload: Prisma.$POSSalePayload<ExtArgs>
        fields: Prisma.POSSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          findFirst: {
            args: Prisma.POSSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          findMany: {
            args: Prisma.POSSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>[]
          }
          create: {
            args: Prisma.POSSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          createMany: {
            args: Prisma.POSSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.POSSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          update: {
            args: Prisma.POSSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          deleteMany: {
            args: Prisma.POSSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.POSSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          aggregate: {
            args: Prisma.POSSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSSale>
          }
          groupBy: {
            args: Prisma.POSSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSSaleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.POSSaleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.POSSaleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.POSSaleCountArgs<ExtArgs>
            result: $Utils.Optional<POSSaleCountAggregateOutputType> | number
          }
        }
      }
      POSSaleDetail: {
        payload: Prisma.$POSSaleDetailPayload<ExtArgs>
        fields: Prisma.POSSaleDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSSaleDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSSaleDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          findFirst: {
            args: Prisma.POSSaleDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSSaleDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          findMany: {
            args: Prisma.POSSaleDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>[]
          }
          create: {
            args: Prisma.POSSaleDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          createMany: {
            args: Prisma.POSSaleDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.POSSaleDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          update: {
            args: Prisma.POSSaleDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          deleteMany: {
            args: Prisma.POSSaleDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSSaleDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.POSSaleDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleDetailPayload>
          }
          aggregate: {
            args: Prisma.POSSaleDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSSaleDetail>
          }
          groupBy: {
            args: Prisma.POSSaleDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSSaleDetailGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.POSSaleDetailFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.POSSaleDetailAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.POSSaleDetailCountArgs<ExtArgs>
            result: $Utils.Optional<POSSaleDetailCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Cashflow: {
        payload: Prisma.$CashflowPayload<ExtArgs>
        fields: Prisma.CashflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          findFirst: {
            args: Prisma.CashflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          findMany: {
            args: Prisma.CashflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>[]
          }
          create: {
            args: Prisma.CashflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          createMany: {
            args: Prisma.CashflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CashflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          update: {
            args: Prisma.CashflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          deleteMany: {
            args: Prisma.CashflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashflowPayload>
          }
          aggregate: {
            args: Prisma.CashflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashflow>
          }
          groupBy: {
            args: Prisma.CashflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashflowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CashflowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CashflowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CashflowCountArgs<ExtArgs>
            result: $Utils.Optional<CashflowCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    product?: ProductOmit
    productVariant?: ProductVariantOmit
    customer?: CustomerOmit
    sale?: SaleOmit
    expense?: ExpenseOmit
    buyer?: BuyerOmit
    communicationPreferences?: CommunicationPreferencesOmit
    customerDevice?: CustomerDeviceOmit
    productInteraction?: ProductInteractionOmit
    browsingEvent?: BrowsingEventOmit
    feedback?: FeedbackOmit
    order?: OrderOmit
    orderDetail?: OrderDetailOmit
    pOSSale?: POSSaleOmit
    pOSSaleDetail?: POSSaleDetailOmit
    service?: ServiceOmit
    cashflow?: CashflowOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }


  /**
   * Count Type BuyerCountOutputType
   */

  export type BuyerCountOutputType = {
    orders: number
    posSales: number
    devices: number
    interactions: number
    browsingEvents: number
    feedback: number
    services: number
  }

  export type BuyerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | BuyerCountOutputTypeCountOrdersArgs
    posSales?: boolean | BuyerCountOutputTypeCountPosSalesArgs
    devices?: boolean | BuyerCountOutputTypeCountDevicesArgs
    interactions?: boolean | BuyerCountOutputTypeCountInteractionsArgs
    browsingEvents?: boolean | BuyerCountOutputTypeCountBrowsingEventsArgs
    feedback?: boolean | BuyerCountOutputTypeCountFeedbackArgs
    services?: boolean | BuyerCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerCountOutputType
     */
    select?: BuyerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountPosSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDeviceWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductInteractionWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountBrowsingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrowsingEventWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * BuyerCountOutputType without action
   */
  export type BuyerCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type CustomerDeviceCountOutputType
   */

  export type CustomerDeviceCountOutputType = {
    services: number
  }

  export type CustomerDeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | CustomerDeviceCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * CustomerDeviceCountOutputType without action
   */
  export type CustomerDeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDeviceCountOutputType
     */
    select?: CustomerDeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerDeviceCountOutputType without action
   */
  export type CustomerDeviceCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    detalles: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalles?: boolean | OrderCountOutputTypeCountDetallesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailWhereInput
  }


  /**
   * Count Type POSSaleCountOutputType
   */

  export type POSSaleCountOutputType = {
    detalles: number
  }

  export type POSSaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalles?: boolean | POSSaleCountOutputTypeCountDetallesArgs
  }

  // Custom InputTypes
  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleCountOutputType
     */
    select?: POSSaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeCountDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleDetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ProductSumAggregateOutputType = {
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    barcode: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    brand: string | null
    provider: string | null
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
    hasVariants: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    barcode: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    brand: string | null
    provider: string | null
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
    hasVariants: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    barcode: number
    sku: number
    name: number
    description: number
    category: number
    brand: number
    provider: number
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock: number
    images: number
    specifications: number
    hasVariants: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
  }

  export type ProductSumAggregateInputType = {
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    provider?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    hasVariants?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    provider?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    hasVariants?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    provider?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    images?: true
    specifications?: true
    hasVariants?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    barcode: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock: number
    images: string[]
    specifications: JsonValue | null
    hasVariants: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barcode?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    provider?: boolean
    costPrice?: boolean
    salePrice?: boolean
    promoPrice?: boolean
    percentPrice?: boolean
    stock?: boolean
    minStock?: boolean
    images?: boolean
    specifications?: boolean
    hasVariants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    barcode?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    provider?: boolean
    costPrice?: boolean
    salePrice?: boolean
    promoPrice?: boolean
    percentPrice?: boolean
    stock?: boolean
    minStock?: boolean
    images?: boolean
    specifications?: boolean
    hasVariants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barcode" | "sku" | "name" | "description" | "category" | "brand" | "provider" | "costPrice" | "salePrice" | "promoPrice" | "percentPrice" | "stock" | "minStock" | "images" | "specifications" | "hasVariants" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barcode: string | null
      sku: string
      name: string
      description: string
      category: string
      brand: string
      provider: string
      costPrice: number
      salePrice: number
      promoPrice: number
      percentPrice: number
      stock: number
      minStock: number
      images: string[]
      specifications: Prisma.JsonValue | null
      hasVariants: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly provider: FieldRef<"Product", 'String'>
    readonly costPrice: FieldRef<"Product", 'Float'>
    readonly salePrice: FieldRef<"Product", 'Float'>
    readonly promoPrice: FieldRef<"Product", 'Float'>
    readonly percentPrice: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly minStock: FieldRef<"Product", 'Int'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly specifications: FieldRef<"Product", 'Json'>
    readonly hasVariants: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product findRaw
   */
  export type ProductFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ProductVariantSumAggregateOutputType = {
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    barcode: string | null
    sku: string | null
    name: string | null
    description: string | null
    color: string | null
    design: string | null
    size: string | null
    material: string | null
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    barcode: string | null
    sku: string | null
    name: string | null
    description: string | null
    color: string | null
    design: string | null
    size: string | null
    material: string | null
    costPrice: number | null
    salePrice: number | null
    promoPrice: number | null
    percentPrice: number | null
    stock: number | null
    minStock: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    barcode: number
    sku: number
    name: number
    description: number
    color: number
    design: number
    size: number
    material: number
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock: number
    images: number
    specifications: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
  }

  export type ProductVariantSumAggregateInputType = {
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    color?: true
    design?: true
    size?: true
    material?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    color?: true
    design?: true
    size?: true
    material?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    barcode?: true
    sku?: true
    name?: true
    description?: true
    color?: true
    design?: true
    size?: true
    material?: true
    costPrice?: true
    salePrice?: true
    promoPrice?: true
    percentPrice?: true
    stock?: true
    minStock?: true
    images?: true
    specifications?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    barcode: string | null
    sku: string
    name: string
    description: string | null
    color: string | null
    design: string | null
    size: string | null
    material: string | null
    costPrice: number
    salePrice: number
    promoPrice: number | null
    percentPrice: number | null
    stock: number
    minStock: number
    images: string[]
    specifications: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    barcode?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    design?: boolean
    size?: boolean
    material?: boolean
    costPrice?: boolean
    salePrice?: boolean
    promoPrice?: boolean
    percentPrice?: boolean
    stock?: boolean
    minStock?: boolean
    images?: boolean
    specifications?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>



  export type ProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    barcode?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    design?: boolean
    size?: boolean
    material?: boolean
    costPrice?: boolean
    salePrice?: boolean
    promoPrice?: boolean
    percentPrice?: boolean
    stock?: boolean
    minStock?: boolean
    images?: boolean
    specifications?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "barcode" | "sku" | "name" | "description" | "color" | "design" | "size" | "material" | "costPrice" | "salePrice" | "promoPrice" | "percentPrice" | "stock" | "minStock" | "images" | "specifications" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      barcode: string | null
      sku: string
      name: string
      description: string | null
      color: string | null
      design: string | null
      size: string | null
      material: string | null
      costPrice: number
      salePrice: number
      promoPrice: number | null
      percentPrice: number | null
      stock: number
      minStock: number
      images: string[]
      specifications: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * @param {ProductVariantFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const productVariant = await prisma.productVariant.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductVariantFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProductVariant.
     * @param {ProductVariantAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const productVariant = await prisma.productVariant.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductVariantAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly barcode: FieldRef<"ProductVariant", 'String'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly description: FieldRef<"ProductVariant", 'String'>
    readonly color: FieldRef<"ProductVariant", 'String'>
    readonly design: FieldRef<"ProductVariant", 'String'>
    readonly size: FieldRef<"ProductVariant", 'String'>
    readonly material: FieldRef<"ProductVariant", 'String'>
    readonly costPrice: FieldRef<"ProductVariant", 'Float'>
    readonly salePrice: FieldRef<"ProductVariant", 'Float'>
    readonly promoPrice: FieldRef<"ProductVariant", 'Float'>
    readonly percentPrice: FieldRef<"ProductVariant", 'Float'>
    readonly stock: FieldRef<"ProductVariant", 'Int'>
    readonly minStock: FieldRef<"ProductVariant", 'Int'>
    readonly images: FieldRef<"ProductVariant", 'String[]'>
    readonly specifications: FieldRef<"ProductVariant", 'Json'>
    readonly isActive: FieldRef<"ProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant findRaw
   */
  export type ProductVariantFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProductVariant aggregateRaw
   */
  export type ProductVariantAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    phone: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    address: number
    phone: number
    purchaseHistory: number
    serviceHistory: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    phone?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    address?: true
    phone?: true
    purchaseHistory?: true
    serviceHistory?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    password: string
    address: JsonValue
    phone: string
    purchaseHistory: string[]
    serviceHistory: string[]
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    phone?: boolean
    purchaseHistory?: boolean
    serviceHistory?: boolean
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    phone?: boolean
    purchaseHistory?: boolean
    serviceHistory?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "password" | "address" | "phone" | "purchaseHistory" | "serviceHistory", ExtArgs["result"]["customer"]>

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      password: string
      address: Prisma.JsonValue
      phone: string
      purchaseHistory: string[]
      serviceHistory: string[]
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * @param {CustomerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer = await prisma.customer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customer.
     * @param {CustomerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer = await prisma.customer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'Json'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly purchaseHistory: FieldRef<"Customer", 'String[]'>
    readonly serviceHistory: FieldRef<"Customer", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer findRaw
   */
  export type CustomerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer aggregateRaw
   */
  export type CustomerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    total: number | null
    discount: number | null
  }

  export type SaleSumAggregateOutputType = {
    total: number | null
    discount: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    details: string | null
    date: Date | null
    total: number | null
    discount: number | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    details: string | null
    date: Date | null
    total: number | null
    discount: number | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    customerId: number
    details: number
    date: number
    products: number
    total: number
    discount: number
    payments: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    total?: true
    discount?: true
  }

  export type SaleSumAggregateInputType = {
    total?: true
    discount?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    customerId?: true
    details?: true
    date?: true
    total?: true
    discount?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    customerId?: true
    details?: true
    date?: true
    total?: true
    discount?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    customerId?: true
    details?: true
    date?: true
    products?: true
    total?: true
    discount?: true
    payments?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    customerId: string
    details: string
    date: Date
    products: JsonValue
    total: number
    discount: number
    payments: JsonValue | null
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    details?: boolean
    date?: boolean
    products?: boolean
    total?: boolean
    discount?: boolean
    payments?: boolean
  }, ExtArgs["result"]["sale"]>



  export type SaleSelectScalar = {
    id?: boolean
    customerId?: boolean
    details?: boolean
    date?: boolean
    products?: boolean
    total?: boolean
    discount?: boolean
    payments?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "details" | "date" | "products" | "total" | "discount" | "payments", ExtArgs["result"]["sale"]>

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      details: string
      date: Date
      products: Prisma.JsonValue
      total: number
      discount: number
      payments: Prisma.JsonValue | null
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * @param {SaleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sale = await prisma.sale.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SaleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sale.
     * @param {SaleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sale = await prisma.sale.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SaleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly details: FieldRef<"Sale", 'String'>
    readonly date: FieldRef<"Sale", 'DateTime'>
    readonly products: FieldRef<"Sale", 'Json'>
    readonly total: FieldRef<"Sale", 'Float'>
    readonly discount: FieldRef<"Sale", 'Float'>
    readonly payments: FieldRef<"Sale", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale findRaw
   */
  export type SaleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sale aggregateRaw
   */
  export type SaleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
    categoryId: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
    categoryId: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    product: string | null
    details: string | null
    amount: number | null
    method: string | null
    date: Date | null
    category: string | null
    categoryId: number | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    product: string | null
    details: string | null
    amount: number | null
    method: string | null
    date: Date | null
    category: string | null
    categoryId: number | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    product: number
    details: number
    amount: number
    method: number
    date: number
    category: number
    categoryId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
    categoryId?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
    categoryId?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    product?: true
    details?: true
    amount?: true
    method?: true
    date?: true
    category?: true
    categoryId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    product?: true
    details?: true
    amount?: true
    method?: true
    date?: true
    category?: true
    categoryId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    product?: true
    details?: true
    amount?: true
    method?: true
    date?: true
    category?: true
    categoryId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    product: string
    details: string | null
    amount: number
    method: string | null
    date: Date
    category: string | null
    categoryId: number | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product?: boolean
    details?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    category?: boolean
    categoryId?: boolean
  }, ExtArgs["result"]["expense"]>



  export type ExpenseSelectScalar = {
    id?: boolean
    product?: boolean
    details?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    category?: boolean
    categoryId?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product" | "details" | "amount" | "method" | "date" | "category" | "categoryId", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      product: string
      details: string | null
      amount: number
      method: string | null
      date: Date
      category: string | null
      categoryId: number | null
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * @param {ExpenseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const expense = await prisma.expense.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExpenseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Expense.
     * @param {ExpenseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const expense = await prisma.expense.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExpenseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly product: FieldRef<"Expense", 'String'>
    readonly details: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly method: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly categoryId: FieldRef<"Expense", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense findRaw
   */
  export type ExpenseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Expense aggregateRaw
   */
  export type ExpenseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model Buyer
   */

  export type AggregateBuyer = {
    _count: BuyerCountAggregateOutputType | null
    _min: BuyerMinAggregateOutputType | null
    _max: BuyerMaxAggregateOutputType | null
  }

  export type BuyerMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    dni: string | null
    cuit: string | null
    telefono: string | null
    whatsapp: string | null
    fecha_nacimiento: Date | null
    direccion: string | null
    acquisition_channel: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_content: string | null
    utm_term: string | null
    segment: $Enums.CustomerSegment | null
    createdAt: Date | null
    updatedAt: Date | null
    last_interaction: Date | null
  }

  export type BuyerMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    dni: string | null
    cuit: string | null
    telefono: string | null
    whatsapp: string | null
    fecha_nacimiento: Date | null
    direccion: string | null
    acquisition_channel: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_content: string | null
    utm_term: string | null
    segment: $Enums.CustomerSegment | null
    createdAt: Date | null
    updatedAt: Date | null
    last_interaction: Date | null
  }

  export type BuyerCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    email: number
    dni: number
    cuit: number
    telefono: number
    whatsapp: number
    fecha_nacimiento: number
    direccion: number
    acquisition_channel: number
    utm_source: number
    utm_medium: number
    utm_campaign: number
    utm_content: number
    utm_term: number
    segment: number
    tags: number
    createdAt: number
    updatedAt: number
    last_interaction: number
    _all: number
  }


  export type BuyerMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    dni?: true
    cuit?: true
    telefono?: true
    whatsapp?: true
    fecha_nacimiento?: true
    direccion?: true
    acquisition_channel?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_content?: true
    utm_term?: true
    segment?: true
    createdAt?: true
    updatedAt?: true
    last_interaction?: true
  }

  export type BuyerMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    dni?: true
    cuit?: true
    telefono?: true
    whatsapp?: true
    fecha_nacimiento?: true
    direccion?: true
    acquisition_channel?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_content?: true
    utm_term?: true
    segment?: true
    createdAt?: true
    updatedAt?: true
    last_interaction?: true
  }

  export type BuyerCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    dni?: true
    cuit?: true
    telefono?: true
    whatsapp?: true
    fecha_nacimiento?: true
    direccion?: true
    acquisition_channel?: true
    utm_source?: true
    utm_medium?: true
    utm_campaign?: true
    utm_content?: true
    utm_term?: true
    segment?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    last_interaction?: true
    _all?: true
  }

  export type BuyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buyer to aggregate.
     */
    where?: BuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buyers to fetch.
     */
    orderBy?: BuyerOrderByWithRelationInput | BuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buyers
    **/
    _count?: true | BuyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuyerMaxAggregateInputType
  }

  export type GetBuyerAggregateType<T extends BuyerAggregateArgs> = {
        [P in keyof T & keyof AggregateBuyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuyer[P]>
      : GetScalarType<T[P], AggregateBuyer[P]>
  }




  export type BuyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuyerWhereInput
    orderBy?: BuyerOrderByWithAggregationInput | BuyerOrderByWithAggregationInput[]
    by: BuyerScalarFieldEnum[] | BuyerScalarFieldEnum
    having?: BuyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuyerCountAggregateInputType | true
    _min?: BuyerMinAggregateInputType
    _max?: BuyerMaxAggregateInputType
  }

  export type BuyerGroupByOutputType = {
    id: string
    nombre: string
    apellido: string | null
    email: string
    dni: string | null
    cuit: string | null
    telefono: string | null
    whatsapp: string | null
    fecha_nacimiento: Date | null
    direccion: string
    acquisition_channel: string | null
    utm_source: string | null
    utm_medium: string | null
    utm_campaign: string | null
    utm_content: string | null
    utm_term: string | null
    segment: $Enums.CustomerSegment
    tags: string[]
    createdAt: Date
    updatedAt: Date
    last_interaction: Date | null
    _count: BuyerCountAggregateOutputType | null
    _min: BuyerMinAggregateOutputType | null
    _max: BuyerMaxAggregateOutputType | null
  }

  type GetBuyerGroupByPayload<T extends BuyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuyerGroupByOutputType[P]>
            : GetScalarType<T[P], BuyerGroupByOutputType[P]>
        }
      >
    >


  export type BuyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    dni?: boolean
    cuit?: boolean
    telefono?: boolean
    whatsapp?: boolean
    fecha_nacimiento?: boolean
    direccion?: boolean
    acquisition_channel?: boolean
    utm_source?: boolean
    utm_medium?: boolean
    utm_campaign?: boolean
    utm_content?: boolean
    utm_term?: boolean
    segment?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    last_interaction?: boolean
    communication_preferences?: boolean | Buyer$communication_preferencesArgs<ExtArgs>
    orders?: boolean | Buyer$ordersArgs<ExtArgs>
    posSales?: boolean | Buyer$posSalesArgs<ExtArgs>
    devices?: boolean | Buyer$devicesArgs<ExtArgs>
    interactions?: boolean | Buyer$interactionsArgs<ExtArgs>
    browsingEvents?: boolean | Buyer$browsingEventsArgs<ExtArgs>
    feedback?: boolean | Buyer$feedbackArgs<ExtArgs>
    services?: boolean | Buyer$servicesArgs<ExtArgs>
    _count?: boolean | BuyerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buyer"]>



  export type BuyerSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    dni?: boolean
    cuit?: boolean
    telefono?: boolean
    whatsapp?: boolean
    fecha_nacimiento?: boolean
    direccion?: boolean
    acquisition_channel?: boolean
    utm_source?: boolean
    utm_medium?: boolean
    utm_campaign?: boolean
    utm_content?: boolean
    utm_term?: boolean
    segment?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    last_interaction?: boolean
  }

  export type BuyerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "email" | "dni" | "cuit" | "telefono" | "whatsapp" | "fecha_nacimiento" | "direccion" | "acquisition_channel" | "utm_source" | "utm_medium" | "utm_campaign" | "utm_content" | "utm_term" | "segment" | "tags" | "createdAt" | "updatedAt" | "last_interaction", ExtArgs["result"]["buyer"]>
  export type BuyerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communication_preferences?: boolean | Buyer$communication_preferencesArgs<ExtArgs>
    orders?: boolean | Buyer$ordersArgs<ExtArgs>
    posSales?: boolean | Buyer$posSalesArgs<ExtArgs>
    devices?: boolean | Buyer$devicesArgs<ExtArgs>
    interactions?: boolean | Buyer$interactionsArgs<ExtArgs>
    browsingEvents?: boolean | Buyer$browsingEventsArgs<ExtArgs>
    feedback?: boolean | Buyer$feedbackArgs<ExtArgs>
    services?: boolean | Buyer$servicesArgs<ExtArgs>
    _count?: boolean | BuyerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Buyer"
    objects: {
      communication_preferences: Prisma.$CommunicationPreferencesPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      posSales: Prisma.$POSSalePayload<ExtArgs>[]
      devices: Prisma.$CustomerDevicePayload<ExtArgs>[]
      interactions: Prisma.$ProductInteractionPayload<ExtArgs>[]
      browsingEvents: Prisma.$BrowsingEventPayload<ExtArgs>[]
      feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      apellido: string | null
      email: string
      dni: string | null
      cuit: string | null
      telefono: string | null
      whatsapp: string | null
      fecha_nacimiento: Date | null
      direccion: string
      acquisition_channel: string | null
      utm_source: string | null
      utm_medium: string | null
      utm_campaign: string | null
      utm_content: string | null
      utm_term: string | null
      segment: $Enums.CustomerSegment
      tags: string[]
      createdAt: Date
      updatedAt: Date
      last_interaction: Date | null
    }, ExtArgs["result"]["buyer"]>
    composites: {}
  }

  type BuyerGetPayload<S extends boolean | null | undefined | BuyerDefaultArgs> = $Result.GetResult<Prisma.$BuyerPayload, S>

  type BuyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuyerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuyerCountAggregateInputType | true
    }

  export interface BuyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Buyer'], meta: { name: 'Buyer' } }
    /**
     * Find zero or one Buyer that matches the filter.
     * @param {BuyerFindUniqueArgs} args - Arguments to find a Buyer
     * @example
     * // Get one Buyer
     * const buyer = await prisma.buyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuyerFindUniqueArgs>(args: SelectSubset<T, BuyerFindUniqueArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Buyer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuyerFindUniqueOrThrowArgs} args - Arguments to find a Buyer
     * @example
     * // Get one Buyer
     * const buyer = await prisma.buyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuyerFindUniqueOrThrowArgs>(args: SelectSubset<T, BuyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Buyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerFindFirstArgs} args - Arguments to find a Buyer
     * @example
     * // Get one Buyer
     * const buyer = await prisma.buyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuyerFindFirstArgs>(args?: SelectSubset<T, BuyerFindFirstArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Buyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerFindFirstOrThrowArgs} args - Arguments to find a Buyer
     * @example
     * // Get one Buyer
     * const buyer = await prisma.buyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuyerFindFirstOrThrowArgs>(args?: SelectSubset<T, BuyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buyers
     * const buyers = await prisma.buyer.findMany()
     * 
     * // Get first 10 Buyers
     * const buyers = await prisma.buyer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buyerWithIdOnly = await prisma.buyer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuyerFindManyArgs>(args?: SelectSubset<T, BuyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Buyer.
     * @param {BuyerCreateArgs} args - Arguments to create a Buyer.
     * @example
     * // Create one Buyer
     * const Buyer = await prisma.buyer.create({
     *   data: {
     *     // ... data to create a Buyer
     *   }
     * })
     * 
     */
    create<T extends BuyerCreateArgs>(args: SelectSubset<T, BuyerCreateArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buyers.
     * @param {BuyerCreateManyArgs} args - Arguments to create many Buyers.
     * @example
     * // Create many Buyers
     * const buyer = await prisma.buyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuyerCreateManyArgs>(args?: SelectSubset<T, BuyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Buyer.
     * @param {BuyerDeleteArgs} args - Arguments to delete one Buyer.
     * @example
     * // Delete one Buyer
     * const Buyer = await prisma.buyer.delete({
     *   where: {
     *     // ... filter to delete one Buyer
     *   }
     * })
     * 
     */
    delete<T extends BuyerDeleteArgs>(args: SelectSubset<T, BuyerDeleteArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Buyer.
     * @param {BuyerUpdateArgs} args - Arguments to update one Buyer.
     * @example
     * // Update one Buyer
     * const buyer = await prisma.buyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuyerUpdateArgs>(args: SelectSubset<T, BuyerUpdateArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buyers.
     * @param {BuyerDeleteManyArgs} args - Arguments to filter Buyers to delete.
     * @example
     * // Delete a few Buyers
     * const { count } = await prisma.buyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuyerDeleteManyArgs>(args?: SelectSubset<T, BuyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buyers
     * const buyer = await prisma.buyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuyerUpdateManyArgs>(args: SelectSubset<T, BuyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Buyer.
     * @param {BuyerUpsertArgs} args - Arguments to update or create a Buyer.
     * @example
     * // Update or create a Buyer
     * const buyer = await prisma.buyer.upsert({
     *   create: {
     *     // ... data to create a Buyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Buyer we want to update
     *   }
     * })
     */
    upsert<T extends BuyerUpsertArgs>(args: SelectSubset<T, BuyerUpsertArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buyers that matches the filter.
     * @param {BuyerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const buyer = await prisma.buyer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BuyerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Buyer.
     * @param {BuyerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const buyer = await prisma.buyer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BuyerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerCountArgs} args - Arguments to filter Buyers to count.
     * @example
     * // Count the number of Buyers
     * const count = await prisma.buyer.count({
     *   where: {
     *     // ... the filter for the Buyers we want to count
     *   }
     * })
    **/
    count<T extends BuyerCountArgs>(
      args?: Subset<T, BuyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Buyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuyerAggregateArgs>(args: Subset<T, BuyerAggregateArgs>): Prisma.PrismaPromise<GetBuyerAggregateType<T>>

    /**
     * Group by Buyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuyerGroupByArgs['orderBy'] }
        : { orderBy?: BuyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Buyer model
   */
  readonly fields: BuyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Buyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    communication_preferences<T extends Buyer$communication_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$communication_preferencesArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Buyer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSales<T extends Buyer$posSalesArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$posSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends Buyer$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Buyer$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    browsingEvents<T extends Buyer$browsingEventsArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$browsingEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedback<T extends Buyer$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Buyer$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Buyer$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Buyer model
   */
  interface BuyerFieldRefs {
    readonly id: FieldRef<"Buyer", 'String'>
    readonly nombre: FieldRef<"Buyer", 'String'>
    readonly apellido: FieldRef<"Buyer", 'String'>
    readonly email: FieldRef<"Buyer", 'String'>
    readonly dni: FieldRef<"Buyer", 'String'>
    readonly cuit: FieldRef<"Buyer", 'String'>
    readonly telefono: FieldRef<"Buyer", 'String'>
    readonly whatsapp: FieldRef<"Buyer", 'String'>
    readonly fecha_nacimiento: FieldRef<"Buyer", 'DateTime'>
    readonly direccion: FieldRef<"Buyer", 'String'>
    readonly acquisition_channel: FieldRef<"Buyer", 'String'>
    readonly utm_source: FieldRef<"Buyer", 'String'>
    readonly utm_medium: FieldRef<"Buyer", 'String'>
    readonly utm_campaign: FieldRef<"Buyer", 'String'>
    readonly utm_content: FieldRef<"Buyer", 'String'>
    readonly utm_term: FieldRef<"Buyer", 'String'>
    readonly segment: FieldRef<"Buyer", 'CustomerSegment'>
    readonly tags: FieldRef<"Buyer", 'String[]'>
    readonly createdAt: FieldRef<"Buyer", 'DateTime'>
    readonly updatedAt: FieldRef<"Buyer", 'DateTime'>
    readonly last_interaction: FieldRef<"Buyer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Buyer findUnique
   */
  export type BuyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter, which Buyer to fetch.
     */
    where: BuyerWhereUniqueInput
  }

  /**
   * Buyer findUniqueOrThrow
   */
  export type BuyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter, which Buyer to fetch.
     */
    where: BuyerWhereUniqueInput
  }

  /**
   * Buyer findFirst
   */
  export type BuyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter, which Buyer to fetch.
     */
    where?: BuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buyers to fetch.
     */
    orderBy?: BuyerOrderByWithRelationInput | BuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buyers.
     */
    cursor?: BuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buyers.
     */
    distinct?: BuyerScalarFieldEnum | BuyerScalarFieldEnum[]
  }

  /**
   * Buyer findFirstOrThrow
   */
  export type BuyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter, which Buyer to fetch.
     */
    where?: BuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buyers to fetch.
     */
    orderBy?: BuyerOrderByWithRelationInput | BuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buyers.
     */
    cursor?: BuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buyers.
     */
    distinct?: BuyerScalarFieldEnum | BuyerScalarFieldEnum[]
  }

  /**
   * Buyer findMany
   */
  export type BuyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter, which Buyers to fetch.
     */
    where?: BuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buyers to fetch.
     */
    orderBy?: BuyerOrderByWithRelationInput | BuyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buyers.
     */
    cursor?: BuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buyers.
     */
    skip?: number
    distinct?: BuyerScalarFieldEnum | BuyerScalarFieldEnum[]
  }

  /**
   * Buyer create
   */
  export type BuyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * The data needed to create a Buyer.
     */
    data: XOR<BuyerCreateInput, BuyerUncheckedCreateInput>
  }

  /**
   * Buyer createMany
   */
  export type BuyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buyers.
     */
    data: BuyerCreateManyInput | BuyerCreateManyInput[]
  }

  /**
   * Buyer update
   */
  export type BuyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * The data needed to update a Buyer.
     */
    data: XOR<BuyerUpdateInput, BuyerUncheckedUpdateInput>
    /**
     * Choose, which Buyer to update.
     */
    where: BuyerWhereUniqueInput
  }

  /**
   * Buyer updateMany
   */
  export type BuyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buyers.
     */
    data: XOR<BuyerUpdateManyMutationInput, BuyerUncheckedUpdateManyInput>
    /**
     * Filter which Buyers to update
     */
    where?: BuyerWhereInput
    /**
     * Limit how many Buyers to update.
     */
    limit?: number
  }

  /**
   * Buyer upsert
   */
  export type BuyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * The filter to search for the Buyer to update in case it exists.
     */
    where: BuyerWhereUniqueInput
    /**
     * In case the Buyer found by the `where` argument doesn't exist, create a new Buyer with this data.
     */
    create: XOR<BuyerCreateInput, BuyerUncheckedCreateInput>
    /**
     * In case the Buyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuyerUpdateInput, BuyerUncheckedUpdateInput>
  }

  /**
   * Buyer delete
   */
  export type BuyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    /**
     * Filter which Buyer to delete.
     */
    where: BuyerWhereUniqueInput
  }

  /**
   * Buyer deleteMany
   */
  export type BuyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buyers to delete
     */
    where?: BuyerWhereInput
    /**
     * Limit how many Buyers to delete.
     */
    limit?: number
  }

  /**
   * Buyer findRaw
   */
  export type BuyerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Buyer aggregateRaw
   */
  export type BuyerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Buyer.communication_preferences
   */
  export type Buyer$communication_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    where?: CommunicationPreferencesWhereInput
  }

  /**
   * Buyer.orders
   */
  export type Buyer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Buyer.posSales
   */
  export type Buyer$posSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    cursor?: POSSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * Buyer.devices
   */
  export type Buyer$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    where?: CustomerDeviceWhereInput
    orderBy?: CustomerDeviceOrderByWithRelationInput | CustomerDeviceOrderByWithRelationInput[]
    cursor?: CustomerDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDeviceScalarFieldEnum | CustomerDeviceScalarFieldEnum[]
  }

  /**
   * Buyer.interactions
   */
  export type Buyer$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    where?: ProductInteractionWhereInput
    orderBy?: ProductInteractionOrderByWithRelationInput | ProductInteractionOrderByWithRelationInput[]
    cursor?: ProductInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductInteractionScalarFieldEnum | ProductInteractionScalarFieldEnum[]
  }

  /**
   * Buyer.browsingEvents
   */
  export type Buyer$browsingEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    where?: BrowsingEventWhereInput
    orderBy?: BrowsingEventOrderByWithRelationInput | BrowsingEventOrderByWithRelationInput[]
    cursor?: BrowsingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrowsingEventScalarFieldEnum | BrowsingEventScalarFieldEnum[]
  }

  /**
   * Buyer.feedback
   */
  export type Buyer$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Buyer.services
   */
  export type Buyer$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Buyer without action
   */
  export type BuyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
  }


  /**
   * Model CommunicationPreferences
   */

  export type AggregateCommunicationPreferences = {
    _count: CommunicationPreferencesCountAggregateOutputType | null
    _min: CommunicationPreferencesMinAggregateOutputType | null
    _max: CommunicationPreferencesMaxAggregateOutputType | null
  }

  export type CommunicationPreferencesMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    email_marketing: boolean | null
    email_transaccional: boolean | null
    sms_marketing: boolean | null
    sms_transaccional: boolean | null
    whatsapp_marketing: boolean | null
    whatsapp_transaccional: boolean | null
    llamadas_comerciales: boolean | null
    preferred_channel: $Enums.CommunicationChannel | null
    best_contact_time: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationPreferencesMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    email_marketing: boolean | null
    email_transaccional: boolean | null
    sms_marketing: boolean | null
    sms_transaccional: boolean | null
    whatsapp_marketing: boolean | null
    whatsapp_transaccional: boolean | null
    llamadas_comerciales: boolean | null
    preferred_channel: $Enums.CommunicationChannel | null
    best_contact_time: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationPreferencesCountAggregateOutputType = {
    id: number
    buyerId: number
    email_marketing: number
    email_transaccional: number
    sms_marketing: number
    sms_transaccional: number
    whatsapp_marketing: number
    whatsapp_transaccional: number
    llamadas_comerciales: number
    preferred_channel: number
    best_contact_time: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunicationPreferencesMinAggregateInputType = {
    id?: true
    buyerId?: true
    email_marketing?: true
    email_transaccional?: true
    sms_marketing?: true
    sms_transaccional?: true
    whatsapp_marketing?: true
    whatsapp_transaccional?: true
    llamadas_comerciales?: true
    preferred_channel?: true
    best_contact_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationPreferencesMaxAggregateInputType = {
    id?: true
    buyerId?: true
    email_marketing?: true
    email_transaccional?: true
    sms_marketing?: true
    sms_transaccional?: true
    whatsapp_marketing?: true
    whatsapp_transaccional?: true
    llamadas_comerciales?: true
    preferred_channel?: true
    best_contact_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationPreferencesCountAggregateInputType = {
    id?: true
    buyerId?: true
    email_marketing?: true
    email_transaccional?: true
    sms_marketing?: true
    sms_transaccional?: true
    whatsapp_marketing?: true
    whatsapp_transaccional?: true
    llamadas_comerciales?: true
    preferred_channel?: true
    best_contact_time?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunicationPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationPreferences to aggregate.
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationPreferences to fetch.
     */
    orderBy?: CommunicationPreferencesOrderByWithRelationInput | CommunicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunicationPreferences
    **/
    _count?: true | CommunicationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationPreferencesMaxAggregateInputType
  }

  export type GetCommunicationPreferencesAggregateType<T extends CommunicationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunicationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunicationPreferences[P]>
      : GetScalarType<T[P], AggregateCommunicationPreferences[P]>
  }




  export type CommunicationPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationPreferencesWhereInput
    orderBy?: CommunicationPreferencesOrderByWithAggregationInput | CommunicationPreferencesOrderByWithAggregationInput[]
    by: CommunicationPreferencesScalarFieldEnum[] | CommunicationPreferencesScalarFieldEnum
    having?: CommunicationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationPreferencesCountAggregateInputType | true
    _min?: CommunicationPreferencesMinAggregateInputType
    _max?: CommunicationPreferencesMaxAggregateInputType
  }

  export type CommunicationPreferencesGroupByOutputType = {
    id: string
    buyerId: string
    email_marketing: boolean
    email_transaccional: boolean
    sms_marketing: boolean
    sms_transaccional: boolean
    whatsapp_marketing: boolean
    whatsapp_transaccional: boolean
    llamadas_comerciales: boolean
    preferred_channel: $Enums.CommunicationChannel
    best_contact_time: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommunicationPreferencesCountAggregateOutputType | null
    _min: CommunicationPreferencesMinAggregateOutputType | null
    _max: CommunicationPreferencesMaxAggregateOutputType | null
  }

  type GetCommunicationPreferencesGroupByPayload<T extends CommunicationPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: boolean
    best_contact_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communicationPreferences"]>



  export type CommunicationPreferencesSelectScalar = {
    id?: boolean
    buyerId?: boolean
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: boolean
    best_contact_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunicationPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "email_marketing" | "email_transaccional" | "sms_marketing" | "sms_transaccional" | "whatsapp_marketing" | "whatsapp_transaccional" | "llamadas_comerciales" | "preferred_channel" | "best_contact_time" | "createdAt" | "updatedAt", ExtArgs["result"]["communicationPreferences"]>
  export type CommunicationPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }

  export type $CommunicationPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunicationPreferences"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      email_marketing: boolean
      email_transaccional: boolean
      sms_marketing: boolean
      sms_transaccional: boolean
      whatsapp_marketing: boolean
      whatsapp_transaccional: boolean
      llamadas_comerciales: boolean
      preferred_channel: $Enums.CommunicationChannel
      best_contact_time: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communicationPreferences"]>
    composites: {}
  }

  type CommunicationPreferencesGetPayload<S extends boolean | null | undefined | CommunicationPreferencesDefaultArgs> = $Result.GetResult<Prisma.$CommunicationPreferencesPayload, S>

  type CommunicationPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunicationPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunicationPreferencesCountAggregateInputType | true
    }

  export interface CommunicationPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunicationPreferences'], meta: { name: 'CommunicationPreferences' } }
    /**
     * Find zero or one CommunicationPreferences that matches the filter.
     * @param {CommunicationPreferencesFindUniqueArgs} args - Arguments to find a CommunicationPreferences
     * @example
     * // Get one CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationPreferencesFindUniqueArgs>(args: SelectSubset<T, CommunicationPreferencesFindUniqueArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunicationPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunicationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a CommunicationPreferences
     * @example
     * // Get one CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunicationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesFindFirstArgs} args - Arguments to find a CommunicationPreferences
     * @example
     * // Get one CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationPreferencesFindFirstArgs>(args?: SelectSubset<T, CommunicationPreferencesFindFirstArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunicationPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesFindFirstOrThrowArgs} args - Arguments to find a CommunicationPreferences
     * @example
     * // Get one CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunicationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findMany()
     * 
     * // Get first 10 CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationPreferencesWithIdOnly = await prisma.communicationPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationPreferencesFindManyArgs>(args?: SelectSubset<T, CommunicationPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunicationPreferences.
     * @param {CommunicationPreferencesCreateArgs} args - Arguments to create a CommunicationPreferences.
     * @example
     * // Create one CommunicationPreferences
     * const CommunicationPreferences = await prisma.communicationPreferences.create({
     *   data: {
     *     // ... data to create a CommunicationPreferences
     *   }
     * })
     * 
     */
    create<T extends CommunicationPreferencesCreateArgs>(args: SelectSubset<T, CommunicationPreferencesCreateArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunicationPreferences.
     * @param {CommunicationPreferencesCreateManyArgs} args - Arguments to create many CommunicationPreferences.
     * @example
     * // Create many CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationPreferencesCreateManyArgs>(args?: SelectSubset<T, CommunicationPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunicationPreferences.
     * @param {CommunicationPreferencesDeleteArgs} args - Arguments to delete one CommunicationPreferences.
     * @example
     * // Delete one CommunicationPreferences
     * const CommunicationPreferences = await prisma.communicationPreferences.delete({
     *   where: {
     *     // ... filter to delete one CommunicationPreferences
     *   }
     * })
     * 
     */
    delete<T extends CommunicationPreferencesDeleteArgs>(args: SelectSubset<T, CommunicationPreferencesDeleteArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunicationPreferences.
     * @param {CommunicationPreferencesUpdateArgs} args - Arguments to update one CommunicationPreferences.
     * @example
     * // Update one CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationPreferencesUpdateArgs>(args: SelectSubset<T, CommunicationPreferencesUpdateArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunicationPreferences.
     * @param {CommunicationPreferencesDeleteManyArgs} args - Arguments to filter CommunicationPreferences to delete.
     * @example
     * // Delete a few CommunicationPreferences
     * const { count } = await prisma.communicationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationPreferencesDeleteManyArgs>(args?: SelectSubset<T, CommunicationPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationPreferencesUpdateManyArgs>(args: SelectSubset<T, CommunicationPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunicationPreferences.
     * @param {CommunicationPreferencesUpsertArgs} args - Arguments to update or create a CommunicationPreferences.
     * @example
     * // Update or create a CommunicationPreferences
     * const communicationPreferences = await prisma.communicationPreferences.upsert({
     *   create: {
     *     // ... data to create a CommunicationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunicationPreferences we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationPreferencesUpsertArgs>(args: SelectSubset<T, CommunicationPreferencesUpsertArgs<ExtArgs>>): Prisma__CommunicationPreferencesClient<$Result.GetResult<Prisma.$CommunicationPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunicationPreferences that matches the filter.
     * @param {CommunicationPreferencesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const communicationPreferences = await prisma.communicationPreferences.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CommunicationPreferencesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CommunicationPreferences.
     * @param {CommunicationPreferencesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const communicationPreferences = await prisma.communicationPreferences.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommunicationPreferencesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CommunicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesCountArgs} args - Arguments to filter CommunicationPreferences to count.
     * @example
     * // Count the number of CommunicationPreferences
     * const count = await prisma.communicationPreferences.count({
     *   where: {
     *     // ... the filter for the CommunicationPreferences we want to count
     *   }
     * })
    **/
    count<T extends CommunicationPreferencesCountArgs>(
      args?: Subset<T, CommunicationPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationPreferencesAggregateArgs>(args: Subset<T, CommunicationPreferencesAggregateArgs>): Prisma.PrismaPromise<GetCommunicationPreferencesAggregateType<T>>

    /**
     * Group by CommunicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunicationPreferences model
   */
  readonly fields: CommunicationPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunicationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunicationPreferences model
   */
  interface CommunicationPreferencesFieldRefs {
    readonly id: FieldRef<"CommunicationPreferences", 'String'>
    readonly buyerId: FieldRef<"CommunicationPreferences", 'String'>
    readonly email_marketing: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly email_transaccional: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly sms_marketing: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly sms_transaccional: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly whatsapp_marketing: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly whatsapp_transaccional: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly llamadas_comerciales: FieldRef<"CommunicationPreferences", 'Boolean'>
    readonly preferred_channel: FieldRef<"CommunicationPreferences", 'CommunicationChannel'>
    readonly best_contact_time: FieldRef<"CommunicationPreferences", 'String'>
    readonly createdAt: FieldRef<"CommunicationPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunicationPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunicationPreferences findUnique
   */
  export type CommunicationPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationPreferences to fetch.
     */
    where: CommunicationPreferencesWhereUniqueInput
  }

  /**
   * CommunicationPreferences findUniqueOrThrow
   */
  export type CommunicationPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationPreferences to fetch.
     */
    where: CommunicationPreferencesWhereUniqueInput
  }

  /**
   * CommunicationPreferences findFirst
   */
  export type CommunicationPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationPreferences to fetch.
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationPreferences to fetch.
     */
    orderBy?: CommunicationPreferencesOrderByWithRelationInput | CommunicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationPreferences.
     */
    cursor?: CommunicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationPreferences.
     */
    distinct?: CommunicationPreferencesScalarFieldEnum | CommunicationPreferencesScalarFieldEnum[]
  }

  /**
   * CommunicationPreferences findFirstOrThrow
   */
  export type CommunicationPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationPreferences to fetch.
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationPreferences to fetch.
     */
    orderBy?: CommunicationPreferencesOrderByWithRelationInput | CommunicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationPreferences.
     */
    cursor?: CommunicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationPreferences.
     */
    distinct?: CommunicationPreferencesScalarFieldEnum | CommunicationPreferencesScalarFieldEnum[]
  }

  /**
   * CommunicationPreferences findMany
   */
  export type CommunicationPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationPreferences to fetch.
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationPreferences to fetch.
     */
    orderBy?: CommunicationPreferencesOrderByWithRelationInput | CommunicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunicationPreferences.
     */
    cursor?: CommunicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationPreferences.
     */
    skip?: number
    distinct?: CommunicationPreferencesScalarFieldEnum | CommunicationPreferencesScalarFieldEnum[]
  }

  /**
   * CommunicationPreferences create
   */
  export type CommunicationPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunicationPreferences.
     */
    data: XOR<CommunicationPreferencesCreateInput, CommunicationPreferencesUncheckedCreateInput>
  }

  /**
   * CommunicationPreferences createMany
   */
  export type CommunicationPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunicationPreferences.
     */
    data: CommunicationPreferencesCreateManyInput | CommunicationPreferencesCreateManyInput[]
  }

  /**
   * CommunicationPreferences update
   */
  export type CommunicationPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunicationPreferences.
     */
    data: XOR<CommunicationPreferencesUpdateInput, CommunicationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which CommunicationPreferences to update.
     */
    where: CommunicationPreferencesWhereUniqueInput
  }

  /**
   * CommunicationPreferences updateMany
   */
  export type CommunicationPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunicationPreferences.
     */
    data: XOR<CommunicationPreferencesUpdateManyMutationInput, CommunicationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which CommunicationPreferences to update
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * Limit how many CommunicationPreferences to update.
     */
    limit?: number
  }

  /**
   * CommunicationPreferences upsert
   */
  export type CommunicationPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunicationPreferences to update in case it exists.
     */
    where: CommunicationPreferencesWhereUniqueInput
    /**
     * In case the CommunicationPreferences found by the `where` argument doesn't exist, create a new CommunicationPreferences with this data.
     */
    create: XOR<CommunicationPreferencesCreateInput, CommunicationPreferencesUncheckedCreateInput>
    /**
     * In case the CommunicationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationPreferencesUpdateInput, CommunicationPreferencesUncheckedUpdateInput>
  }

  /**
   * CommunicationPreferences delete
   */
  export type CommunicationPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter which CommunicationPreferences to delete.
     */
    where: CommunicationPreferencesWhereUniqueInput
  }

  /**
   * CommunicationPreferences deleteMany
   */
  export type CommunicationPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationPreferences to delete
     */
    where?: CommunicationPreferencesWhereInput
    /**
     * Limit how many CommunicationPreferences to delete.
     */
    limit?: number
  }

  /**
   * CommunicationPreferences findRaw
   */
  export type CommunicationPreferencesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommunicationPreferences aggregateRaw
   */
  export type CommunicationPreferencesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommunicationPreferences without action
   */
  export type CommunicationPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationPreferences
     */
    select?: CommunicationPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunicationPreferences
     */
    omit?: CommunicationPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model CustomerDevice
   */

  export type AggregateCustomerDevice = {
    _count: CustomerDeviceCountAggregateOutputType | null
    _avg: CustomerDeviceAvgAggregateOutputType | null
    _sum: CustomerDeviceSumAggregateOutputType | null
    _min: CustomerDeviceMinAggregateOutputType | null
    _max: CustomerDeviceMaxAggregateOutputType | null
  }

  export type CustomerDeviceAvgAggregateOutputType = {
    precio_compra: number | null
  }

  export type CustomerDeviceSumAggregateOutputType = {
    precio_compra: number | null
  }

  export type CustomerDeviceMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    marca: string | null
    modelo: string | null
    numero_serie: string | null
    imei: string | null
    color: string | null
    capacidad: string | null
    fecha_compra: Date | null
    lugar_compra: string | null
    precio_compra: number | null
    tiene_garantia: boolean | null
    garantia_hasta: Date | null
    is_active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerDeviceMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    marca: string | null
    modelo: string | null
    numero_serie: string | null
    imei: string | null
    color: string | null
    capacidad: string | null
    fecha_compra: Date | null
    lugar_compra: string | null
    precio_compra: number | null
    tiene_garantia: boolean | null
    garantia_hasta: Date | null
    is_active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerDeviceCountAggregateOutputType = {
    id: number
    buyerId: number
    marca: number
    modelo: number
    numero_serie: number
    imei: number
    color: number
    capacidad: number
    fecha_compra: number
    lugar_compra: number
    precio_compra: number
    tiene_garantia: number
    garantia_hasta: number
    is_active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerDeviceAvgAggregateInputType = {
    precio_compra?: true
  }

  export type CustomerDeviceSumAggregateInputType = {
    precio_compra?: true
  }

  export type CustomerDeviceMinAggregateInputType = {
    id?: true
    buyerId?: true
    marca?: true
    modelo?: true
    numero_serie?: true
    imei?: true
    color?: true
    capacidad?: true
    fecha_compra?: true
    lugar_compra?: true
    precio_compra?: true
    tiene_garantia?: true
    garantia_hasta?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerDeviceMaxAggregateInputType = {
    id?: true
    buyerId?: true
    marca?: true
    modelo?: true
    numero_serie?: true
    imei?: true
    color?: true
    capacidad?: true
    fecha_compra?: true
    lugar_compra?: true
    precio_compra?: true
    tiene_garantia?: true
    garantia_hasta?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerDeviceCountAggregateInputType = {
    id?: true
    buyerId?: true
    marca?: true
    modelo?: true
    numero_serie?: true
    imei?: true
    color?: true
    capacidad?: true
    fecha_compra?: true
    lugar_compra?: true
    precio_compra?: true
    tiene_garantia?: true
    garantia_hasta?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDevice to aggregate.
     */
    where?: CustomerDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDevices to fetch.
     */
    orderBy?: CustomerDeviceOrderByWithRelationInput | CustomerDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDevices
    **/
    _count?: true | CustomerDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDeviceMaxAggregateInputType
  }

  export type GetCustomerDeviceAggregateType<T extends CustomerDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDevice[P]>
      : GetScalarType<T[P], AggregateCustomerDevice[P]>
  }




  export type CustomerDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDeviceWhereInput
    orderBy?: CustomerDeviceOrderByWithAggregationInput | CustomerDeviceOrderByWithAggregationInput[]
    by: CustomerDeviceScalarFieldEnum[] | CustomerDeviceScalarFieldEnum
    having?: CustomerDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDeviceCountAggregateInputType | true
    _avg?: CustomerDeviceAvgAggregateInputType
    _sum?: CustomerDeviceSumAggregateInputType
    _min?: CustomerDeviceMinAggregateInputType
    _max?: CustomerDeviceMaxAggregateInputType
  }

  export type CustomerDeviceGroupByOutputType = {
    id: string
    buyerId: string
    marca: string
    modelo: string
    numero_serie: string | null
    imei: string | null
    color: string | null
    capacidad: string | null
    fecha_compra: Date | null
    lugar_compra: string | null
    precio_compra: number | null
    tiene_garantia: boolean
    garantia_hasta: Date | null
    is_active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerDeviceCountAggregateOutputType | null
    _avg: CustomerDeviceAvgAggregateOutputType | null
    _sum: CustomerDeviceSumAggregateOutputType | null
    _min: CustomerDeviceMinAggregateOutputType | null
    _max: CustomerDeviceMaxAggregateOutputType | null
  }

  type GetCustomerDeviceGroupByPayload<T extends CustomerDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDeviceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    marca?: boolean
    modelo?: boolean
    numero_serie?: boolean
    imei?: boolean
    color?: boolean
    capacidad?: boolean
    fecha_compra?: boolean
    lugar_compra?: boolean
    precio_compra?: boolean
    tiene_garantia?: boolean
    garantia_hasta?: boolean
    is_active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    services?: boolean | CustomerDevice$servicesArgs<ExtArgs>
    _count?: boolean | CustomerDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDevice"]>



  export type CustomerDeviceSelectScalar = {
    id?: boolean
    buyerId?: boolean
    marca?: boolean
    modelo?: boolean
    numero_serie?: boolean
    imei?: boolean
    color?: boolean
    capacidad?: boolean
    fecha_compra?: boolean
    lugar_compra?: boolean
    precio_compra?: boolean
    tiene_garantia?: boolean
    garantia_hasta?: boolean
    is_active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "marca" | "modelo" | "numero_serie" | "imei" | "color" | "capacidad" | "fecha_compra" | "lugar_compra" | "precio_compra" | "tiene_garantia" | "garantia_hasta" | "is_active" | "createdAt" | "updatedAt", ExtArgs["result"]["customerDevice"]>
  export type CustomerDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    services?: boolean | CustomerDevice$servicesArgs<ExtArgs>
    _count?: boolean | CustomerDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerDevice"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      marca: string
      modelo: string
      numero_serie: string | null
      imei: string | null
      color: string | null
      capacidad: string | null
      fecha_compra: Date | null
      lugar_compra: string | null
      precio_compra: number | null
      tiene_garantia: boolean
      garantia_hasta: Date | null
      is_active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerDevice"]>
    composites: {}
  }

  type CustomerDeviceGetPayload<S extends boolean | null | undefined | CustomerDeviceDefaultArgs> = $Result.GetResult<Prisma.$CustomerDevicePayload, S>

  type CustomerDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerDeviceCountAggregateInputType | true
    }

  export interface CustomerDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerDevice'], meta: { name: 'CustomerDevice' } }
    /**
     * Find zero or one CustomerDevice that matches the filter.
     * @param {CustomerDeviceFindUniqueArgs} args - Arguments to find a CustomerDevice
     * @example
     * // Get one CustomerDevice
     * const customerDevice = await prisma.customerDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerDeviceFindUniqueArgs>(args: SelectSubset<T, CustomerDeviceFindUniqueArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerDeviceFindUniqueOrThrowArgs} args - Arguments to find a CustomerDevice
     * @example
     * // Get one CustomerDevice
     * const customerDevice = await prisma.customerDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceFindFirstArgs} args - Arguments to find a CustomerDevice
     * @example
     * // Get one CustomerDevice
     * const customerDevice = await prisma.customerDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerDeviceFindFirstArgs>(args?: SelectSubset<T, CustomerDeviceFindFirstArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceFindFirstOrThrowArgs} args - Arguments to find a CustomerDevice
     * @example
     * // Get one CustomerDevice
     * const customerDevice = await prisma.customerDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDevices
     * const customerDevices = await prisma.customerDevice.findMany()
     * 
     * // Get first 10 CustomerDevices
     * const customerDevices = await prisma.customerDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerDeviceWithIdOnly = await prisma.customerDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerDeviceFindManyArgs>(args?: SelectSubset<T, CustomerDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerDevice.
     * @param {CustomerDeviceCreateArgs} args - Arguments to create a CustomerDevice.
     * @example
     * // Create one CustomerDevice
     * const CustomerDevice = await prisma.customerDevice.create({
     *   data: {
     *     // ... data to create a CustomerDevice
     *   }
     * })
     * 
     */
    create<T extends CustomerDeviceCreateArgs>(args: SelectSubset<T, CustomerDeviceCreateArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerDevices.
     * @param {CustomerDeviceCreateManyArgs} args - Arguments to create many CustomerDevices.
     * @example
     * // Create many CustomerDevices
     * const customerDevice = await prisma.customerDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerDeviceCreateManyArgs>(args?: SelectSubset<T, CustomerDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerDevice.
     * @param {CustomerDeviceDeleteArgs} args - Arguments to delete one CustomerDevice.
     * @example
     * // Delete one CustomerDevice
     * const CustomerDevice = await prisma.customerDevice.delete({
     *   where: {
     *     // ... filter to delete one CustomerDevice
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeviceDeleteArgs>(args: SelectSubset<T, CustomerDeviceDeleteArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerDevice.
     * @param {CustomerDeviceUpdateArgs} args - Arguments to update one CustomerDevice.
     * @example
     * // Update one CustomerDevice
     * const customerDevice = await prisma.customerDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerDeviceUpdateArgs>(args: SelectSubset<T, CustomerDeviceUpdateArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerDevices.
     * @param {CustomerDeviceDeleteManyArgs} args - Arguments to filter CustomerDevices to delete.
     * @example
     * // Delete a few CustomerDevices
     * const { count } = await prisma.customerDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeviceDeleteManyArgs>(args?: SelectSubset<T, CustomerDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDevices
     * const customerDevice = await prisma.customerDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerDeviceUpdateManyArgs>(args: SelectSubset<T, CustomerDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerDevice.
     * @param {CustomerDeviceUpsertArgs} args - Arguments to update or create a CustomerDevice.
     * @example
     * // Update or create a CustomerDevice
     * const customerDevice = await prisma.customerDevice.upsert({
     *   create: {
     *     // ... data to create a CustomerDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDevice we want to update
     *   }
     * })
     */
    upsert<T extends CustomerDeviceUpsertArgs>(args: SelectSubset<T, CustomerDeviceUpsertArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerDevices that matches the filter.
     * @param {CustomerDeviceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customerDevice = await prisma.customerDevice.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerDeviceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomerDevice.
     * @param {CustomerDeviceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customerDevice = await prisma.customerDevice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerDeviceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CustomerDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceCountArgs} args - Arguments to filter CustomerDevices to count.
     * @example
     * // Count the number of CustomerDevices
     * const count = await prisma.customerDevice.count({
     *   where: {
     *     // ... the filter for the CustomerDevices we want to count
     *   }
     * })
    **/
    count<T extends CustomerDeviceCountArgs>(
      args?: Subset<T, CustomerDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDeviceAggregateArgs>(args: Subset<T, CustomerDeviceAggregateArgs>): Prisma.PrismaPromise<GetCustomerDeviceAggregateType<T>>

    /**
     * Group by CustomerDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDeviceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerDevice model
   */
  readonly fields: CustomerDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends CustomerDevice$servicesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDevice$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerDevice model
   */
  interface CustomerDeviceFieldRefs {
    readonly id: FieldRef<"CustomerDevice", 'String'>
    readonly buyerId: FieldRef<"CustomerDevice", 'String'>
    readonly marca: FieldRef<"CustomerDevice", 'String'>
    readonly modelo: FieldRef<"CustomerDevice", 'String'>
    readonly numero_serie: FieldRef<"CustomerDevice", 'String'>
    readonly imei: FieldRef<"CustomerDevice", 'String'>
    readonly color: FieldRef<"CustomerDevice", 'String'>
    readonly capacidad: FieldRef<"CustomerDevice", 'String'>
    readonly fecha_compra: FieldRef<"CustomerDevice", 'DateTime'>
    readonly lugar_compra: FieldRef<"CustomerDevice", 'String'>
    readonly precio_compra: FieldRef<"CustomerDevice", 'Float'>
    readonly tiene_garantia: FieldRef<"CustomerDevice", 'Boolean'>
    readonly garantia_hasta: FieldRef<"CustomerDevice", 'DateTime'>
    readonly is_active: FieldRef<"CustomerDevice", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerDevice", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerDevice findUnique
   */
  export type CustomerDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDevice to fetch.
     */
    where: CustomerDeviceWhereUniqueInput
  }

  /**
   * CustomerDevice findUniqueOrThrow
   */
  export type CustomerDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDevice to fetch.
     */
    where: CustomerDeviceWhereUniqueInput
  }

  /**
   * CustomerDevice findFirst
   */
  export type CustomerDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDevice to fetch.
     */
    where?: CustomerDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDevices to fetch.
     */
    orderBy?: CustomerDeviceOrderByWithRelationInput | CustomerDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDevices.
     */
    cursor?: CustomerDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDevices.
     */
    distinct?: CustomerDeviceScalarFieldEnum | CustomerDeviceScalarFieldEnum[]
  }

  /**
   * CustomerDevice findFirstOrThrow
   */
  export type CustomerDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDevice to fetch.
     */
    where?: CustomerDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDevices to fetch.
     */
    orderBy?: CustomerDeviceOrderByWithRelationInput | CustomerDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDevices.
     */
    cursor?: CustomerDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDevices.
     */
    distinct?: CustomerDeviceScalarFieldEnum | CustomerDeviceScalarFieldEnum[]
  }

  /**
   * CustomerDevice findMany
   */
  export type CustomerDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDevices to fetch.
     */
    where?: CustomerDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDevices to fetch.
     */
    orderBy?: CustomerDeviceOrderByWithRelationInput | CustomerDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDevices.
     */
    cursor?: CustomerDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDevices.
     */
    skip?: number
    distinct?: CustomerDeviceScalarFieldEnum | CustomerDeviceScalarFieldEnum[]
  }

  /**
   * CustomerDevice create
   */
  export type CustomerDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerDevice.
     */
    data: XOR<CustomerDeviceCreateInput, CustomerDeviceUncheckedCreateInput>
  }

  /**
   * CustomerDevice createMany
   */
  export type CustomerDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerDevices.
     */
    data: CustomerDeviceCreateManyInput | CustomerDeviceCreateManyInput[]
  }

  /**
   * CustomerDevice update
   */
  export type CustomerDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerDevice.
     */
    data: XOR<CustomerDeviceUpdateInput, CustomerDeviceUncheckedUpdateInput>
    /**
     * Choose, which CustomerDevice to update.
     */
    where: CustomerDeviceWhereUniqueInput
  }

  /**
   * CustomerDevice updateMany
   */
  export type CustomerDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerDevices.
     */
    data: XOR<CustomerDeviceUpdateManyMutationInput, CustomerDeviceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDevices to update
     */
    where?: CustomerDeviceWhereInput
    /**
     * Limit how many CustomerDevices to update.
     */
    limit?: number
  }

  /**
   * CustomerDevice upsert
   */
  export type CustomerDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerDevice to update in case it exists.
     */
    where: CustomerDeviceWhereUniqueInput
    /**
     * In case the CustomerDevice found by the `where` argument doesn't exist, create a new CustomerDevice with this data.
     */
    create: XOR<CustomerDeviceCreateInput, CustomerDeviceUncheckedCreateInput>
    /**
     * In case the CustomerDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerDeviceUpdateInput, CustomerDeviceUncheckedUpdateInput>
  }

  /**
   * CustomerDevice delete
   */
  export type CustomerDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    /**
     * Filter which CustomerDevice to delete.
     */
    where: CustomerDeviceWhereUniqueInput
  }

  /**
   * CustomerDevice deleteMany
   */
  export type CustomerDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDevices to delete
     */
    where?: CustomerDeviceWhereInput
    /**
     * Limit how many CustomerDevices to delete.
     */
    limit?: number
  }

  /**
   * CustomerDevice findRaw
   */
  export type CustomerDeviceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerDevice aggregateRaw
   */
  export type CustomerDeviceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CustomerDevice.services
   */
  export type CustomerDevice$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * CustomerDevice without action
   */
  export type CustomerDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
  }


  /**
   * Model ProductInteraction
   */

  export type AggregateProductInteraction = {
    _count: ProductInteractionCountAggregateOutputType | null
    _avg: ProductInteractionAvgAggregateOutputType | null
    _sum: ProductInteractionSumAggregateOutputType | null
    _min: ProductInteractionMinAggregateOutputType | null
    _max: ProductInteractionMaxAggregateOutputType | null
  }

  export type ProductInteractionAvgAggregateOutputType = {
    quantity: number | null
    price_at_interaction: number | null
  }

  export type ProductInteractionSumAggregateOutputType = {
    quantity: number | null
    price_at_interaction: number | null
  }

  export type ProductInteractionMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    productoId: string | null
    productoName: string | null
    tipo: $Enums.InteractionType | null
    session_id: string | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    quantity: number | null
    price_at_interaction: number | null
    createdAt: Date | null
  }

  export type ProductInteractionMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    productoId: string | null
    productoName: string | null
    tipo: $Enums.InteractionType | null
    session_id: string | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    quantity: number | null
    price_at_interaction: number | null
    createdAt: Date | null
  }

  export type ProductInteractionCountAggregateOutputType = {
    id: number
    buyerId: number
    productoId: number
    productoName: number
    tipo: number
    session_id: number
    user_agent: number
    ip_address: number
    referrer: number
    quantity: number
    price_at_interaction: number
    createdAt: number
    _all: number
  }


  export type ProductInteractionAvgAggregateInputType = {
    quantity?: true
    price_at_interaction?: true
  }

  export type ProductInteractionSumAggregateInputType = {
    quantity?: true
    price_at_interaction?: true
  }

  export type ProductInteractionMinAggregateInputType = {
    id?: true
    buyerId?: true
    productoId?: true
    productoName?: true
    tipo?: true
    session_id?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    quantity?: true
    price_at_interaction?: true
    createdAt?: true
  }

  export type ProductInteractionMaxAggregateInputType = {
    id?: true
    buyerId?: true
    productoId?: true
    productoName?: true
    tipo?: true
    session_id?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    quantity?: true
    price_at_interaction?: true
    createdAt?: true
  }

  export type ProductInteractionCountAggregateInputType = {
    id?: true
    buyerId?: true
    productoId?: true
    productoName?: true
    tipo?: true
    session_id?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    quantity?: true
    price_at_interaction?: true
    createdAt?: true
    _all?: true
  }

  export type ProductInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductInteraction to aggregate.
     */
    where?: ProductInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInteractions to fetch.
     */
    orderBy?: ProductInteractionOrderByWithRelationInput | ProductInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductInteractions
    **/
    _count?: true | ProductInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductInteractionMaxAggregateInputType
  }

  export type GetProductInteractionAggregateType<T extends ProductInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductInteraction[P]>
      : GetScalarType<T[P], AggregateProductInteraction[P]>
  }




  export type ProductInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductInteractionWhereInput
    orderBy?: ProductInteractionOrderByWithAggregationInput | ProductInteractionOrderByWithAggregationInput[]
    by: ProductInteractionScalarFieldEnum[] | ProductInteractionScalarFieldEnum
    having?: ProductInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductInteractionCountAggregateInputType | true
    _avg?: ProductInteractionAvgAggregateInputType
    _sum?: ProductInteractionSumAggregateInputType
    _min?: ProductInteractionMinAggregateInputType
    _max?: ProductInteractionMaxAggregateInputType
  }

  export type ProductInteractionGroupByOutputType = {
    id: string
    buyerId: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id: string | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    quantity: number | null
    price_at_interaction: number | null
    createdAt: Date
    _count: ProductInteractionCountAggregateOutputType | null
    _avg: ProductInteractionAvgAggregateOutputType | null
    _sum: ProductInteractionSumAggregateOutputType | null
    _min: ProductInteractionMinAggregateOutputType | null
    _max: ProductInteractionMaxAggregateOutputType | null
  }

  type GetProductInteractionGroupByPayload<T extends ProductInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductInteractionGroupByOutputType[P]>
        }
      >
    >


  export type ProductInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    productoId?: boolean
    productoName?: boolean
    tipo?: boolean
    session_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referrer?: boolean
    quantity?: boolean
    price_at_interaction?: boolean
    createdAt?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productInteraction"]>



  export type ProductInteractionSelectScalar = {
    id?: boolean
    buyerId?: boolean
    productoId?: boolean
    productoName?: boolean
    tipo?: boolean
    session_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referrer?: boolean
    quantity?: boolean
    price_at_interaction?: boolean
    createdAt?: boolean
  }

  export type ProductInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "productoId" | "productoName" | "tipo" | "session_id" | "user_agent" | "ip_address" | "referrer" | "quantity" | "price_at_interaction" | "createdAt", ExtArgs["result"]["productInteraction"]>
  export type ProductInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }

  export type $ProductInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductInteraction"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      productoId: string
      productoName: string
      tipo: $Enums.InteractionType
      session_id: string | null
      user_agent: string | null
      ip_address: string | null
      referrer: string | null
      quantity: number | null
      price_at_interaction: number | null
      createdAt: Date
    }, ExtArgs["result"]["productInteraction"]>
    composites: {}
  }

  type ProductInteractionGetPayload<S extends boolean | null | undefined | ProductInteractionDefaultArgs> = $Result.GetResult<Prisma.$ProductInteractionPayload, S>

  type ProductInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductInteractionCountAggregateInputType | true
    }

  export interface ProductInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductInteraction'], meta: { name: 'ProductInteraction' } }
    /**
     * Find zero or one ProductInteraction that matches the filter.
     * @param {ProductInteractionFindUniqueArgs} args - Arguments to find a ProductInteraction
     * @example
     * // Get one ProductInteraction
     * const productInteraction = await prisma.productInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductInteractionFindUniqueArgs>(args: SelectSubset<T, ProductInteractionFindUniqueArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductInteractionFindUniqueOrThrowArgs} args - Arguments to find a ProductInteraction
     * @example
     * // Get one ProductInteraction
     * const productInteraction = await prisma.productInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionFindFirstArgs} args - Arguments to find a ProductInteraction
     * @example
     * // Get one ProductInteraction
     * const productInteraction = await prisma.productInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductInteractionFindFirstArgs>(args?: SelectSubset<T, ProductInteractionFindFirstArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionFindFirstOrThrowArgs} args - Arguments to find a ProductInteraction
     * @example
     * // Get one ProductInteraction
     * const productInteraction = await prisma.productInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductInteractions
     * const productInteractions = await prisma.productInteraction.findMany()
     * 
     * // Get first 10 ProductInteractions
     * const productInteractions = await prisma.productInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productInteractionWithIdOnly = await prisma.productInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductInteractionFindManyArgs>(args?: SelectSubset<T, ProductInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductInteraction.
     * @param {ProductInteractionCreateArgs} args - Arguments to create a ProductInteraction.
     * @example
     * // Create one ProductInteraction
     * const ProductInteraction = await prisma.productInteraction.create({
     *   data: {
     *     // ... data to create a ProductInteraction
     *   }
     * })
     * 
     */
    create<T extends ProductInteractionCreateArgs>(args: SelectSubset<T, ProductInteractionCreateArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductInteractions.
     * @param {ProductInteractionCreateManyArgs} args - Arguments to create many ProductInteractions.
     * @example
     * // Create many ProductInteractions
     * const productInteraction = await prisma.productInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductInteractionCreateManyArgs>(args?: SelectSubset<T, ProductInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductInteraction.
     * @param {ProductInteractionDeleteArgs} args - Arguments to delete one ProductInteraction.
     * @example
     * // Delete one ProductInteraction
     * const ProductInteraction = await prisma.productInteraction.delete({
     *   where: {
     *     // ... filter to delete one ProductInteraction
     *   }
     * })
     * 
     */
    delete<T extends ProductInteractionDeleteArgs>(args: SelectSubset<T, ProductInteractionDeleteArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductInteraction.
     * @param {ProductInteractionUpdateArgs} args - Arguments to update one ProductInteraction.
     * @example
     * // Update one ProductInteraction
     * const productInteraction = await prisma.productInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductInteractionUpdateArgs>(args: SelectSubset<T, ProductInteractionUpdateArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductInteractions.
     * @param {ProductInteractionDeleteManyArgs} args - Arguments to filter ProductInteractions to delete.
     * @example
     * // Delete a few ProductInteractions
     * const { count } = await prisma.productInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductInteractionDeleteManyArgs>(args?: SelectSubset<T, ProductInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductInteractions
     * const productInteraction = await prisma.productInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductInteractionUpdateManyArgs>(args: SelectSubset<T, ProductInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductInteraction.
     * @param {ProductInteractionUpsertArgs} args - Arguments to update or create a ProductInteraction.
     * @example
     * // Update or create a ProductInteraction
     * const productInteraction = await prisma.productInteraction.upsert({
     *   create: {
     *     // ... data to create a ProductInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductInteraction we want to update
     *   }
     * })
     */
    upsert<T extends ProductInteractionUpsertArgs>(args: SelectSubset<T, ProductInteractionUpsertArgs<ExtArgs>>): Prisma__ProductInteractionClient<$Result.GetResult<Prisma.$ProductInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductInteractions that matches the filter.
     * @param {ProductInteractionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const productInteraction = await prisma.productInteraction.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductInteractionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProductInteraction.
     * @param {ProductInteractionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const productInteraction = await prisma.productInteraction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductInteractionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProductInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionCountArgs} args - Arguments to filter ProductInteractions to count.
     * @example
     * // Count the number of ProductInteractions
     * const count = await prisma.productInteraction.count({
     *   where: {
     *     // ... the filter for the ProductInteractions we want to count
     *   }
     * })
    **/
    count<T extends ProductInteractionCountArgs>(
      args?: Subset<T, ProductInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductInteractionAggregateArgs>(args: Subset<T, ProductInteractionAggregateArgs>): Prisma.PrismaPromise<GetProductInteractionAggregateType<T>>

    /**
     * Group by ProductInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductInteractionGroupByArgs['orderBy'] }
        : { orderBy?: ProductInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductInteraction model
   */
  readonly fields: ProductInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductInteraction model
   */
  interface ProductInteractionFieldRefs {
    readonly id: FieldRef<"ProductInteraction", 'String'>
    readonly buyerId: FieldRef<"ProductInteraction", 'String'>
    readonly productoId: FieldRef<"ProductInteraction", 'String'>
    readonly productoName: FieldRef<"ProductInteraction", 'String'>
    readonly tipo: FieldRef<"ProductInteraction", 'InteractionType'>
    readonly session_id: FieldRef<"ProductInteraction", 'String'>
    readonly user_agent: FieldRef<"ProductInteraction", 'String'>
    readonly ip_address: FieldRef<"ProductInteraction", 'String'>
    readonly referrer: FieldRef<"ProductInteraction", 'String'>
    readonly quantity: FieldRef<"ProductInteraction", 'Int'>
    readonly price_at_interaction: FieldRef<"ProductInteraction", 'Float'>
    readonly createdAt: FieldRef<"ProductInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductInteraction findUnique
   */
  export type ProductInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ProductInteraction to fetch.
     */
    where: ProductInteractionWhereUniqueInput
  }

  /**
   * ProductInteraction findUniqueOrThrow
   */
  export type ProductInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ProductInteraction to fetch.
     */
    where: ProductInteractionWhereUniqueInput
  }

  /**
   * ProductInteraction findFirst
   */
  export type ProductInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ProductInteraction to fetch.
     */
    where?: ProductInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInteractions to fetch.
     */
    orderBy?: ProductInteractionOrderByWithRelationInput | ProductInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInteractions.
     */
    cursor?: ProductInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInteractions.
     */
    distinct?: ProductInteractionScalarFieldEnum | ProductInteractionScalarFieldEnum[]
  }

  /**
   * ProductInteraction findFirstOrThrow
   */
  export type ProductInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ProductInteraction to fetch.
     */
    where?: ProductInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInteractions to fetch.
     */
    orderBy?: ProductInteractionOrderByWithRelationInput | ProductInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInteractions.
     */
    cursor?: ProductInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInteractions.
     */
    distinct?: ProductInteractionScalarFieldEnum | ProductInteractionScalarFieldEnum[]
  }

  /**
   * ProductInteraction findMany
   */
  export type ProductInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ProductInteractions to fetch.
     */
    where?: ProductInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInteractions to fetch.
     */
    orderBy?: ProductInteractionOrderByWithRelationInput | ProductInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductInteractions.
     */
    cursor?: ProductInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInteractions.
     */
    skip?: number
    distinct?: ProductInteractionScalarFieldEnum | ProductInteractionScalarFieldEnum[]
  }

  /**
   * ProductInteraction create
   */
  export type ProductInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductInteraction.
     */
    data: XOR<ProductInteractionCreateInput, ProductInteractionUncheckedCreateInput>
  }

  /**
   * ProductInteraction createMany
   */
  export type ProductInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductInteractions.
     */
    data: ProductInteractionCreateManyInput | ProductInteractionCreateManyInput[]
  }

  /**
   * ProductInteraction update
   */
  export type ProductInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductInteraction.
     */
    data: XOR<ProductInteractionUpdateInput, ProductInteractionUncheckedUpdateInput>
    /**
     * Choose, which ProductInteraction to update.
     */
    where: ProductInteractionWhereUniqueInput
  }

  /**
   * ProductInteraction updateMany
   */
  export type ProductInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductInteractions.
     */
    data: XOR<ProductInteractionUpdateManyMutationInput, ProductInteractionUncheckedUpdateManyInput>
    /**
     * Filter which ProductInteractions to update
     */
    where?: ProductInteractionWhereInput
    /**
     * Limit how many ProductInteractions to update.
     */
    limit?: number
  }

  /**
   * ProductInteraction upsert
   */
  export type ProductInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductInteraction to update in case it exists.
     */
    where: ProductInteractionWhereUniqueInput
    /**
     * In case the ProductInteraction found by the `where` argument doesn't exist, create a new ProductInteraction with this data.
     */
    create: XOR<ProductInteractionCreateInput, ProductInteractionUncheckedCreateInput>
    /**
     * In case the ProductInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductInteractionUpdateInput, ProductInteractionUncheckedUpdateInput>
  }

  /**
   * ProductInteraction delete
   */
  export type ProductInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
    /**
     * Filter which ProductInteraction to delete.
     */
    where: ProductInteractionWhereUniqueInput
  }

  /**
   * ProductInteraction deleteMany
   */
  export type ProductInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductInteractions to delete
     */
    where?: ProductInteractionWhereInput
    /**
     * Limit how many ProductInteractions to delete.
     */
    limit?: number
  }

  /**
   * ProductInteraction findRaw
   */
  export type ProductInteractionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProductInteraction aggregateRaw
   */
  export type ProductInteractionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProductInteraction without action
   */
  export type ProductInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInteraction
     */
    select?: ProductInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInteraction
     */
    omit?: ProductInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInteractionInclude<ExtArgs> | null
  }


  /**
   * Model BrowsingEvent
   */

  export type AggregateBrowsingEvent = {
    _count: BrowsingEventCountAggregateOutputType | null
    _avg: BrowsingEventAvgAggregateOutputType | null
    _sum: BrowsingEventSumAggregateOutputType | null
    _min: BrowsingEventMinAggregateOutputType | null
    _max: BrowsingEventMaxAggregateOutputType | null
  }

  export type BrowsingEventAvgAggregateOutputType = {
    time_spent: number | null
  }

  export type BrowsingEventSumAggregateOutputType = {
    time_spent: number | null
  }

  export type BrowsingEventMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    session_id: string | null
    page_url: string | null
    page_title: string | null
    time_spent: number | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    device_type: string | null
    createdAt: Date | null
  }

  export type BrowsingEventMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    session_id: string | null
    page_url: string | null
    page_title: string | null
    time_spent: number | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    device_type: string | null
    createdAt: Date | null
  }

  export type BrowsingEventCountAggregateOutputType = {
    id: number
    buyerId: number
    session_id: number
    page_url: number
    page_title: number
    time_spent: number
    user_agent: number
    ip_address: number
    referrer: number
    device_type: number
    createdAt: number
    _all: number
  }


  export type BrowsingEventAvgAggregateInputType = {
    time_spent?: true
  }

  export type BrowsingEventSumAggregateInputType = {
    time_spent?: true
  }

  export type BrowsingEventMinAggregateInputType = {
    id?: true
    buyerId?: true
    session_id?: true
    page_url?: true
    page_title?: true
    time_spent?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    device_type?: true
    createdAt?: true
  }

  export type BrowsingEventMaxAggregateInputType = {
    id?: true
    buyerId?: true
    session_id?: true
    page_url?: true
    page_title?: true
    time_spent?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    device_type?: true
    createdAt?: true
  }

  export type BrowsingEventCountAggregateInputType = {
    id?: true
    buyerId?: true
    session_id?: true
    page_url?: true
    page_title?: true
    time_spent?: true
    user_agent?: true
    ip_address?: true
    referrer?: true
    device_type?: true
    createdAt?: true
    _all?: true
  }

  export type BrowsingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrowsingEvent to aggregate.
     */
    where?: BrowsingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrowsingEvents to fetch.
     */
    orderBy?: BrowsingEventOrderByWithRelationInput | BrowsingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrowsingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrowsingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrowsingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BrowsingEvents
    **/
    _count?: true | BrowsingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrowsingEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrowsingEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrowsingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrowsingEventMaxAggregateInputType
  }

  export type GetBrowsingEventAggregateType<T extends BrowsingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBrowsingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrowsingEvent[P]>
      : GetScalarType<T[P], AggregateBrowsingEvent[P]>
  }




  export type BrowsingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrowsingEventWhereInput
    orderBy?: BrowsingEventOrderByWithAggregationInput | BrowsingEventOrderByWithAggregationInput[]
    by: BrowsingEventScalarFieldEnum[] | BrowsingEventScalarFieldEnum
    having?: BrowsingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrowsingEventCountAggregateInputType | true
    _avg?: BrowsingEventAvgAggregateInputType
    _sum?: BrowsingEventSumAggregateInputType
    _min?: BrowsingEventMinAggregateInputType
    _max?: BrowsingEventMaxAggregateInputType
  }

  export type BrowsingEventGroupByOutputType = {
    id: string
    buyerId: string | null
    session_id: string
    page_url: string
    page_title: string | null
    time_spent: number | null
    user_agent: string | null
    ip_address: string | null
    referrer: string | null
    device_type: string | null
    createdAt: Date
    _count: BrowsingEventCountAggregateOutputType | null
    _avg: BrowsingEventAvgAggregateOutputType | null
    _sum: BrowsingEventSumAggregateOutputType | null
    _min: BrowsingEventMinAggregateOutputType | null
    _max: BrowsingEventMaxAggregateOutputType | null
  }

  type GetBrowsingEventGroupByPayload<T extends BrowsingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrowsingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrowsingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrowsingEventGroupByOutputType[P]>
            : GetScalarType<T[P], BrowsingEventGroupByOutputType[P]>
        }
      >
    >


  export type BrowsingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    session_id?: boolean
    page_url?: boolean
    page_title?: boolean
    time_spent?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referrer?: boolean
    device_type?: boolean
    createdAt?: boolean
    buyer?: boolean | BrowsingEvent$buyerArgs<ExtArgs>
  }, ExtArgs["result"]["browsingEvent"]>



  export type BrowsingEventSelectScalar = {
    id?: boolean
    buyerId?: boolean
    session_id?: boolean
    page_url?: boolean
    page_title?: boolean
    time_spent?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referrer?: boolean
    device_type?: boolean
    createdAt?: boolean
  }

  export type BrowsingEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "session_id" | "page_url" | "page_title" | "time_spent" | "user_agent" | "ip_address" | "referrer" | "device_type" | "createdAt", ExtArgs["result"]["browsingEvent"]>
  export type BrowsingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BrowsingEvent$buyerArgs<ExtArgs>
  }

  export type $BrowsingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BrowsingEvent"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string | null
      session_id: string
      page_url: string
      page_title: string | null
      time_spent: number | null
      user_agent: string | null
      ip_address: string | null
      referrer: string | null
      device_type: string | null
      createdAt: Date
    }, ExtArgs["result"]["browsingEvent"]>
    composites: {}
  }

  type BrowsingEventGetPayload<S extends boolean | null | undefined | BrowsingEventDefaultArgs> = $Result.GetResult<Prisma.$BrowsingEventPayload, S>

  type BrowsingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrowsingEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrowsingEventCountAggregateInputType | true
    }

  export interface BrowsingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BrowsingEvent'], meta: { name: 'BrowsingEvent' } }
    /**
     * Find zero or one BrowsingEvent that matches the filter.
     * @param {BrowsingEventFindUniqueArgs} args - Arguments to find a BrowsingEvent
     * @example
     * // Get one BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrowsingEventFindUniqueArgs>(args: SelectSubset<T, BrowsingEventFindUniqueArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BrowsingEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrowsingEventFindUniqueOrThrowArgs} args - Arguments to find a BrowsingEvent
     * @example
     * // Get one BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrowsingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, BrowsingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BrowsingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventFindFirstArgs} args - Arguments to find a BrowsingEvent
     * @example
     * // Get one BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrowsingEventFindFirstArgs>(args?: SelectSubset<T, BrowsingEventFindFirstArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BrowsingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventFindFirstOrThrowArgs} args - Arguments to find a BrowsingEvent
     * @example
     * // Get one BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrowsingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, BrowsingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BrowsingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BrowsingEvents
     * const browsingEvents = await prisma.browsingEvent.findMany()
     * 
     * // Get first 10 BrowsingEvents
     * const browsingEvents = await prisma.browsingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const browsingEventWithIdOnly = await prisma.browsingEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrowsingEventFindManyArgs>(args?: SelectSubset<T, BrowsingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BrowsingEvent.
     * @param {BrowsingEventCreateArgs} args - Arguments to create a BrowsingEvent.
     * @example
     * // Create one BrowsingEvent
     * const BrowsingEvent = await prisma.browsingEvent.create({
     *   data: {
     *     // ... data to create a BrowsingEvent
     *   }
     * })
     * 
     */
    create<T extends BrowsingEventCreateArgs>(args: SelectSubset<T, BrowsingEventCreateArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BrowsingEvents.
     * @param {BrowsingEventCreateManyArgs} args - Arguments to create many BrowsingEvents.
     * @example
     * // Create many BrowsingEvents
     * const browsingEvent = await prisma.browsingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrowsingEventCreateManyArgs>(args?: SelectSubset<T, BrowsingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BrowsingEvent.
     * @param {BrowsingEventDeleteArgs} args - Arguments to delete one BrowsingEvent.
     * @example
     * // Delete one BrowsingEvent
     * const BrowsingEvent = await prisma.browsingEvent.delete({
     *   where: {
     *     // ... filter to delete one BrowsingEvent
     *   }
     * })
     * 
     */
    delete<T extends BrowsingEventDeleteArgs>(args: SelectSubset<T, BrowsingEventDeleteArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BrowsingEvent.
     * @param {BrowsingEventUpdateArgs} args - Arguments to update one BrowsingEvent.
     * @example
     * // Update one BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrowsingEventUpdateArgs>(args: SelectSubset<T, BrowsingEventUpdateArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BrowsingEvents.
     * @param {BrowsingEventDeleteManyArgs} args - Arguments to filter BrowsingEvents to delete.
     * @example
     * // Delete a few BrowsingEvents
     * const { count } = await prisma.browsingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrowsingEventDeleteManyArgs>(args?: SelectSubset<T, BrowsingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BrowsingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BrowsingEvents
     * const browsingEvent = await prisma.browsingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrowsingEventUpdateManyArgs>(args: SelectSubset<T, BrowsingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BrowsingEvent.
     * @param {BrowsingEventUpsertArgs} args - Arguments to update or create a BrowsingEvent.
     * @example
     * // Update or create a BrowsingEvent
     * const browsingEvent = await prisma.browsingEvent.upsert({
     *   create: {
     *     // ... data to create a BrowsingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BrowsingEvent we want to update
     *   }
     * })
     */
    upsert<T extends BrowsingEventUpsertArgs>(args: SelectSubset<T, BrowsingEventUpsertArgs<ExtArgs>>): Prisma__BrowsingEventClient<$Result.GetResult<Prisma.$BrowsingEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BrowsingEvents that matches the filter.
     * @param {BrowsingEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const browsingEvent = await prisma.browsingEvent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BrowsingEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BrowsingEvent.
     * @param {BrowsingEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const browsingEvent = await prisma.browsingEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BrowsingEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BrowsingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventCountArgs} args - Arguments to filter BrowsingEvents to count.
     * @example
     * // Count the number of BrowsingEvents
     * const count = await prisma.browsingEvent.count({
     *   where: {
     *     // ... the filter for the BrowsingEvents we want to count
     *   }
     * })
    **/
    count<T extends BrowsingEventCountArgs>(
      args?: Subset<T, BrowsingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrowsingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BrowsingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrowsingEventAggregateArgs>(args: Subset<T, BrowsingEventAggregateArgs>): Prisma.PrismaPromise<GetBrowsingEventAggregateType<T>>

    /**
     * Group by BrowsingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrowsingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrowsingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrowsingEventGroupByArgs['orderBy'] }
        : { orderBy?: BrowsingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrowsingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrowsingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BrowsingEvent model
   */
  readonly fields: BrowsingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BrowsingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrowsingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BrowsingEvent$buyerArgs<ExtArgs> = {}>(args?: Subset<T, BrowsingEvent$buyerArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BrowsingEvent model
   */
  interface BrowsingEventFieldRefs {
    readonly id: FieldRef<"BrowsingEvent", 'String'>
    readonly buyerId: FieldRef<"BrowsingEvent", 'String'>
    readonly session_id: FieldRef<"BrowsingEvent", 'String'>
    readonly page_url: FieldRef<"BrowsingEvent", 'String'>
    readonly page_title: FieldRef<"BrowsingEvent", 'String'>
    readonly time_spent: FieldRef<"BrowsingEvent", 'Int'>
    readonly user_agent: FieldRef<"BrowsingEvent", 'String'>
    readonly ip_address: FieldRef<"BrowsingEvent", 'String'>
    readonly referrer: FieldRef<"BrowsingEvent", 'String'>
    readonly device_type: FieldRef<"BrowsingEvent", 'String'>
    readonly createdAt: FieldRef<"BrowsingEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BrowsingEvent findUnique
   */
  export type BrowsingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter, which BrowsingEvent to fetch.
     */
    where: BrowsingEventWhereUniqueInput
  }

  /**
   * BrowsingEvent findUniqueOrThrow
   */
  export type BrowsingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter, which BrowsingEvent to fetch.
     */
    where: BrowsingEventWhereUniqueInput
  }

  /**
   * BrowsingEvent findFirst
   */
  export type BrowsingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter, which BrowsingEvent to fetch.
     */
    where?: BrowsingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrowsingEvents to fetch.
     */
    orderBy?: BrowsingEventOrderByWithRelationInput | BrowsingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrowsingEvents.
     */
    cursor?: BrowsingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrowsingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrowsingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrowsingEvents.
     */
    distinct?: BrowsingEventScalarFieldEnum | BrowsingEventScalarFieldEnum[]
  }

  /**
   * BrowsingEvent findFirstOrThrow
   */
  export type BrowsingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter, which BrowsingEvent to fetch.
     */
    where?: BrowsingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrowsingEvents to fetch.
     */
    orderBy?: BrowsingEventOrderByWithRelationInput | BrowsingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrowsingEvents.
     */
    cursor?: BrowsingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrowsingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrowsingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrowsingEvents.
     */
    distinct?: BrowsingEventScalarFieldEnum | BrowsingEventScalarFieldEnum[]
  }

  /**
   * BrowsingEvent findMany
   */
  export type BrowsingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter, which BrowsingEvents to fetch.
     */
    where?: BrowsingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrowsingEvents to fetch.
     */
    orderBy?: BrowsingEventOrderByWithRelationInput | BrowsingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BrowsingEvents.
     */
    cursor?: BrowsingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrowsingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrowsingEvents.
     */
    skip?: number
    distinct?: BrowsingEventScalarFieldEnum | BrowsingEventScalarFieldEnum[]
  }

  /**
   * BrowsingEvent create
   */
  export type BrowsingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a BrowsingEvent.
     */
    data: XOR<BrowsingEventCreateInput, BrowsingEventUncheckedCreateInput>
  }

  /**
   * BrowsingEvent createMany
   */
  export type BrowsingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BrowsingEvents.
     */
    data: BrowsingEventCreateManyInput | BrowsingEventCreateManyInput[]
  }

  /**
   * BrowsingEvent update
   */
  export type BrowsingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a BrowsingEvent.
     */
    data: XOR<BrowsingEventUpdateInput, BrowsingEventUncheckedUpdateInput>
    /**
     * Choose, which BrowsingEvent to update.
     */
    where: BrowsingEventWhereUniqueInput
  }

  /**
   * BrowsingEvent updateMany
   */
  export type BrowsingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BrowsingEvents.
     */
    data: XOR<BrowsingEventUpdateManyMutationInput, BrowsingEventUncheckedUpdateManyInput>
    /**
     * Filter which BrowsingEvents to update
     */
    where?: BrowsingEventWhereInput
    /**
     * Limit how many BrowsingEvents to update.
     */
    limit?: number
  }

  /**
   * BrowsingEvent upsert
   */
  export type BrowsingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the BrowsingEvent to update in case it exists.
     */
    where: BrowsingEventWhereUniqueInput
    /**
     * In case the BrowsingEvent found by the `where` argument doesn't exist, create a new BrowsingEvent with this data.
     */
    create: XOR<BrowsingEventCreateInput, BrowsingEventUncheckedCreateInput>
    /**
     * In case the BrowsingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrowsingEventUpdateInput, BrowsingEventUncheckedUpdateInput>
  }

  /**
   * BrowsingEvent delete
   */
  export type BrowsingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
    /**
     * Filter which BrowsingEvent to delete.
     */
    where: BrowsingEventWhereUniqueInput
  }

  /**
   * BrowsingEvent deleteMany
   */
  export type BrowsingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrowsingEvents to delete
     */
    where?: BrowsingEventWhereInput
    /**
     * Limit how many BrowsingEvents to delete.
     */
    limit?: number
  }

  /**
   * BrowsingEvent findRaw
   */
  export type BrowsingEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BrowsingEvent aggregateRaw
   */
  export type BrowsingEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BrowsingEvent.buyer
   */
  export type BrowsingEvent$buyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    where?: BuyerWhereInput
  }

  /**
   * BrowsingEvent without action
   */
  export type BrowsingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrowsingEvent
     */
    select?: BrowsingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BrowsingEvent
     */
    omit?: BrowsingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrowsingEventInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    tipo: $Enums.FeedbackType | null
    rating: number | null
    comentario: string | null
    related_order_id: string | null
    related_service_id: string | null
    related_product_id: string | null
    respuesta: string | null
    respondido_por: string | null
    fecha_respuesta: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    tipo: $Enums.FeedbackType | null
    rating: number | null
    comentario: string | null
    related_order_id: string | null
    related_service_id: string | null
    related_product_id: string | null
    respuesta: string | null
    respondido_por: string | null
    fecha_respuesta: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    buyerId: number
    tipo: number
    rating: number
    comentario: number
    related_order_id: number
    related_service_id: number
    related_product_id: number
    respuesta: number
    respondido_por: number
    fecha_respuesta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    buyerId?: true
    tipo?: true
    rating?: true
    comentario?: true
    related_order_id?: true
    related_service_id?: true
    related_product_id?: true
    respuesta?: true
    respondido_por?: true
    fecha_respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    buyerId?: true
    tipo?: true
    rating?: true
    comentario?: true
    related_order_id?: true
    related_service_id?: true
    related_product_id?: true
    respuesta?: true
    respondido_por?: true
    fecha_respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    buyerId?: true
    tipo?: true
    rating?: true
    comentario?: true
    related_order_id?: true
    related_service_id?: true
    related_product_id?: true
    respuesta?: true
    respondido_por?: true
    fecha_respuesta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    buyerId: string
    tipo: $Enums.FeedbackType
    rating: number | null
    comentario: string | null
    related_order_id: string | null
    related_service_id: string | null
    related_product_id: string | null
    respuesta: string | null
    respondido_por: string | null
    fecha_respuesta: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    tipo?: boolean
    rating?: boolean
    comentario?: boolean
    related_order_id?: boolean
    related_service_id?: boolean
    related_product_id?: boolean
    respuesta?: boolean
    respondido_por?: boolean
    fecha_respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>



  export type FeedbackSelectScalar = {
    id?: boolean
    buyerId?: boolean
    tipo?: boolean
    rating?: boolean
    comentario?: boolean
    related_order_id?: boolean
    related_service_id?: boolean
    related_product_id?: boolean
    respuesta?: boolean
    respondido_por?: boolean
    fecha_respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "tipo" | "rating" | "comentario" | "related_order_id" | "related_service_id" | "related_product_id" | "respuesta" | "respondido_por" | "fecha_respuesta" | "createdAt" | "updatedAt", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      tipo: $Enums.FeedbackType
      rating: number | null
      comentario: string | null
      related_order_id: string | null
      related_service_id: string | null
      related_product_id: string | null
      respuesta: string | null
      respondido_por: string | null
      fecha_respuesta: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * @param {FeedbackFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feedback = await prisma.feedback.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FeedbackFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Feedback.
     * @param {FeedbackAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feedback = await prisma.feedback.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FeedbackAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly buyerId: FieldRef<"Feedback", 'String'>
    readonly tipo: FieldRef<"Feedback", 'FeedbackType'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly comentario: FieldRef<"Feedback", 'String'>
    readonly related_order_id: FieldRef<"Feedback", 'String'>
    readonly related_service_id: FieldRef<"Feedback", 'String'>
    readonly related_product_id: FieldRef<"Feedback", 'String'>
    readonly respuesta: FieldRef<"Feedback", 'String'>
    readonly respondido_por: FieldRef<"Feedback", 'String'>
    readonly fecha_respuesta: FieldRef<"Feedback", 'DateTime'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback findRaw
   */
  export type FeedbackFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Feedback aggregateRaw
   */
  export type FeedbackAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    monto_total: number | null
  }

  export type OrderSumAggregateOutputType = {
    monto_total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    fecha_creacion: Date | null
    monto_total: number | null
    estado: string | null
    metodo_pago: string | null
    id_transaccion_pasarela: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    fecha_creacion: Date | null
    monto_total: number | null
    estado: string | null
    metodo_pago: string | null
    id_transaccion_pasarela: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    buyerId: number
    fecha_creacion: number
    monto_total: number
    estado: number
    metodo_pago: number
    info_envio: number
    id_transaccion_pasarela: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    monto_total?: true
  }

  export type OrderSumAggregateInputType = {
    monto_total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
    metodo_pago?: true
    id_transaccion_pasarela?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
    metodo_pago?: true
    id_transaccion_pasarela?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
    metodo_pago?: true
    info_envio?: true
    id_transaccion_pasarela?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    buyerId: string
    fecha_creacion: Date
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio: JsonValue | null
    id_transaccion_pasarela: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    fecha_creacion?: boolean
    monto_total?: boolean
    estado?: boolean
    metodo_pago?: boolean
    info_envio?: boolean
    id_transaccion_pasarela?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    detalles?: boolean | Order$detallesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    buyerId?: boolean
    fecha_creacion?: boolean
    monto_total?: boolean
    estado?: boolean
    metodo_pago?: boolean
    info_envio?: boolean
    id_transaccion_pasarela?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "fecha_creacion" | "monto_total" | "estado" | "metodo_pago" | "info_envio" | "id_transaccion_pasarela", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    detalles?: boolean | Order$detallesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
      detalles: Prisma.$OrderDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      fecha_creacion: Date
      monto_total: number
      estado: string
      metodo_pago: string
      info_envio: Prisma.JsonValue | null
      id_transaccion_pasarela: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detalles<T extends Order$detallesArgs<ExtArgs> = {}>(args?: Subset<T, Order$detallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly buyerId: FieldRef<"Order", 'String'>
    readonly fecha_creacion: FieldRef<"Order", 'DateTime'>
    readonly monto_total: FieldRef<"Order", 'Int'>
    readonly estado: FieldRef<"Order", 'String'>
    readonly metodo_pago: FieldRef<"Order", 'String'>
    readonly info_envio: FieldRef<"Order", 'Json'>
    readonly id_transaccion_pasarela: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order findRaw
   */
  export type OrderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order.detalles
   */
  export type Order$detallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    where?: OrderDetailWhereInput
    orderBy?: OrderDetailOrderByWithRelationInput | OrderDetailOrderByWithRelationInput[]
    cursor?: OrderDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailScalarFieldEnum | OrderDetailScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderDetail
   */

  export type AggregateOrderDetail = {
    _count: OrderDetailCountAggregateOutputType | null
    _avg: OrderDetailAvgAggregateOutputType | null
    _sum: OrderDetailSumAggregateOutputType | null
    _min: OrderDetailMinAggregateOutputType | null
    _max: OrderDetailMaxAggregateOutputType | null
  }

  export type OrderDetailAvgAggregateOutputType = {
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type OrderDetailSumAggregateOutputType = {
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type OrderDetailMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productoId: string | null
    productoName: string | null
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type OrderDetailMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productoId: string | null
    productoName: string | null
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type OrderDetailCountAggregateOutputType = {
    id: number
    orderId: number
    productoId: number
    productoName: number
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    _all: number
  }


  export type OrderDetailAvgAggregateInputType = {
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type OrderDetailSumAggregateInputType = {
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type OrderDetailMinAggregateInputType = {
    id?: true
    orderId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type OrderDetailMaxAggregateInputType = {
    id?: true
    orderId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type OrderDetailCountAggregateInputType = {
    id?: true
    orderId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
    _all?: true
  }

  export type OrderDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetail to aggregate.
     */
    where?: OrderDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailOrderByWithRelationInput | OrderDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderDetails
    **/
    _count?: true | OrderDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDetailMaxAggregateInputType
  }

  export type GetOrderDetailAggregateType<T extends OrderDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDetail[P]>
      : GetScalarType<T[P], AggregateOrderDetail[P]>
  }




  export type OrderDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailWhereInput
    orderBy?: OrderDetailOrderByWithAggregationInput | OrderDetailOrderByWithAggregationInput[]
    by: OrderDetailScalarFieldEnum[] | OrderDetailScalarFieldEnum
    having?: OrderDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDetailCountAggregateInputType | true
    _avg?: OrderDetailAvgAggregateInputType
    _sum?: OrderDetailSumAggregateInputType
    _min?: OrderDetailMinAggregateInputType
    _max?: OrderDetailMaxAggregateInputType
  }

  export type OrderDetailGroupByOutputType = {
    id: string
    orderId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    _count: OrderDetailCountAggregateOutputType | null
    _avg: OrderDetailAvgAggregateOutputType | null
    _sum: OrderDetailSumAggregateOutputType | null
    _min: OrderDetailMinAggregateOutputType | null
    _max: OrderDetailMaxAggregateOutputType | null
  }

  type GetOrderDetailGroupByPayload<T extends OrderDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDetailGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDetailGroupByOutputType[P]>
        }
      >
    >


  export type OrderDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productoId?: boolean
    productoName?: boolean
    cantidad?: boolean
    precio_unitario_al_momento_de_compra?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetail"]>



  export type OrderDetailSelectScalar = {
    id?: boolean
    orderId?: boolean
    productoId?: boolean
    productoName?: boolean
    cantidad?: boolean
    precio_unitario_al_momento_de_compra?: boolean
  }

  export type OrderDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productoId" | "productoName" | "cantidad" | "precio_unitario_al_momento_de_compra", ExtArgs["result"]["orderDetail"]>
  export type OrderDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderDetail"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productoId: string
      productoName: string
      cantidad: number
      precio_unitario_al_momento_de_compra: number
    }, ExtArgs["result"]["orderDetail"]>
    composites: {}
  }

  type OrderDetailGetPayload<S extends boolean | null | undefined | OrderDetailDefaultArgs> = $Result.GetResult<Prisma.$OrderDetailPayload, S>

  type OrderDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderDetailCountAggregateInputType | true
    }

  export interface OrderDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderDetail'], meta: { name: 'OrderDetail' } }
    /**
     * Find zero or one OrderDetail that matches the filter.
     * @param {OrderDetailFindUniqueArgs} args - Arguments to find a OrderDetail
     * @example
     * // Get one OrderDetail
     * const orderDetail = await prisma.orderDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderDetailFindUniqueArgs>(args: SelectSubset<T, OrderDetailFindUniqueArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderDetailFindUniqueOrThrowArgs} args - Arguments to find a OrderDetail
     * @example
     * // Get one OrderDetail
     * const orderDetail = await prisma.orderDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailFindFirstArgs} args - Arguments to find a OrderDetail
     * @example
     * // Get one OrderDetail
     * const orderDetail = await prisma.orderDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderDetailFindFirstArgs>(args?: SelectSubset<T, OrderDetailFindFirstArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailFindFirstOrThrowArgs} args - Arguments to find a OrderDetail
     * @example
     * // Get one OrderDetail
     * const orderDetail = await prisma.orderDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDetails
     * const orderDetails = await prisma.orderDetail.findMany()
     * 
     * // Get first 10 OrderDetails
     * const orderDetails = await prisma.orderDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderDetailWithIdOnly = await prisma.orderDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderDetailFindManyArgs>(args?: SelectSubset<T, OrderDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderDetail.
     * @param {OrderDetailCreateArgs} args - Arguments to create a OrderDetail.
     * @example
     * // Create one OrderDetail
     * const OrderDetail = await prisma.orderDetail.create({
     *   data: {
     *     // ... data to create a OrderDetail
     *   }
     * })
     * 
     */
    create<T extends OrderDetailCreateArgs>(args: SelectSubset<T, OrderDetailCreateArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderDetails.
     * @param {OrderDetailCreateManyArgs} args - Arguments to create many OrderDetails.
     * @example
     * // Create many OrderDetails
     * const orderDetail = await prisma.orderDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderDetailCreateManyArgs>(args?: SelectSubset<T, OrderDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderDetail.
     * @param {OrderDetailDeleteArgs} args - Arguments to delete one OrderDetail.
     * @example
     * // Delete one OrderDetail
     * const OrderDetail = await prisma.orderDetail.delete({
     *   where: {
     *     // ... filter to delete one OrderDetail
     *   }
     * })
     * 
     */
    delete<T extends OrderDetailDeleteArgs>(args: SelectSubset<T, OrderDetailDeleteArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderDetail.
     * @param {OrderDetailUpdateArgs} args - Arguments to update one OrderDetail.
     * @example
     * // Update one OrderDetail
     * const orderDetail = await prisma.orderDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderDetailUpdateArgs>(args: SelectSubset<T, OrderDetailUpdateArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderDetails.
     * @param {OrderDetailDeleteManyArgs} args - Arguments to filter OrderDetails to delete.
     * @example
     * // Delete a few OrderDetails
     * const { count } = await prisma.orderDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDetailDeleteManyArgs>(args?: SelectSubset<T, OrderDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDetails
     * const orderDetail = await prisma.orderDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderDetailUpdateManyArgs>(args: SelectSubset<T, OrderDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderDetail.
     * @param {OrderDetailUpsertArgs} args - Arguments to update or create a OrderDetail.
     * @example
     * // Update or create a OrderDetail
     * const orderDetail = await prisma.orderDetail.upsert({
     *   create: {
     *     // ... data to create a OrderDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDetail we want to update
     *   }
     * })
     */
    upsert<T extends OrderDetailUpsertArgs>(args: SelectSubset<T, OrderDetailUpsertArgs<ExtArgs>>): Prisma__OrderDetailClient<$Result.GetResult<Prisma.$OrderDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderDetails that matches the filter.
     * @param {OrderDetailFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const orderDetail = await prisma.orderDetail.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderDetailFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OrderDetail.
     * @param {OrderDetailAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const orderDetail = await prisma.orderDetail.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderDetailAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailCountArgs} args - Arguments to filter OrderDetails to count.
     * @example
     * // Count the number of OrderDetails
     * const count = await prisma.orderDetail.count({
     *   where: {
     *     // ... the filter for the OrderDetails we want to count
     *   }
     * })
    **/
    count<T extends OrderDetailCountArgs>(
      args?: Subset<T, OrderDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDetailAggregateArgs>(args: Subset<T, OrderDetailAggregateArgs>): Prisma.PrismaPromise<GetOrderDetailAggregateType<T>>

    /**
     * Group by OrderDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDetailGroupByArgs['orderBy'] }
        : { orderBy?: OrderDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderDetail model
   */
  readonly fields: OrderDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderDetail model
   */
  interface OrderDetailFieldRefs {
    readonly id: FieldRef<"OrderDetail", 'String'>
    readonly orderId: FieldRef<"OrderDetail", 'String'>
    readonly productoId: FieldRef<"OrderDetail", 'String'>
    readonly productoName: FieldRef<"OrderDetail", 'String'>
    readonly cantidad: FieldRef<"OrderDetail", 'Int'>
    readonly precio_unitario_al_momento_de_compra: FieldRef<"OrderDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderDetail findUnique
   */
  export type OrderDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetail to fetch.
     */
    where: OrderDetailWhereUniqueInput
  }

  /**
   * OrderDetail findUniqueOrThrow
   */
  export type OrderDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetail to fetch.
     */
    where: OrderDetailWhereUniqueInput
  }

  /**
   * OrderDetail findFirst
   */
  export type OrderDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetail to fetch.
     */
    where?: OrderDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailOrderByWithRelationInput | OrderDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailScalarFieldEnum | OrderDetailScalarFieldEnum[]
  }

  /**
   * OrderDetail findFirstOrThrow
   */
  export type OrderDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetail to fetch.
     */
    where?: OrderDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailOrderByWithRelationInput | OrderDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailScalarFieldEnum | OrderDetailScalarFieldEnum[]
  }

  /**
   * OrderDetail findMany
   */
  export type OrderDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailOrderByWithRelationInput | OrderDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderDetails.
     */
    cursor?: OrderDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    distinct?: OrderDetailScalarFieldEnum | OrderDetailScalarFieldEnum[]
  }

  /**
   * OrderDetail create
   */
  export type OrderDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderDetail.
     */
    data: XOR<OrderDetailCreateInput, OrderDetailUncheckedCreateInput>
  }

  /**
   * OrderDetail createMany
   */
  export type OrderDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderDetails.
     */
    data: OrderDetailCreateManyInput | OrderDetailCreateManyInput[]
  }

  /**
   * OrderDetail update
   */
  export type OrderDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderDetail.
     */
    data: XOR<OrderDetailUpdateInput, OrderDetailUncheckedUpdateInput>
    /**
     * Choose, which OrderDetail to update.
     */
    where: OrderDetailWhereUniqueInput
  }

  /**
   * OrderDetail updateMany
   */
  export type OrderDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderDetails.
     */
    data: XOR<OrderDetailUpdateManyMutationInput, OrderDetailUncheckedUpdateManyInput>
    /**
     * Filter which OrderDetails to update
     */
    where?: OrderDetailWhereInput
    /**
     * Limit how many OrderDetails to update.
     */
    limit?: number
  }

  /**
   * OrderDetail upsert
   */
  export type OrderDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderDetail to update in case it exists.
     */
    where: OrderDetailWhereUniqueInput
    /**
     * In case the OrderDetail found by the `where` argument doesn't exist, create a new OrderDetail with this data.
     */
    create: XOR<OrderDetailCreateInput, OrderDetailUncheckedCreateInput>
    /**
     * In case the OrderDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDetailUpdateInput, OrderDetailUncheckedUpdateInput>
  }

  /**
   * OrderDetail delete
   */
  export type OrderDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
    /**
     * Filter which OrderDetail to delete.
     */
    where: OrderDetailWhereUniqueInput
  }

  /**
   * OrderDetail deleteMany
   */
  export type OrderDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetails to delete
     */
    where?: OrderDetailWhereInput
    /**
     * Limit how many OrderDetails to delete.
     */
    limit?: number
  }

  /**
   * OrderDetail findRaw
   */
  export type OrderDetailFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OrderDetail aggregateRaw
   */
  export type OrderDetailAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OrderDetail without action
   */
  export type OrderDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetail
     */
    select?: OrderDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetail
     */
    omit?: OrderDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailInclude<ExtArgs> | null
  }


  /**
   * Model POSSale
   */

  export type AggregatePOSSale = {
    _count: POSSaleCountAggregateOutputType | null
    _avg: POSSaleAvgAggregateOutputType | null
    _sum: POSSaleSumAggregateOutputType | null
    _min: POSSaleMinAggregateOutputType | null
    _max: POSSaleMaxAggregateOutputType | null
  }

  export type POSSaleAvgAggregateOutputType = {
    monto_total: number | null
  }

  export type POSSaleSumAggregateOutputType = {
    monto_total: number | null
  }

  export type POSSaleMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    fecha_creacion: Date | null
    monto_total: number | null
    estado: string | null
  }

  export type POSSaleMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    fecha_creacion: Date | null
    monto_total: number | null
    estado: string | null
  }

  export type POSSaleCountAggregateOutputType = {
    id: number
    buyerId: number
    fecha_creacion: number
    monto_total: number
    estado: number
    metodo_pago: number
    _all: number
  }


  export type POSSaleAvgAggregateInputType = {
    monto_total?: true
  }

  export type POSSaleSumAggregateInputType = {
    monto_total?: true
  }

  export type POSSaleMinAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
  }

  export type POSSaleMaxAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
  }

  export type POSSaleCountAggregateInputType = {
    id?: true
    buyerId?: true
    fecha_creacion?: true
    monto_total?: true
    estado?: true
    metodo_pago?: true
    _all?: true
  }

  export type POSSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSale to aggregate.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSSales
    **/
    _count?: true | POSSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSSaleMaxAggregateInputType
  }

  export type GetPOSSaleAggregateType<T extends POSSaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSSale[P]>
      : GetScalarType<T[P], AggregatePOSSale[P]>
  }




  export type POSSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithAggregationInput | POSSaleOrderByWithAggregationInput[]
    by: POSSaleScalarFieldEnum[] | POSSaleScalarFieldEnum
    having?: POSSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSSaleCountAggregateInputType | true
    _avg?: POSSaleAvgAggregateInputType
    _sum?: POSSaleSumAggregateInputType
    _min?: POSSaleMinAggregateInputType
    _max?: POSSaleMaxAggregateInputType
  }

  export type POSSaleGroupByOutputType = {
    id: string
    buyerId: string
    fecha_creacion: Date
    monto_total: number
    estado: string
    metodo_pago: JsonValue | null
    _count: POSSaleCountAggregateOutputType | null
    _avg: POSSaleAvgAggregateOutputType | null
    _sum: POSSaleSumAggregateOutputType | null
    _min: POSSaleMinAggregateOutputType | null
    _max: POSSaleMaxAggregateOutputType | null
  }

  type GetPOSSaleGroupByPayload<T extends POSSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSSaleGroupByOutputType[P]>
            : GetScalarType<T[P], POSSaleGroupByOutputType[P]>
        }
      >
    >


  export type POSSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    fecha_creacion?: boolean
    monto_total?: boolean
    estado?: boolean
    metodo_pago?: boolean
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    detalles?: boolean | POSSale$detallesArgs<ExtArgs>
    _count?: boolean | POSSaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSale"]>



  export type POSSaleSelectScalar = {
    id?: boolean
    buyerId?: boolean
    fecha_creacion?: boolean
    monto_total?: boolean
    estado?: boolean
    metodo_pago?: boolean
  }

  export type POSSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "fecha_creacion" | "monto_total" | "estado" | "metodo_pago", ExtArgs["result"]["pOSSale"]>
  export type POSSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | BuyerDefaultArgs<ExtArgs>
    detalles?: boolean | POSSale$detallesArgs<ExtArgs>
    _count?: boolean | POSSaleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $POSSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSSale"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs>
      detalles: Prisma.$POSSaleDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string
      fecha_creacion: Date
      monto_total: number
      estado: string
      metodo_pago: Prisma.JsonValue | null
    }, ExtArgs["result"]["pOSSale"]>
    composites: {}
  }

  type POSSaleGetPayload<S extends boolean | null | undefined | POSSaleDefaultArgs> = $Result.GetResult<Prisma.$POSSalePayload, S>

  type POSSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSSaleCountAggregateInputType | true
    }

  export interface POSSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSSale'], meta: { name: 'POSSale' } }
    /**
     * Find zero or one POSSale that matches the filter.
     * @param {POSSaleFindUniqueArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSSaleFindUniqueArgs>(args: SelectSubset<T, POSSaleFindUniqueArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSSaleFindUniqueOrThrowArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, POSSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindFirstArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSSaleFindFirstArgs>(args?: SelectSubset<T, POSSaleFindFirstArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindFirstOrThrowArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, POSSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSSales
     * const pOSSales = await prisma.pOSSale.findMany()
     * 
     * // Get first 10 POSSales
     * const pOSSales = await prisma.pOSSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSSaleWithIdOnly = await prisma.pOSSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSSaleFindManyArgs>(args?: SelectSubset<T, POSSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSSale.
     * @param {POSSaleCreateArgs} args - Arguments to create a POSSale.
     * @example
     * // Create one POSSale
     * const POSSale = await prisma.pOSSale.create({
     *   data: {
     *     // ... data to create a POSSale
     *   }
     * })
     * 
     */
    create<T extends POSSaleCreateArgs>(args: SelectSubset<T, POSSaleCreateArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSSales.
     * @param {POSSaleCreateManyArgs} args - Arguments to create many POSSales.
     * @example
     * // Create many POSSales
     * const pOSSale = await prisma.pOSSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSSaleCreateManyArgs>(args?: SelectSubset<T, POSSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a POSSale.
     * @param {POSSaleDeleteArgs} args - Arguments to delete one POSSale.
     * @example
     * // Delete one POSSale
     * const POSSale = await prisma.pOSSale.delete({
     *   where: {
     *     // ... filter to delete one POSSale
     *   }
     * })
     * 
     */
    delete<T extends POSSaleDeleteArgs>(args: SelectSubset<T, POSSaleDeleteArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSSale.
     * @param {POSSaleUpdateArgs} args - Arguments to update one POSSale.
     * @example
     * // Update one POSSale
     * const pOSSale = await prisma.pOSSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSSaleUpdateArgs>(args: SelectSubset<T, POSSaleUpdateArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSSales.
     * @param {POSSaleDeleteManyArgs} args - Arguments to filter POSSales to delete.
     * @example
     * // Delete a few POSSales
     * const { count } = await prisma.pOSSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSSaleDeleteManyArgs>(args?: SelectSubset<T, POSSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSSales
     * const pOSSale = await prisma.pOSSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSSaleUpdateManyArgs>(args: SelectSubset<T, POSSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POSSale.
     * @param {POSSaleUpsertArgs} args - Arguments to update or create a POSSale.
     * @example
     * // Update or create a POSSale
     * const pOSSale = await prisma.pOSSale.upsert({
     *   create: {
     *     // ... data to create a POSSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSSale we want to update
     *   }
     * })
     */
    upsert<T extends POSSaleUpsertArgs>(args: SelectSubset<T, POSSaleUpsertArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSales that matches the filter.
     * @param {POSSaleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pOSSale = await prisma.pOSSale.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: POSSaleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a POSSale.
     * @param {POSSaleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pOSSale = await prisma.pOSSale.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: POSSaleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of POSSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleCountArgs} args - Arguments to filter POSSales to count.
     * @example
     * // Count the number of POSSales
     * const count = await prisma.pOSSale.count({
     *   where: {
     *     // ... the filter for the POSSales we want to count
     *   }
     * })
    **/
    count<T extends POSSaleCountArgs>(
      args?: Subset<T, POSSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSSaleAggregateArgs>(args: Subset<T, POSSaleAggregateArgs>): Prisma.PrismaPromise<GetPOSSaleAggregateType<T>>

    /**
     * Group by POSSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSSaleGroupByArgs['orderBy'] }
        : { orderBy?: POSSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSSale model
   */
  readonly fields: POSSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends BuyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuyerDefaultArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detalles<T extends POSSale$detallesArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$detallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSSale model
   */
  interface POSSaleFieldRefs {
    readonly id: FieldRef<"POSSale", 'String'>
    readonly buyerId: FieldRef<"POSSale", 'String'>
    readonly fecha_creacion: FieldRef<"POSSale", 'DateTime'>
    readonly monto_total: FieldRef<"POSSale", 'Int'>
    readonly estado: FieldRef<"POSSale", 'String'>
    readonly metodo_pago: FieldRef<"POSSale", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * POSSale findUnique
   */
  export type POSSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale findUniqueOrThrow
   */
  export type POSSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale findFirst
   */
  export type POSSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSales.
     */
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale findFirstOrThrow
   */
  export type POSSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSales.
     */
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale findMany
   */
  export type POSSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSales to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale create
   */
  export type POSSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a POSSale.
     */
    data: XOR<POSSaleCreateInput, POSSaleUncheckedCreateInput>
  }

  /**
   * POSSale createMany
   */
  export type POSSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSSales.
     */
    data: POSSaleCreateManyInput | POSSaleCreateManyInput[]
  }

  /**
   * POSSale update
   */
  export type POSSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a POSSale.
     */
    data: XOR<POSSaleUpdateInput, POSSaleUncheckedUpdateInput>
    /**
     * Choose, which POSSale to update.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale updateMany
   */
  export type POSSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSSales.
     */
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyInput>
    /**
     * Filter which POSSales to update
     */
    where?: POSSaleWhereInput
    /**
     * Limit how many POSSales to update.
     */
    limit?: number
  }

  /**
   * POSSale upsert
   */
  export type POSSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the POSSale to update in case it exists.
     */
    where: POSSaleWhereUniqueInput
    /**
     * In case the POSSale found by the `where` argument doesn't exist, create a new POSSale with this data.
     */
    create: XOR<POSSaleCreateInput, POSSaleUncheckedCreateInput>
    /**
     * In case the POSSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSSaleUpdateInput, POSSaleUncheckedUpdateInput>
  }

  /**
   * POSSale delete
   */
  export type POSSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter which POSSale to delete.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale deleteMany
   */
  export type POSSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSales to delete
     */
    where?: POSSaleWhereInput
    /**
     * Limit how many POSSales to delete.
     */
    limit?: number
  }

  /**
   * POSSale findRaw
   */
  export type POSSaleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * POSSale aggregateRaw
   */
  export type POSSaleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * POSSale.detalles
   */
  export type POSSale$detallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    where?: POSSaleDetailWhereInput
    orderBy?: POSSaleDetailOrderByWithRelationInput | POSSaleDetailOrderByWithRelationInput[]
    cursor?: POSSaleDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleDetailScalarFieldEnum | POSSaleDetailScalarFieldEnum[]
  }

  /**
   * POSSale without action
   */
  export type POSSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
  }


  /**
   * Model POSSaleDetail
   */

  export type AggregatePOSSaleDetail = {
    _count: POSSaleDetailCountAggregateOutputType | null
    _avg: POSSaleDetailAvgAggregateOutputType | null
    _sum: POSSaleDetailSumAggregateOutputType | null
    _min: POSSaleDetailMinAggregateOutputType | null
    _max: POSSaleDetailMaxAggregateOutputType | null
  }

  export type POSSaleDetailAvgAggregateOutputType = {
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type POSSaleDetailSumAggregateOutputType = {
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type POSSaleDetailMinAggregateOutputType = {
    id: string | null
    posSaleId: string | null
    productoId: string | null
    productoName: string | null
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type POSSaleDetailMaxAggregateOutputType = {
    id: string | null
    posSaleId: string | null
    productoId: string | null
    productoName: string | null
    cantidad: number | null
    precio_unitario_al_momento_de_compra: number | null
  }

  export type POSSaleDetailCountAggregateOutputType = {
    id: number
    posSaleId: number
    productoId: number
    productoName: number
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    _all: number
  }


  export type POSSaleDetailAvgAggregateInputType = {
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type POSSaleDetailSumAggregateInputType = {
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type POSSaleDetailMinAggregateInputType = {
    id?: true
    posSaleId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type POSSaleDetailMaxAggregateInputType = {
    id?: true
    posSaleId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
  }

  export type POSSaleDetailCountAggregateInputType = {
    id?: true
    posSaleId?: true
    productoId?: true
    productoName?: true
    cantidad?: true
    precio_unitario_al_momento_de_compra?: true
    _all?: true
  }

  export type POSSaleDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSaleDetail to aggregate.
     */
    where?: POSSaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleDetails to fetch.
     */
    orderBy?: POSSaleDetailOrderByWithRelationInput | POSSaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSSaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSSaleDetails
    **/
    _count?: true | POSSaleDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSSaleDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSSaleDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSSaleDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSSaleDetailMaxAggregateInputType
  }

  export type GetPOSSaleDetailAggregateType<T extends POSSaleDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSSaleDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSSaleDetail[P]>
      : GetScalarType<T[P], AggregatePOSSaleDetail[P]>
  }




  export type POSSaleDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleDetailWhereInput
    orderBy?: POSSaleDetailOrderByWithAggregationInput | POSSaleDetailOrderByWithAggregationInput[]
    by: POSSaleDetailScalarFieldEnum[] | POSSaleDetailScalarFieldEnum
    having?: POSSaleDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSSaleDetailCountAggregateInputType | true
    _avg?: POSSaleDetailAvgAggregateInputType
    _sum?: POSSaleDetailSumAggregateInputType
    _min?: POSSaleDetailMinAggregateInputType
    _max?: POSSaleDetailMaxAggregateInputType
  }

  export type POSSaleDetailGroupByOutputType = {
    id: string
    posSaleId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    _count: POSSaleDetailCountAggregateOutputType | null
    _avg: POSSaleDetailAvgAggregateOutputType | null
    _sum: POSSaleDetailSumAggregateOutputType | null
    _min: POSSaleDetailMinAggregateOutputType | null
    _max: POSSaleDetailMaxAggregateOutputType | null
  }

  type GetPOSSaleDetailGroupByPayload<T extends POSSaleDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSSaleDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSSaleDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSSaleDetailGroupByOutputType[P]>
            : GetScalarType<T[P], POSSaleDetailGroupByOutputType[P]>
        }
      >
    >


  export type POSSaleDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    posSaleId?: boolean
    productoId?: boolean
    productoName?: boolean
    cantidad?: boolean
    precio_unitario_al_momento_de_compra?: boolean
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSaleDetail"]>



  export type POSSaleDetailSelectScalar = {
    id?: boolean
    posSaleId?: boolean
    productoId?: boolean
    productoName?: boolean
    cantidad?: boolean
    precio_unitario_al_momento_de_compra?: boolean
  }

  export type POSSaleDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "posSaleId" | "productoId" | "productoName" | "cantidad" | "precio_unitario_al_momento_de_compra", ExtArgs["result"]["pOSSaleDetail"]>
  export type POSSaleDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }

  export type $POSSaleDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSSaleDetail"
    objects: {
      posSale: Prisma.$POSSalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      posSaleId: string
      productoId: string
      productoName: string
      cantidad: number
      precio_unitario_al_momento_de_compra: number
    }, ExtArgs["result"]["pOSSaleDetail"]>
    composites: {}
  }

  type POSSaleDetailGetPayload<S extends boolean | null | undefined | POSSaleDetailDefaultArgs> = $Result.GetResult<Prisma.$POSSaleDetailPayload, S>

  type POSSaleDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSSaleDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSSaleDetailCountAggregateInputType | true
    }

  export interface POSSaleDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSSaleDetail'], meta: { name: 'POSSaleDetail' } }
    /**
     * Find zero or one POSSaleDetail that matches the filter.
     * @param {POSSaleDetailFindUniqueArgs} args - Arguments to find a POSSaleDetail
     * @example
     * // Get one POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSSaleDetailFindUniqueArgs>(args: SelectSubset<T, POSSaleDetailFindUniqueArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSSaleDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSSaleDetailFindUniqueOrThrowArgs} args - Arguments to find a POSSaleDetail
     * @example
     * // Get one POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSSaleDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, POSSaleDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSaleDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailFindFirstArgs} args - Arguments to find a POSSaleDetail
     * @example
     * // Get one POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSSaleDetailFindFirstArgs>(args?: SelectSubset<T, POSSaleDetailFindFirstArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSaleDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailFindFirstOrThrowArgs} args - Arguments to find a POSSaleDetail
     * @example
     * // Get one POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSSaleDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, POSSaleDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSaleDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSSaleDetails
     * const pOSSaleDetails = await prisma.pOSSaleDetail.findMany()
     * 
     * // Get first 10 POSSaleDetails
     * const pOSSaleDetails = await prisma.pOSSaleDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSSaleDetailWithIdOnly = await prisma.pOSSaleDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSSaleDetailFindManyArgs>(args?: SelectSubset<T, POSSaleDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSSaleDetail.
     * @param {POSSaleDetailCreateArgs} args - Arguments to create a POSSaleDetail.
     * @example
     * // Create one POSSaleDetail
     * const POSSaleDetail = await prisma.pOSSaleDetail.create({
     *   data: {
     *     // ... data to create a POSSaleDetail
     *   }
     * })
     * 
     */
    create<T extends POSSaleDetailCreateArgs>(args: SelectSubset<T, POSSaleDetailCreateArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSSaleDetails.
     * @param {POSSaleDetailCreateManyArgs} args - Arguments to create many POSSaleDetails.
     * @example
     * // Create many POSSaleDetails
     * const pOSSaleDetail = await prisma.pOSSaleDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSSaleDetailCreateManyArgs>(args?: SelectSubset<T, POSSaleDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a POSSaleDetail.
     * @param {POSSaleDetailDeleteArgs} args - Arguments to delete one POSSaleDetail.
     * @example
     * // Delete one POSSaleDetail
     * const POSSaleDetail = await prisma.pOSSaleDetail.delete({
     *   where: {
     *     // ... filter to delete one POSSaleDetail
     *   }
     * })
     * 
     */
    delete<T extends POSSaleDetailDeleteArgs>(args: SelectSubset<T, POSSaleDetailDeleteArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSSaleDetail.
     * @param {POSSaleDetailUpdateArgs} args - Arguments to update one POSSaleDetail.
     * @example
     * // Update one POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSSaleDetailUpdateArgs>(args: SelectSubset<T, POSSaleDetailUpdateArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSSaleDetails.
     * @param {POSSaleDetailDeleteManyArgs} args - Arguments to filter POSSaleDetails to delete.
     * @example
     * // Delete a few POSSaleDetails
     * const { count } = await prisma.pOSSaleDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSSaleDetailDeleteManyArgs>(args?: SelectSubset<T, POSSaleDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSaleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSSaleDetails
     * const pOSSaleDetail = await prisma.pOSSaleDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSSaleDetailUpdateManyArgs>(args: SelectSubset<T, POSSaleDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one POSSaleDetail.
     * @param {POSSaleDetailUpsertArgs} args - Arguments to update or create a POSSaleDetail.
     * @example
     * // Update or create a POSSaleDetail
     * const pOSSaleDetail = await prisma.pOSSaleDetail.upsert({
     *   create: {
     *     // ... data to create a POSSaleDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSSaleDetail we want to update
     *   }
     * })
     */
    upsert<T extends POSSaleDetailUpsertArgs>(args: SelectSubset<T, POSSaleDetailUpsertArgs<ExtArgs>>): Prisma__POSSaleDetailClient<$Result.GetResult<Prisma.$POSSaleDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSaleDetails that matches the filter.
     * @param {POSSaleDetailFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pOSSaleDetail = await prisma.pOSSaleDetail.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: POSSaleDetailFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a POSSaleDetail.
     * @param {POSSaleDetailAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pOSSaleDetail = await prisma.pOSSaleDetail.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: POSSaleDetailAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of POSSaleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailCountArgs} args - Arguments to filter POSSaleDetails to count.
     * @example
     * // Count the number of POSSaleDetails
     * const count = await prisma.pOSSaleDetail.count({
     *   where: {
     *     // ... the filter for the POSSaleDetails we want to count
     *   }
     * })
    **/
    count<T extends POSSaleDetailCountArgs>(
      args?: Subset<T, POSSaleDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSSaleDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSSaleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSSaleDetailAggregateArgs>(args: Subset<T, POSSaleDetailAggregateArgs>): Prisma.PrismaPromise<GetPOSSaleDetailAggregateType<T>>

    /**
     * Group by POSSaleDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSSaleDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSSaleDetailGroupByArgs['orderBy'] }
        : { orderBy?: POSSaleDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSSaleDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSSaleDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSSaleDetail model
   */
  readonly fields: POSSaleDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSSaleDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSSaleDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posSale<T extends POSSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSSaleDefaultArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSSaleDetail model
   */
  interface POSSaleDetailFieldRefs {
    readonly id: FieldRef<"POSSaleDetail", 'String'>
    readonly posSaleId: FieldRef<"POSSaleDetail", 'String'>
    readonly productoId: FieldRef<"POSSaleDetail", 'String'>
    readonly productoName: FieldRef<"POSSaleDetail", 'String'>
    readonly cantidad: FieldRef<"POSSaleDetail", 'Int'>
    readonly precio_unitario_al_momento_de_compra: FieldRef<"POSSaleDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * POSSaleDetail findUnique
   */
  export type POSSaleDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleDetail to fetch.
     */
    where: POSSaleDetailWhereUniqueInput
  }

  /**
   * POSSaleDetail findUniqueOrThrow
   */
  export type POSSaleDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleDetail to fetch.
     */
    where: POSSaleDetailWhereUniqueInput
  }

  /**
   * POSSaleDetail findFirst
   */
  export type POSSaleDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleDetail to fetch.
     */
    where?: POSSaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleDetails to fetch.
     */
    orderBy?: POSSaleDetailOrderByWithRelationInput | POSSaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSaleDetails.
     */
    cursor?: POSSaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSaleDetails.
     */
    distinct?: POSSaleDetailScalarFieldEnum | POSSaleDetailScalarFieldEnum[]
  }

  /**
   * POSSaleDetail findFirstOrThrow
   */
  export type POSSaleDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleDetail to fetch.
     */
    where?: POSSaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleDetails to fetch.
     */
    orderBy?: POSSaleDetailOrderByWithRelationInput | POSSaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSaleDetails.
     */
    cursor?: POSSaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSaleDetails.
     */
    distinct?: POSSaleDetailScalarFieldEnum | POSSaleDetailScalarFieldEnum[]
  }

  /**
   * POSSaleDetail findMany
   */
  export type POSSaleDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleDetails to fetch.
     */
    where?: POSSaleDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleDetails to fetch.
     */
    orderBy?: POSSaleDetailOrderByWithRelationInput | POSSaleDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSSaleDetails.
     */
    cursor?: POSSaleDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleDetails.
     */
    skip?: number
    distinct?: POSSaleDetailScalarFieldEnum | POSSaleDetailScalarFieldEnum[]
  }

  /**
   * POSSaleDetail create
   */
  export type POSSaleDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a POSSaleDetail.
     */
    data: XOR<POSSaleDetailCreateInput, POSSaleDetailUncheckedCreateInput>
  }

  /**
   * POSSaleDetail createMany
   */
  export type POSSaleDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSSaleDetails.
     */
    data: POSSaleDetailCreateManyInput | POSSaleDetailCreateManyInput[]
  }

  /**
   * POSSaleDetail update
   */
  export type POSSaleDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a POSSaleDetail.
     */
    data: XOR<POSSaleDetailUpdateInput, POSSaleDetailUncheckedUpdateInput>
    /**
     * Choose, which POSSaleDetail to update.
     */
    where: POSSaleDetailWhereUniqueInput
  }

  /**
   * POSSaleDetail updateMany
   */
  export type POSSaleDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSSaleDetails.
     */
    data: XOR<POSSaleDetailUpdateManyMutationInput, POSSaleDetailUncheckedUpdateManyInput>
    /**
     * Filter which POSSaleDetails to update
     */
    where?: POSSaleDetailWhereInput
    /**
     * Limit how many POSSaleDetails to update.
     */
    limit?: number
  }

  /**
   * POSSaleDetail upsert
   */
  export type POSSaleDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the POSSaleDetail to update in case it exists.
     */
    where: POSSaleDetailWhereUniqueInput
    /**
     * In case the POSSaleDetail found by the `where` argument doesn't exist, create a new POSSaleDetail with this data.
     */
    create: XOR<POSSaleDetailCreateInput, POSSaleDetailUncheckedCreateInput>
    /**
     * In case the POSSaleDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSSaleDetailUpdateInput, POSSaleDetailUncheckedUpdateInput>
  }

  /**
   * POSSaleDetail delete
   */
  export type POSSaleDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
    /**
     * Filter which POSSaleDetail to delete.
     */
    where: POSSaleDetailWhereUniqueInput
  }

  /**
   * POSSaleDetail deleteMany
   */
  export type POSSaleDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSaleDetails to delete
     */
    where?: POSSaleDetailWhereInput
    /**
     * Limit how many POSSaleDetails to delete.
     */
    limit?: number
  }

  /**
   * POSSaleDetail findRaw
   */
  export type POSSaleDetailFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * POSSaleDetail aggregateRaw
   */
  export type POSSaleDetailAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * POSSaleDetail without action
   */
  export type POSSaleDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleDetail
     */
    select?: POSSaleDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleDetail
     */
    omit?: POSSaleDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleDetailInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    total: number | null
    discount: number | null
  }

  export type ServiceSumAggregateOutputType = {
    total: number | null
    discount: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    customerDeviceId: string | null
    state: string | null
    diagnostico: string | null
    estado_dispositivo_al_ingresar: $Enums.DeviceStatus | null
    observaciones: string | null
    repair: string | null
    total: number | null
    discount: number | null
    date: Date | null
    dateOut: Date | null
    fecha_presupuesto: Date | null
    fecha_aprobacion: Date | null
    garantia_hasta: Date | null
    observaciones_garantia: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    customerDeviceId: string | null
    state: string | null
    diagnostico: string | null
    estado_dispositivo_al_ingresar: $Enums.DeviceStatus | null
    observaciones: string | null
    repair: string | null
    total: number | null
    discount: number | null
    date: Date | null
    dateOut: Date | null
    fecha_presupuesto: Date | null
    fecha_aprobacion: Date | null
    garantia_hasta: Date | null
    observaciones_garantia: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    buyerId: number
    customerDeviceId: number
    device: number
    client: number
    state: number
    diagnostico: number
    estado_dispositivo_al_ingresar: number
    observaciones: number
    repair: number
    piezas: number
    total: number
    discount: number
    date: number
    dateOut: number
    fecha_presupuesto: number
    fecha_aprobacion: number
    garantia_hasta: number
    observaciones_garantia: number
    payments: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    total?: true
    discount?: true
  }

  export type ServiceSumAggregateInputType = {
    total?: true
    discount?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    buyerId?: true
    customerDeviceId?: true
    state?: true
    diagnostico?: true
    estado_dispositivo_al_ingresar?: true
    observaciones?: true
    repair?: true
    total?: true
    discount?: true
    date?: true
    dateOut?: true
    fecha_presupuesto?: true
    fecha_aprobacion?: true
    garantia_hasta?: true
    observaciones_garantia?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    buyerId?: true
    customerDeviceId?: true
    state?: true
    diagnostico?: true
    estado_dispositivo_al_ingresar?: true
    observaciones?: true
    repair?: true
    total?: true
    discount?: true
    date?: true
    dateOut?: true
    fecha_presupuesto?: true
    fecha_aprobacion?: true
    garantia_hasta?: true
    observaciones_garantia?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    buyerId?: true
    customerDeviceId?: true
    device?: true
    client?: true
    state?: true
    diagnostico?: true
    estado_dispositivo_al_ingresar?: true
    observaciones?: true
    repair?: true
    piezas?: true
    total?: true
    discount?: true
    date?: true
    dateOut?: true
    fecha_presupuesto?: true
    fecha_aprobacion?: true
    garantia_hasta?: true
    observaciones_garantia?: true
    payments?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    buyerId: string | null
    customerDeviceId: string | null
    device: JsonValue
    client: JsonValue
    state: string
    diagnostico: string | null
    estado_dispositivo_al_ingresar: $Enums.DeviceStatus | null
    observaciones: string | null
    repair: string
    piezas: JsonValue | null
    total: number
    discount: number | null
    date: Date
    dateOut: Date | null
    fecha_presupuesto: Date | null
    fecha_aprobacion: Date | null
    garantia_hasta: Date | null
    observaciones_garantia: string | null
    payments: JsonValue | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    customerDeviceId?: boolean
    device?: boolean
    client?: boolean
    state?: boolean
    diagnostico?: boolean
    estado_dispositivo_al_ingresar?: boolean
    observaciones?: boolean
    repair?: boolean
    piezas?: boolean
    total?: boolean
    discount?: boolean
    date?: boolean
    dateOut?: boolean
    fecha_presupuesto?: boolean
    fecha_aprobacion?: boolean
    garantia_hasta?: boolean
    observaciones_garantia?: boolean
    payments?: boolean
    buyer?: boolean | Service$buyerArgs<ExtArgs>
    customerDevice?: boolean | Service$customerDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    id?: boolean
    buyerId?: boolean
    customerDeviceId?: boolean
    device?: boolean
    client?: boolean
    state?: boolean
    diagnostico?: boolean
    estado_dispositivo_al_ingresar?: boolean
    observaciones?: boolean
    repair?: boolean
    piezas?: boolean
    total?: boolean
    discount?: boolean
    date?: boolean
    dateOut?: boolean
    fecha_presupuesto?: boolean
    fecha_aprobacion?: boolean
    garantia_hasta?: boolean
    observaciones_garantia?: boolean
    payments?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buyerId" | "customerDeviceId" | "device" | "client" | "state" | "diagnostico" | "estado_dispositivo_al_ingresar" | "observaciones" | "repair" | "piezas" | "total" | "discount" | "date" | "dateOut" | "fecha_presupuesto" | "fecha_aprobacion" | "garantia_hasta" | "observaciones_garantia" | "payments", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buyer?: boolean | Service$buyerArgs<ExtArgs>
    customerDevice?: boolean | Service$customerDeviceArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      buyer: Prisma.$BuyerPayload<ExtArgs> | null
      customerDevice: Prisma.$CustomerDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buyerId: string | null
      customerDeviceId: string | null
      device: Prisma.JsonValue
      client: Prisma.JsonValue
      state: string
      diagnostico: string | null
      estado_dispositivo_al_ingresar: $Enums.DeviceStatus | null
      observaciones: string | null
      repair: string
      piezas: Prisma.JsonValue | null
      total: number
      discount: number | null
      date: Date
      dateOut: Date | null
      fecha_presupuesto: Date | null
      fecha_aprobacion: Date | null
      garantia_hasta: Date | null
      observaciones_garantia: string | null
      payments: Prisma.JsonValue | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * @param {ServiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const service = await prisma.service.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Service.
     * @param {ServiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const service = await prisma.service.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buyer<T extends Service$buyerArgs<ExtArgs> = {}>(args?: Subset<T, Service$buyerArgs<ExtArgs>>): Prisma__BuyerClient<$Result.GetResult<Prisma.$BuyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customerDevice<T extends Service$customerDeviceArgs<ExtArgs> = {}>(args?: Subset<T, Service$customerDeviceArgs<ExtArgs>>): Prisma__CustomerDeviceClient<$Result.GetResult<Prisma.$CustomerDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly buyerId: FieldRef<"Service", 'String'>
    readonly customerDeviceId: FieldRef<"Service", 'String'>
    readonly device: FieldRef<"Service", 'Json'>
    readonly client: FieldRef<"Service", 'Json'>
    readonly state: FieldRef<"Service", 'String'>
    readonly diagnostico: FieldRef<"Service", 'String'>
    readonly estado_dispositivo_al_ingresar: FieldRef<"Service", 'DeviceStatus'>
    readonly observaciones: FieldRef<"Service", 'String'>
    readonly repair: FieldRef<"Service", 'String'>
    readonly piezas: FieldRef<"Service", 'Json'>
    readonly total: FieldRef<"Service", 'Float'>
    readonly discount: FieldRef<"Service", 'Float'>
    readonly date: FieldRef<"Service", 'DateTime'>
    readonly dateOut: FieldRef<"Service", 'DateTime'>
    readonly fecha_presupuesto: FieldRef<"Service", 'DateTime'>
    readonly fecha_aprobacion: FieldRef<"Service", 'DateTime'>
    readonly garantia_hasta: FieldRef<"Service", 'DateTime'>
    readonly observaciones_garantia: FieldRef<"Service", 'String'>
    readonly payments: FieldRef<"Service", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service findRaw
   */
  export type ServiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service aggregateRaw
   */
  export type ServiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service.buyer
   */
  export type Service$buyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Buyer
     */
    select?: BuyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Buyer
     */
    omit?: BuyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerInclude<ExtArgs> | null
    where?: BuyerWhereInput
  }

  /**
   * Service.customerDevice
   */
  export type Service$customerDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDevice
     */
    select?: CustomerDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerDevice
     */
    omit?: CustomerDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDeviceInclude<ExtArgs> | null
    where?: CustomerDeviceWhereInput
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Cashflow
   */

  export type AggregateCashflow = {
    _count: CashflowCountAggregateOutputType | null
    _avg: CashflowAvgAggregateOutputType | null
    _sum: CashflowSumAggregateOutputType | null
    _min: CashflowMinAggregateOutputType | null
    _max: CashflowMaxAggregateOutputType | null
  }

  export type CashflowAvgAggregateOutputType = {
    openingBalance: number | null
    total: number | null
    expenses: number | null
    cashSales: number | null
    cashServices: number | null
    digitalSales: number | null
    digitalServices: number | null
  }

  export type CashflowSumAggregateOutputType = {
    openingBalance: number | null
    total: number | null
    expenses: number | null
    cashSales: number | null
    cashServices: number | null
    digitalSales: number | null
    digitalServices: number | null
  }

  export type CashflowMinAggregateOutputType = {
    id: string | null
    active: boolean | null
    openDate: Date | null
    closeDate: Date | null
    openingBalance: number | null
    total: number | null
    expenses: number | null
    cashSales: number | null
    cashServices: number | null
    digitalSales: number | null
    digitalServices: number | null
    observations: string | null
  }

  export type CashflowMaxAggregateOutputType = {
    id: string | null
    active: boolean | null
    openDate: Date | null
    closeDate: Date | null
    openingBalance: number | null
    total: number | null
    expenses: number | null
    cashSales: number | null
    cashServices: number | null
    digitalSales: number | null
    digitalServices: number | null
    observations: string | null
  }

  export type CashflowCountAggregateOutputType = {
    id: number
    active: number
    openDate: number
    closeDate: number
    openingBalance: number
    total: number
    expenses: number
    cashSales: number
    cashServices: number
    digitalSales: number
    digitalServices: number
    observations: number
    _all: number
  }


  export type CashflowAvgAggregateInputType = {
    openingBalance?: true
    total?: true
    expenses?: true
    cashSales?: true
    cashServices?: true
    digitalSales?: true
    digitalServices?: true
  }

  export type CashflowSumAggregateInputType = {
    openingBalance?: true
    total?: true
    expenses?: true
    cashSales?: true
    cashServices?: true
    digitalSales?: true
    digitalServices?: true
  }

  export type CashflowMinAggregateInputType = {
    id?: true
    active?: true
    openDate?: true
    closeDate?: true
    openingBalance?: true
    total?: true
    expenses?: true
    cashSales?: true
    cashServices?: true
    digitalSales?: true
    digitalServices?: true
    observations?: true
  }

  export type CashflowMaxAggregateInputType = {
    id?: true
    active?: true
    openDate?: true
    closeDate?: true
    openingBalance?: true
    total?: true
    expenses?: true
    cashSales?: true
    cashServices?: true
    digitalSales?: true
    digitalServices?: true
    observations?: true
  }

  export type CashflowCountAggregateInputType = {
    id?: true
    active?: true
    openDate?: true
    closeDate?: true
    openingBalance?: true
    total?: true
    expenses?: true
    cashSales?: true
    cashServices?: true
    digitalSales?: true
    digitalServices?: true
    observations?: true
    _all?: true
  }

  export type CashflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cashflow to aggregate.
     */
    where?: CashflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cashflows to fetch.
     */
    orderBy?: CashflowOrderByWithRelationInput | CashflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cashflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cashflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cashflows
    **/
    _count?: true | CashflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashflowMaxAggregateInputType
  }

  export type GetCashflowAggregateType<T extends CashflowAggregateArgs> = {
        [P in keyof T & keyof AggregateCashflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashflow[P]>
      : GetScalarType<T[P], AggregateCashflow[P]>
  }




  export type CashflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashflowWhereInput
    orderBy?: CashflowOrderByWithAggregationInput | CashflowOrderByWithAggregationInput[]
    by: CashflowScalarFieldEnum[] | CashflowScalarFieldEnum
    having?: CashflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashflowCountAggregateInputType | true
    _avg?: CashflowAvgAggregateInputType
    _sum?: CashflowSumAggregateInputType
    _min?: CashflowMinAggregateInputType
    _max?: CashflowMaxAggregateInputType
  }

  export type CashflowGroupByOutputType = {
    id: string
    active: boolean
    openDate: Date
    closeDate: Date | null
    openingBalance: number
    total: number
    expenses: number
    cashSales: number
    cashServices: number
    digitalSales: number
    digitalServices: number
    observations: string
    _count: CashflowCountAggregateOutputType | null
    _avg: CashflowAvgAggregateOutputType | null
    _sum: CashflowSumAggregateOutputType | null
    _min: CashflowMinAggregateOutputType | null
    _max: CashflowMaxAggregateOutputType | null
  }

  type GetCashflowGroupByPayload<T extends CashflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashflowGroupByOutputType[P]>
            : GetScalarType<T[P], CashflowGroupByOutputType[P]>
        }
      >
    >


  export type CashflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    active?: boolean
    openDate?: boolean
    closeDate?: boolean
    openingBalance?: boolean
    total?: boolean
    expenses?: boolean
    cashSales?: boolean
    cashServices?: boolean
    digitalSales?: boolean
    digitalServices?: boolean
    observations?: boolean
  }, ExtArgs["result"]["cashflow"]>



  export type CashflowSelectScalar = {
    id?: boolean
    active?: boolean
    openDate?: boolean
    closeDate?: boolean
    openingBalance?: boolean
    total?: boolean
    expenses?: boolean
    cashSales?: boolean
    cashServices?: boolean
    digitalSales?: boolean
    digitalServices?: boolean
    observations?: boolean
  }

  export type CashflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "active" | "openDate" | "closeDate" | "openingBalance" | "total" | "expenses" | "cashSales" | "cashServices" | "digitalSales" | "digitalServices" | "observations", ExtArgs["result"]["cashflow"]>

  export type $CashflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cashflow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      active: boolean
      openDate: Date
      closeDate: Date | null
      openingBalance: number
      total: number
      expenses: number
      cashSales: number
      cashServices: number
      digitalSales: number
      digitalServices: number
      observations: string
    }, ExtArgs["result"]["cashflow"]>
    composites: {}
  }

  type CashflowGetPayload<S extends boolean | null | undefined | CashflowDefaultArgs> = $Result.GetResult<Prisma.$CashflowPayload, S>

  type CashflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashflowCountAggregateInputType | true
    }

  export interface CashflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cashflow'], meta: { name: 'Cashflow' } }
    /**
     * Find zero or one Cashflow that matches the filter.
     * @param {CashflowFindUniqueArgs} args - Arguments to find a Cashflow
     * @example
     * // Get one Cashflow
     * const cashflow = await prisma.cashflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashflowFindUniqueArgs>(args: SelectSubset<T, CashflowFindUniqueArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cashflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashflowFindUniqueOrThrowArgs} args - Arguments to find a Cashflow
     * @example
     * // Get one Cashflow
     * const cashflow = await prisma.cashflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashflowFindUniqueOrThrowArgs>(args: SelectSubset<T, CashflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cashflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowFindFirstArgs} args - Arguments to find a Cashflow
     * @example
     * // Get one Cashflow
     * const cashflow = await prisma.cashflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashflowFindFirstArgs>(args?: SelectSubset<T, CashflowFindFirstArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cashflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowFindFirstOrThrowArgs} args - Arguments to find a Cashflow
     * @example
     * // Get one Cashflow
     * const cashflow = await prisma.cashflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashflowFindFirstOrThrowArgs>(args?: SelectSubset<T, CashflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cashflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cashflows
     * const cashflows = await prisma.cashflow.findMany()
     * 
     * // Get first 10 Cashflows
     * const cashflows = await prisma.cashflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashflowWithIdOnly = await prisma.cashflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashflowFindManyArgs>(args?: SelectSubset<T, CashflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cashflow.
     * @param {CashflowCreateArgs} args - Arguments to create a Cashflow.
     * @example
     * // Create one Cashflow
     * const Cashflow = await prisma.cashflow.create({
     *   data: {
     *     // ... data to create a Cashflow
     *   }
     * })
     * 
     */
    create<T extends CashflowCreateArgs>(args: SelectSubset<T, CashflowCreateArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cashflows.
     * @param {CashflowCreateManyArgs} args - Arguments to create many Cashflows.
     * @example
     * // Create many Cashflows
     * const cashflow = await prisma.cashflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashflowCreateManyArgs>(args?: SelectSubset<T, CashflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cashflow.
     * @param {CashflowDeleteArgs} args - Arguments to delete one Cashflow.
     * @example
     * // Delete one Cashflow
     * const Cashflow = await prisma.cashflow.delete({
     *   where: {
     *     // ... filter to delete one Cashflow
     *   }
     * })
     * 
     */
    delete<T extends CashflowDeleteArgs>(args: SelectSubset<T, CashflowDeleteArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cashflow.
     * @param {CashflowUpdateArgs} args - Arguments to update one Cashflow.
     * @example
     * // Update one Cashflow
     * const cashflow = await prisma.cashflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashflowUpdateArgs>(args: SelectSubset<T, CashflowUpdateArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cashflows.
     * @param {CashflowDeleteManyArgs} args - Arguments to filter Cashflows to delete.
     * @example
     * // Delete a few Cashflows
     * const { count } = await prisma.cashflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashflowDeleteManyArgs>(args?: SelectSubset<T, CashflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cashflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cashflows
     * const cashflow = await prisma.cashflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashflowUpdateManyArgs>(args: SelectSubset<T, CashflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cashflow.
     * @param {CashflowUpsertArgs} args - Arguments to update or create a Cashflow.
     * @example
     * // Update or create a Cashflow
     * const cashflow = await prisma.cashflow.upsert({
     *   create: {
     *     // ... data to create a Cashflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cashflow we want to update
     *   }
     * })
     */
    upsert<T extends CashflowUpsertArgs>(args: SelectSubset<T, CashflowUpsertArgs<ExtArgs>>): Prisma__CashflowClient<$Result.GetResult<Prisma.$CashflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cashflows that matches the filter.
     * @param {CashflowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cashflow = await prisma.cashflow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CashflowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Cashflow.
     * @param {CashflowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cashflow = await prisma.cashflow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CashflowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cashflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowCountArgs} args - Arguments to filter Cashflows to count.
     * @example
     * // Count the number of Cashflows
     * const count = await prisma.cashflow.count({
     *   where: {
     *     // ... the filter for the Cashflows we want to count
     *   }
     * })
    **/
    count<T extends CashflowCountArgs>(
      args?: Subset<T, CashflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cashflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashflowAggregateArgs>(args: Subset<T, CashflowAggregateArgs>): Prisma.PrismaPromise<GetCashflowAggregateType<T>>

    /**
     * Group by Cashflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashflowGroupByArgs['orderBy'] }
        : { orderBy?: CashflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cashflow model
   */
  readonly fields: CashflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cashflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cashflow model
   */
  interface CashflowFieldRefs {
    readonly id: FieldRef<"Cashflow", 'String'>
    readonly active: FieldRef<"Cashflow", 'Boolean'>
    readonly openDate: FieldRef<"Cashflow", 'DateTime'>
    readonly closeDate: FieldRef<"Cashflow", 'DateTime'>
    readonly openingBalance: FieldRef<"Cashflow", 'Float'>
    readonly total: FieldRef<"Cashflow", 'Float'>
    readonly expenses: FieldRef<"Cashflow", 'Float'>
    readonly cashSales: FieldRef<"Cashflow", 'Float'>
    readonly cashServices: FieldRef<"Cashflow", 'Float'>
    readonly digitalSales: FieldRef<"Cashflow", 'Float'>
    readonly digitalServices: FieldRef<"Cashflow", 'Float'>
    readonly observations: FieldRef<"Cashflow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cashflow findUnique
   */
  export type CashflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter, which Cashflow to fetch.
     */
    where: CashflowWhereUniqueInput
  }

  /**
   * Cashflow findUniqueOrThrow
   */
  export type CashflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter, which Cashflow to fetch.
     */
    where: CashflowWhereUniqueInput
  }

  /**
   * Cashflow findFirst
   */
  export type CashflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter, which Cashflow to fetch.
     */
    where?: CashflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cashflows to fetch.
     */
    orderBy?: CashflowOrderByWithRelationInput | CashflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cashflows.
     */
    cursor?: CashflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cashflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cashflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cashflows.
     */
    distinct?: CashflowScalarFieldEnum | CashflowScalarFieldEnum[]
  }

  /**
   * Cashflow findFirstOrThrow
   */
  export type CashflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter, which Cashflow to fetch.
     */
    where?: CashflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cashflows to fetch.
     */
    orderBy?: CashflowOrderByWithRelationInput | CashflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cashflows.
     */
    cursor?: CashflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cashflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cashflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cashflows.
     */
    distinct?: CashflowScalarFieldEnum | CashflowScalarFieldEnum[]
  }

  /**
   * Cashflow findMany
   */
  export type CashflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter, which Cashflows to fetch.
     */
    where?: CashflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cashflows to fetch.
     */
    orderBy?: CashflowOrderByWithRelationInput | CashflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cashflows.
     */
    cursor?: CashflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cashflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cashflows.
     */
    skip?: number
    distinct?: CashflowScalarFieldEnum | CashflowScalarFieldEnum[]
  }

  /**
   * Cashflow create
   */
  export type CashflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * The data needed to create a Cashflow.
     */
    data: XOR<CashflowCreateInput, CashflowUncheckedCreateInput>
  }

  /**
   * Cashflow createMany
   */
  export type CashflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cashflows.
     */
    data: CashflowCreateManyInput | CashflowCreateManyInput[]
  }

  /**
   * Cashflow update
   */
  export type CashflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * The data needed to update a Cashflow.
     */
    data: XOR<CashflowUpdateInput, CashflowUncheckedUpdateInput>
    /**
     * Choose, which Cashflow to update.
     */
    where: CashflowWhereUniqueInput
  }

  /**
   * Cashflow updateMany
   */
  export type CashflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cashflows.
     */
    data: XOR<CashflowUpdateManyMutationInput, CashflowUncheckedUpdateManyInput>
    /**
     * Filter which Cashflows to update
     */
    where?: CashflowWhereInput
    /**
     * Limit how many Cashflows to update.
     */
    limit?: number
  }

  /**
   * Cashflow upsert
   */
  export type CashflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * The filter to search for the Cashflow to update in case it exists.
     */
    where: CashflowWhereUniqueInput
    /**
     * In case the Cashflow found by the `where` argument doesn't exist, create a new Cashflow with this data.
     */
    create: XOR<CashflowCreateInput, CashflowUncheckedCreateInput>
    /**
     * In case the Cashflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashflowUpdateInput, CashflowUncheckedUpdateInput>
  }

  /**
   * Cashflow delete
   */
  export type CashflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
    /**
     * Filter which Cashflow to delete.
     */
    where: CashflowWhereUniqueInput
  }

  /**
   * Cashflow deleteMany
   */
  export type CashflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cashflows to delete
     */
    where?: CashflowWhereInput
    /**
     * Limit how many Cashflows to delete.
     */
    limit?: number
  }

  /**
   * Cashflow findRaw
   */
  export type CashflowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Cashflow aggregateRaw
   */
  export type CashflowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Cashflow without action
   */
  export type CashflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cashflow
     */
    select?: CashflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cashflow
     */
    omit?: CashflowOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    avatar: string | null
    sucursal: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    avatar: string | null
    sucursal: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    avatar: number
    sucursal: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    sucursal?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    sucursal?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    sucursal?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string | null
    email: string
    password: string
    avatar: string | null
    sucursal: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    sucursal?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "avatar" | "sucursal", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string | null
      email: string
      password: string
      avatar: string | null
      sucursal: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly sucursal: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const ProductScalarFieldEnum: {
    id: 'id',
    barcode: 'barcode',
    sku: 'sku',
    name: 'name',
    description: 'description',
    category: 'category',
    brand: 'brand',
    provider: 'provider',
    costPrice: 'costPrice',
    salePrice: 'salePrice',
    promoPrice: 'promoPrice',
    percentPrice: 'percentPrice',
    stock: 'stock',
    minStock: 'minStock',
    images: 'images',
    specifications: 'specifications',
    hasVariants: 'hasVariants',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    barcode: 'barcode',
    sku: 'sku',
    name: 'name',
    description: 'description',
    color: 'color',
    design: 'design',
    size: 'size',
    material: 'material',
    costPrice: 'costPrice',
    salePrice: 'salePrice',
    promoPrice: 'promoPrice',
    percentPrice: 'percentPrice',
    stock: 'stock',
    minStock: 'minStock',
    images: 'images',
    specifications: 'specifications',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    address: 'address',
    phone: 'phone',
    purchaseHistory: 'purchaseHistory',
    serviceHistory: 'serviceHistory'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    details: 'details',
    date: 'date',
    products: 'products',
    total: 'total',
    discount: 'discount',
    payments: 'payments'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    product: 'product',
    details: 'details',
    amount: 'amount',
    method: 'method',
    date: 'date',
    category: 'category',
    categoryId: 'categoryId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const BuyerScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    dni: 'dni',
    cuit: 'cuit',
    telefono: 'telefono',
    whatsapp: 'whatsapp',
    fecha_nacimiento: 'fecha_nacimiento',
    direccion: 'direccion',
    acquisition_channel: 'acquisition_channel',
    utm_source: 'utm_source',
    utm_medium: 'utm_medium',
    utm_campaign: 'utm_campaign',
    utm_content: 'utm_content',
    utm_term: 'utm_term',
    segment: 'segment',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    last_interaction: 'last_interaction'
  };

  export type BuyerScalarFieldEnum = (typeof BuyerScalarFieldEnum)[keyof typeof BuyerScalarFieldEnum]


  export const CommunicationPreferencesScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    email_marketing: 'email_marketing',
    email_transaccional: 'email_transaccional',
    sms_marketing: 'sms_marketing',
    sms_transaccional: 'sms_transaccional',
    whatsapp_marketing: 'whatsapp_marketing',
    whatsapp_transaccional: 'whatsapp_transaccional',
    llamadas_comerciales: 'llamadas_comerciales',
    preferred_channel: 'preferred_channel',
    best_contact_time: 'best_contact_time',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunicationPreferencesScalarFieldEnum = (typeof CommunicationPreferencesScalarFieldEnum)[keyof typeof CommunicationPreferencesScalarFieldEnum]


  export const CustomerDeviceScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    marca: 'marca',
    modelo: 'modelo',
    numero_serie: 'numero_serie',
    imei: 'imei',
    color: 'color',
    capacidad: 'capacidad',
    fecha_compra: 'fecha_compra',
    lugar_compra: 'lugar_compra',
    precio_compra: 'precio_compra',
    tiene_garantia: 'tiene_garantia',
    garantia_hasta: 'garantia_hasta',
    is_active: 'is_active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerDeviceScalarFieldEnum = (typeof CustomerDeviceScalarFieldEnum)[keyof typeof CustomerDeviceScalarFieldEnum]


  export const ProductInteractionScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    productoId: 'productoId',
    productoName: 'productoName',
    tipo: 'tipo',
    session_id: 'session_id',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    referrer: 'referrer',
    quantity: 'quantity',
    price_at_interaction: 'price_at_interaction',
    createdAt: 'createdAt'
  };

  export type ProductInteractionScalarFieldEnum = (typeof ProductInteractionScalarFieldEnum)[keyof typeof ProductInteractionScalarFieldEnum]


  export const BrowsingEventScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    session_id: 'session_id',
    page_url: 'page_url',
    page_title: 'page_title',
    time_spent: 'time_spent',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    referrer: 'referrer',
    device_type: 'device_type',
    createdAt: 'createdAt'
  };

  export type BrowsingEventScalarFieldEnum = (typeof BrowsingEventScalarFieldEnum)[keyof typeof BrowsingEventScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    tipo: 'tipo',
    rating: 'rating',
    comentario: 'comentario',
    related_order_id: 'related_order_id',
    related_service_id: 'related_service_id',
    related_product_id: 'related_product_id',
    respuesta: 'respuesta',
    respondido_por: 'respondido_por',
    fecha_respuesta: 'fecha_respuesta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    fecha_creacion: 'fecha_creacion',
    monto_total: 'monto_total',
    estado: 'estado',
    metodo_pago: 'metodo_pago',
    info_envio: 'info_envio',
    id_transaccion_pasarela: 'id_transaccion_pasarela'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderDetailScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productoId: 'productoId',
    productoName: 'productoName',
    cantidad: 'cantidad',
    precio_unitario_al_momento_de_compra: 'precio_unitario_al_momento_de_compra'
  };

  export type OrderDetailScalarFieldEnum = (typeof OrderDetailScalarFieldEnum)[keyof typeof OrderDetailScalarFieldEnum]


  export const POSSaleScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    fecha_creacion: 'fecha_creacion',
    monto_total: 'monto_total',
    estado: 'estado',
    metodo_pago: 'metodo_pago'
  };

  export type POSSaleScalarFieldEnum = (typeof POSSaleScalarFieldEnum)[keyof typeof POSSaleScalarFieldEnum]


  export const POSSaleDetailScalarFieldEnum: {
    id: 'id',
    posSaleId: 'posSaleId',
    productoId: 'productoId',
    productoName: 'productoName',
    cantidad: 'cantidad',
    precio_unitario_al_momento_de_compra: 'precio_unitario_al_momento_de_compra'
  };

  export type POSSaleDetailScalarFieldEnum = (typeof POSSaleDetailScalarFieldEnum)[keyof typeof POSSaleDetailScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    customerDeviceId: 'customerDeviceId',
    device: 'device',
    client: 'client',
    state: 'state',
    diagnostico: 'diagnostico',
    estado_dispositivo_al_ingresar: 'estado_dispositivo_al_ingresar',
    observaciones: 'observaciones',
    repair: 'repair',
    piezas: 'piezas',
    total: 'total',
    discount: 'discount',
    date: 'date',
    dateOut: 'dateOut',
    fecha_presupuesto: 'fecha_presupuesto',
    fecha_aprobacion: 'fecha_aprobacion',
    garantia_hasta: 'garantia_hasta',
    observaciones_garantia: 'observaciones_garantia',
    payments: 'payments'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const CashflowScalarFieldEnum: {
    id: 'id',
    active: 'active',
    openDate: 'openDate',
    closeDate: 'closeDate',
    openingBalance: 'openingBalance',
    total: 'total',
    expenses: 'expenses',
    cashSales: 'cashSales',
    cashServices: 'cashServices',
    digitalSales: 'digitalSales',
    digitalServices: 'digitalServices',
    observations: 'observations'
  };

  export type CashflowScalarFieldEnum = (typeof CashflowScalarFieldEnum)[keyof typeof CashflowScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    avatar: 'avatar',
    sucursal: 'sucursal'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CustomerSegment'
   */
  export type EnumCustomerSegmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerSegment'>
    


  /**
   * Reference to a field of type 'CustomerSegment[]'
   */
  export type ListEnumCustomerSegmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerSegment[]'>
    


  /**
   * Reference to a field of type 'CommunicationChannel'
   */
  export type EnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel'>
    


  /**
   * Reference to a field of type 'CommunicationChannel[]'
   */
  export type ListEnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel[]'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'InteractionType[]'
   */
  export type ListEnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'DeviceStatus'
   */
  export type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>
    


  /**
   * Reference to a field of type 'DeviceStatus[]'
   */
  export type ListEnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    brand?: StringFilter<"Product"> | string
    provider?: StringFilter<"Product"> | string
    costPrice?: FloatFilter<"Product"> | number
    salePrice?: FloatFilter<"Product"> | number
    promoPrice?: FloatFilter<"Product"> | number
    percentPrice?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    specifications?: JsonNullableFilter<"Product">
    hasVariants?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    variants?: ProductVariantListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    provider?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    hasVariants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variants?: ProductVariantOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    barcode?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    brand?: StringFilter<"Product"> | string
    provider?: StringFilter<"Product"> | string
    costPrice?: FloatFilter<"Product"> | number
    salePrice?: FloatFilter<"Product"> | number
    promoPrice?: FloatFilter<"Product"> | number
    percentPrice?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    specifications?: JsonNullableFilter<"Product">
    hasVariants?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    variants?: ProductVariantListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    provider?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    hasVariants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    category?: StringWithAggregatesFilter<"Product"> | string
    brand?: StringWithAggregatesFilter<"Product"> | string
    provider?: StringWithAggregatesFilter<"Product"> | string
    costPrice?: FloatWithAggregatesFilter<"Product"> | number
    salePrice?: FloatWithAggregatesFilter<"Product"> | number
    promoPrice?: FloatWithAggregatesFilter<"Product"> | number
    percentPrice?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    minStock?: IntWithAggregatesFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    specifications?: JsonNullableWithAggregatesFilter<"Product">
    hasVariants?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    sku?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    description?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    design?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: FloatFilter<"ProductVariant"> | number
    salePrice?: FloatFilter<"ProductVariant"> | number
    promoPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    percentPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntFilter<"ProductVariant"> | number
    minStock?: IntFilter<"ProductVariant"> | number
    images?: StringNullableListFilter<"ProductVariant">
    specifications?: JsonNullableFilter<"ProductVariant">
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    design?: SortOrder
    size?: SortOrder
    material?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    productId?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    sku?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    description?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    design?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: FloatFilter<"ProductVariant"> | number
    salePrice?: FloatFilter<"ProductVariant"> | number
    promoPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    percentPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntFilter<"ProductVariant"> | number
    minStock?: IntFilter<"ProductVariant"> | number
    images?: StringNullableListFilter<"ProductVariant">
    specifications?: JsonNullableFilter<"ProductVariant">
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    design?: SortOrder
    size?: SortOrder
    material?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    productId?: StringWithAggregatesFilter<"ProductVariant"> | string
    barcode?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    sku?: StringWithAggregatesFilter<"ProductVariant"> | string
    name?: StringWithAggregatesFilter<"ProductVariant"> | string
    description?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    design?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    size?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    material?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    costPrice?: FloatWithAggregatesFilter<"ProductVariant"> | number
    salePrice?: FloatWithAggregatesFilter<"ProductVariant"> | number
    promoPrice?: FloatNullableWithAggregatesFilter<"ProductVariant"> | number | null
    percentPrice?: FloatNullableWithAggregatesFilter<"ProductVariant"> | number | null
    stock?: IntWithAggregatesFilter<"ProductVariant"> | number
    minStock?: IntWithAggregatesFilter<"ProductVariant"> | number
    images?: StringNullableListFilter<"ProductVariant">
    specifications?: JsonNullableWithAggregatesFilter<"ProductVariant">
    isActive?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    address?: JsonFilter<"Customer">
    phone?: StringFilter<"Customer"> | string
    purchaseHistory?: StringNullableListFilter<"Customer">
    serviceHistory?: StringNullableListFilter<"Customer">
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    purchaseHistory?: SortOrder
    serviceHistory?: SortOrder
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    address?: JsonFilter<"Customer">
    phone?: StringFilter<"Customer"> | string
    purchaseHistory?: StringNullableListFilter<"Customer">
    serviceHistory?: StringNullableListFilter<"Customer">
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    purchaseHistory?: SortOrder
    serviceHistory?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    address?: JsonWithAggregatesFilter<"Customer">
    phone?: StringWithAggregatesFilter<"Customer"> | string
    purchaseHistory?: StringNullableListFilter<"Customer">
    serviceHistory?: StringNullableListFilter<"Customer">
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    customerId?: StringFilter<"Sale"> | string
    details?: StringFilter<"Sale"> | string
    date?: DateTimeFilter<"Sale"> | Date | string
    products?: JsonFilter<"Sale">
    total?: FloatFilter<"Sale"> | number
    discount?: FloatFilter<"Sale"> | number
    payments?: JsonNullableFilter<"Sale">
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    details?: SortOrder
    date?: SortOrder
    products?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    payments?: SortOrder
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    customerId?: StringFilter<"Sale"> | string
    details?: StringFilter<"Sale"> | string
    date?: DateTimeFilter<"Sale"> | Date | string
    products?: JsonFilter<"Sale">
    total?: FloatFilter<"Sale"> | number
    discount?: FloatFilter<"Sale"> | number
    payments?: JsonNullableFilter<"Sale">
  }, "id">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    details?: SortOrder
    date?: SortOrder
    products?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    payments?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringWithAggregatesFilter<"Sale"> | string
    details?: StringWithAggregatesFilter<"Sale"> | string
    date?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    products?: JsonWithAggregatesFilter<"Sale">
    total?: FloatWithAggregatesFilter<"Sale"> | number
    discount?: FloatWithAggregatesFilter<"Sale"> | number
    payments?: JsonNullableWithAggregatesFilter<"Sale">
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    product?: StringFilter<"Expense"> | string
    details?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    method?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    category?: StringNullableFilter<"Expense"> | string | null
    categoryId?: IntNullableFilter<"Expense"> | number | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    product?: SortOrder
    details?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    category?: SortOrder
    categoryId?: SortOrder
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    product?: StringFilter<"Expense"> | string
    details?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    method?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    category?: StringNullableFilter<"Expense"> | string | null
    categoryId?: IntNullableFilter<"Expense"> | number | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    product?: SortOrder
    details?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    category?: SortOrder
    categoryId?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    product?: StringWithAggregatesFilter<"Expense"> | string
    details?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    method?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    category?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    categoryId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
  }

  export type BuyerWhereInput = {
    AND?: BuyerWhereInput | BuyerWhereInput[]
    OR?: BuyerWhereInput[]
    NOT?: BuyerWhereInput | BuyerWhereInput[]
    id?: StringFilter<"Buyer"> | string
    nombre?: StringFilter<"Buyer"> | string
    apellido?: StringNullableFilter<"Buyer"> | string | null
    email?: StringFilter<"Buyer"> | string
    dni?: StringNullableFilter<"Buyer"> | string | null
    cuit?: StringNullableFilter<"Buyer"> | string | null
    telefono?: StringNullableFilter<"Buyer"> | string | null
    whatsapp?: StringNullableFilter<"Buyer"> | string | null
    fecha_nacimiento?: DateTimeNullableFilter<"Buyer"> | Date | string | null
    direccion?: StringFilter<"Buyer"> | string
    acquisition_channel?: StringNullableFilter<"Buyer"> | string | null
    utm_source?: StringNullableFilter<"Buyer"> | string | null
    utm_medium?: StringNullableFilter<"Buyer"> | string | null
    utm_campaign?: StringNullableFilter<"Buyer"> | string | null
    utm_content?: StringNullableFilter<"Buyer"> | string | null
    utm_term?: StringNullableFilter<"Buyer"> | string | null
    segment?: EnumCustomerSegmentFilter<"Buyer"> | $Enums.CustomerSegment
    tags?: StringNullableListFilter<"Buyer">
    createdAt?: DateTimeFilter<"Buyer"> | Date | string
    updatedAt?: DateTimeFilter<"Buyer"> | Date | string
    last_interaction?: DateTimeNullableFilter<"Buyer"> | Date | string | null
    communication_preferences?: XOR<CommunicationPreferencesNullableScalarRelationFilter, CommunicationPreferencesWhereInput> | null
    orders?: OrderListRelationFilter
    posSales?: POSSaleListRelationFilter
    devices?: CustomerDeviceListRelationFilter
    interactions?: ProductInteractionListRelationFilter
    browsingEvents?: BrowsingEventListRelationFilter
    feedback?: FeedbackListRelationFilter
    services?: ServiceListRelationFilter
  }

  export type BuyerOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    dni?: SortOrder
    cuit?: SortOrder
    telefono?: SortOrder
    whatsapp?: SortOrder
    fecha_nacimiento?: SortOrder
    direccion?: SortOrder
    acquisition_channel?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_content?: SortOrder
    utm_term?: SortOrder
    segment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    last_interaction?: SortOrder
    communication_preferences?: CommunicationPreferencesOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    posSales?: POSSaleOrderByRelationAggregateInput
    devices?: CustomerDeviceOrderByRelationAggregateInput
    interactions?: ProductInteractionOrderByRelationAggregateInput
    browsingEvents?: BrowsingEventOrderByRelationAggregateInput
    feedback?: FeedbackOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type BuyerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: BuyerWhereInput | BuyerWhereInput[]
    OR?: BuyerWhereInput[]
    NOT?: BuyerWhereInput | BuyerWhereInput[]
    nombre?: StringFilter<"Buyer"> | string
    apellido?: StringNullableFilter<"Buyer"> | string | null
    dni?: StringNullableFilter<"Buyer"> | string | null
    cuit?: StringNullableFilter<"Buyer"> | string | null
    telefono?: StringNullableFilter<"Buyer"> | string | null
    whatsapp?: StringNullableFilter<"Buyer"> | string | null
    fecha_nacimiento?: DateTimeNullableFilter<"Buyer"> | Date | string | null
    direccion?: StringFilter<"Buyer"> | string
    acquisition_channel?: StringNullableFilter<"Buyer"> | string | null
    utm_source?: StringNullableFilter<"Buyer"> | string | null
    utm_medium?: StringNullableFilter<"Buyer"> | string | null
    utm_campaign?: StringNullableFilter<"Buyer"> | string | null
    utm_content?: StringNullableFilter<"Buyer"> | string | null
    utm_term?: StringNullableFilter<"Buyer"> | string | null
    segment?: EnumCustomerSegmentFilter<"Buyer"> | $Enums.CustomerSegment
    tags?: StringNullableListFilter<"Buyer">
    createdAt?: DateTimeFilter<"Buyer"> | Date | string
    updatedAt?: DateTimeFilter<"Buyer"> | Date | string
    last_interaction?: DateTimeNullableFilter<"Buyer"> | Date | string | null
    communication_preferences?: XOR<CommunicationPreferencesNullableScalarRelationFilter, CommunicationPreferencesWhereInput> | null
    orders?: OrderListRelationFilter
    posSales?: POSSaleListRelationFilter
    devices?: CustomerDeviceListRelationFilter
    interactions?: ProductInteractionListRelationFilter
    browsingEvents?: BrowsingEventListRelationFilter
    feedback?: FeedbackListRelationFilter
    services?: ServiceListRelationFilter
  }, "id" | "email">

  export type BuyerOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    dni?: SortOrder
    cuit?: SortOrder
    telefono?: SortOrder
    whatsapp?: SortOrder
    fecha_nacimiento?: SortOrder
    direccion?: SortOrder
    acquisition_channel?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_content?: SortOrder
    utm_term?: SortOrder
    segment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    last_interaction?: SortOrder
    _count?: BuyerCountOrderByAggregateInput
    _max?: BuyerMaxOrderByAggregateInput
    _min?: BuyerMinOrderByAggregateInput
  }

  export type BuyerScalarWhereWithAggregatesInput = {
    AND?: BuyerScalarWhereWithAggregatesInput | BuyerScalarWhereWithAggregatesInput[]
    OR?: BuyerScalarWhereWithAggregatesInput[]
    NOT?: BuyerScalarWhereWithAggregatesInput | BuyerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Buyer"> | string
    nombre?: StringWithAggregatesFilter<"Buyer"> | string
    apellido?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    email?: StringWithAggregatesFilter<"Buyer"> | string
    dni?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    cuit?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"Buyer"> | Date | string | null
    direccion?: StringWithAggregatesFilter<"Buyer"> | string
    acquisition_channel?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    utm_source?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    utm_medium?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    utm_campaign?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    utm_content?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    utm_term?: StringNullableWithAggregatesFilter<"Buyer"> | string | null
    segment?: EnumCustomerSegmentWithAggregatesFilter<"Buyer"> | $Enums.CustomerSegment
    tags?: StringNullableListFilter<"Buyer">
    createdAt?: DateTimeWithAggregatesFilter<"Buyer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Buyer"> | Date | string
    last_interaction?: DateTimeNullableWithAggregatesFilter<"Buyer"> | Date | string | null
  }

  export type CommunicationPreferencesWhereInput = {
    AND?: CommunicationPreferencesWhereInput | CommunicationPreferencesWhereInput[]
    OR?: CommunicationPreferencesWhereInput[]
    NOT?: CommunicationPreferencesWhereInput | CommunicationPreferencesWhereInput[]
    id?: StringFilter<"CommunicationPreferences"> | string
    buyerId?: StringFilter<"CommunicationPreferences"> | string
    email_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    email_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    sms_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    sms_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    whatsapp_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    whatsapp_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    llamadas_comerciales?: BoolFilter<"CommunicationPreferences"> | boolean
    preferred_channel?: EnumCommunicationChannelFilter<"CommunicationPreferences"> | $Enums.CommunicationChannel
    best_contact_time?: StringNullableFilter<"CommunicationPreferences"> | string | null
    createdAt?: DateTimeFilter<"CommunicationPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"CommunicationPreferences"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }

  export type CommunicationPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    email_marketing?: SortOrder
    email_transaccional?: SortOrder
    sms_marketing?: SortOrder
    sms_transaccional?: SortOrder
    whatsapp_marketing?: SortOrder
    whatsapp_transaccional?: SortOrder
    llamadas_comerciales?: SortOrder
    preferred_channel?: SortOrder
    best_contact_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
  }

  export type CommunicationPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    buyerId?: string
    AND?: CommunicationPreferencesWhereInput | CommunicationPreferencesWhereInput[]
    OR?: CommunicationPreferencesWhereInput[]
    NOT?: CommunicationPreferencesWhereInput | CommunicationPreferencesWhereInput[]
    email_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    email_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    sms_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    sms_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    whatsapp_marketing?: BoolFilter<"CommunicationPreferences"> | boolean
    whatsapp_transaccional?: BoolFilter<"CommunicationPreferences"> | boolean
    llamadas_comerciales?: BoolFilter<"CommunicationPreferences"> | boolean
    preferred_channel?: EnumCommunicationChannelFilter<"CommunicationPreferences"> | $Enums.CommunicationChannel
    best_contact_time?: StringNullableFilter<"CommunicationPreferences"> | string | null
    createdAt?: DateTimeFilter<"CommunicationPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"CommunicationPreferences"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }, "id" | "buyerId">

  export type CommunicationPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    email_marketing?: SortOrder
    email_transaccional?: SortOrder
    sms_marketing?: SortOrder
    sms_transaccional?: SortOrder
    whatsapp_marketing?: SortOrder
    whatsapp_transaccional?: SortOrder
    llamadas_comerciales?: SortOrder
    preferred_channel?: SortOrder
    best_contact_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunicationPreferencesCountOrderByAggregateInput
    _max?: CommunicationPreferencesMaxOrderByAggregateInput
    _min?: CommunicationPreferencesMinOrderByAggregateInput
  }

  export type CommunicationPreferencesScalarWhereWithAggregatesInput = {
    AND?: CommunicationPreferencesScalarWhereWithAggregatesInput | CommunicationPreferencesScalarWhereWithAggregatesInput[]
    OR?: CommunicationPreferencesScalarWhereWithAggregatesInput[]
    NOT?: CommunicationPreferencesScalarWhereWithAggregatesInput | CommunicationPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunicationPreferences"> | string
    buyerId?: StringWithAggregatesFilter<"CommunicationPreferences"> | string
    email_marketing?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    email_transaccional?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    sms_marketing?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    sms_transaccional?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    whatsapp_marketing?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    whatsapp_transaccional?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    llamadas_comerciales?: BoolWithAggregatesFilter<"CommunicationPreferences"> | boolean
    preferred_channel?: EnumCommunicationChannelWithAggregatesFilter<"CommunicationPreferences"> | $Enums.CommunicationChannel
    best_contact_time?: StringNullableWithAggregatesFilter<"CommunicationPreferences"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CommunicationPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunicationPreferences"> | Date | string
  }

  export type CustomerDeviceWhereInput = {
    AND?: CustomerDeviceWhereInput | CustomerDeviceWhereInput[]
    OR?: CustomerDeviceWhereInput[]
    NOT?: CustomerDeviceWhereInput | CustomerDeviceWhereInput[]
    id?: StringFilter<"CustomerDevice"> | string
    buyerId?: StringFilter<"CustomerDevice"> | string
    marca?: StringFilter<"CustomerDevice"> | string
    modelo?: StringFilter<"CustomerDevice"> | string
    numero_serie?: StringNullableFilter<"CustomerDevice"> | string | null
    imei?: StringNullableFilter<"CustomerDevice"> | string | null
    color?: StringNullableFilter<"CustomerDevice"> | string | null
    capacidad?: StringNullableFilter<"CustomerDevice"> | string | null
    fecha_compra?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    lugar_compra?: StringNullableFilter<"CustomerDevice"> | string | null
    precio_compra?: FloatNullableFilter<"CustomerDevice"> | number | null
    tiene_garantia?: BoolFilter<"CustomerDevice"> | boolean
    garantia_hasta?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    is_active?: BoolFilter<"CustomerDevice"> | boolean
    createdAt?: DateTimeFilter<"CustomerDevice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerDevice"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    services?: ServiceListRelationFilter
  }

  export type CustomerDeviceOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    numero_serie?: SortOrder
    imei?: SortOrder
    color?: SortOrder
    capacidad?: SortOrder
    fecha_compra?: SortOrder
    lugar_compra?: SortOrder
    precio_compra?: SortOrder
    tiene_garantia?: SortOrder
    garantia_hasta?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type CustomerDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerDeviceWhereInput | CustomerDeviceWhereInput[]
    OR?: CustomerDeviceWhereInput[]
    NOT?: CustomerDeviceWhereInput | CustomerDeviceWhereInput[]
    buyerId?: StringFilter<"CustomerDevice"> | string
    marca?: StringFilter<"CustomerDevice"> | string
    modelo?: StringFilter<"CustomerDevice"> | string
    numero_serie?: StringNullableFilter<"CustomerDevice"> | string | null
    imei?: StringNullableFilter<"CustomerDevice"> | string | null
    color?: StringNullableFilter<"CustomerDevice"> | string | null
    capacidad?: StringNullableFilter<"CustomerDevice"> | string | null
    fecha_compra?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    lugar_compra?: StringNullableFilter<"CustomerDevice"> | string | null
    precio_compra?: FloatNullableFilter<"CustomerDevice"> | number | null
    tiene_garantia?: BoolFilter<"CustomerDevice"> | boolean
    garantia_hasta?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    is_active?: BoolFilter<"CustomerDevice"> | boolean
    createdAt?: DateTimeFilter<"CustomerDevice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerDevice"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    services?: ServiceListRelationFilter
  }, "id">

  export type CustomerDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    numero_serie?: SortOrder
    imei?: SortOrder
    color?: SortOrder
    capacidad?: SortOrder
    fecha_compra?: SortOrder
    lugar_compra?: SortOrder
    precio_compra?: SortOrder
    tiene_garantia?: SortOrder
    garantia_hasta?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerDeviceCountOrderByAggregateInput
    _avg?: CustomerDeviceAvgOrderByAggregateInput
    _max?: CustomerDeviceMaxOrderByAggregateInput
    _min?: CustomerDeviceMinOrderByAggregateInput
    _sum?: CustomerDeviceSumOrderByAggregateInput
  }

  export type CustomerDeviceScalarWhereWithAggregatesInput = {
    AND?: CustomerDeviceScalarWhereWithAggregatesInput | CustomerDeviceScalarWhereWithAggregatesInput[]
    OR?: CustomerDeviceScalarWhereWithAggregatesInput[]
    NOT?: CustomerDeviceScalarWhereWithAggregatesInput | CustomerDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerDevice"> | string
    buyerId?: StringWithAggregatesFilter<"CustomerDevice"> | string
    marca?: StringWithAggregatesFilter<"CustomerDevice"> | string
    modelo?: StringWithAggregatesFilter<"CustomerDevice"> | string
    numero_serie?: StringNullableWithAggregatesFilter<"CustomerDevice"> | string | null
    imei?: StringNullableWithAggregatesFilter<"CustomerDevice"> | string | null
    color?: StringNullableWithAggregatesFilter<"CustomerDevice"> | string | null
    capacidad?: StringNullableWithAggregatesFilter<"CustomerDevice"> | string | null
    fecha_compra?: DateTimeNullableWithAggregatesFilter<"CustomerDevice"> | Date | string | null
    lugar_compra?: StringNullableWithAggregatesFilter<"CustomerDevice"> | string | null
    precio_compra?: FloatNullableWithAggregatesFilter<"CustomerDevice"> | number | null
    tiene_garantia?: BoolWithAggregatesFilter<"CustomerDevice"> | boolean
    garantia_hasta?: DateTimeNullableWithAggregatesFilter<"CustomerDevice"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"CustomerDevice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerDevice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerDevice"> | Date | string
  }

  export type ProductInteractionWhereInput = {
    AND?: ProductInteractionWhereInput | ProductInteractionWhereInput[]
    OR?: ProductInteractionWhereInput[]
    NOT?: ProductInteractionWhereInput | ProductInteractionWhereInput[]
    id?: StringFilter<"ProductInteraction"> | string
    buyerId?: StringFilter<"ProductInteraction"> | string
    productoId?: StringFilter<"ProductInteraction"> | string
    productoName?: StringFilter<"ProductInteraction"> | string
    tipo?: EnumInteractionTypeFilter<"ProductInteraction"> | $Enums.InteractionType
    session_id?: StringNullableFilter<"ProductInteraction"> | string | null
    user_agent?: StringNullableFilter<"ProductInteraction"> | string | null
    ip_address?: StringNullableFilter<"ProductInteraction"> | string | null
    referrer?: StringNullableFilter<"ProductInteraction"> | string | null
    quantity?: IntNullableFilter<"ProductInteraction"> | number | null
    price_at_interaction?: FloatNullableFilter<"ProductInteraction"> | number | null
    createdAt?: DateTimeFilter<"ProductInteraction"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }

  export type ProductInteractionOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    tipo?: SortOrder
    session_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    quantity?: SortOrder
    price_at_interaction?: SortOrder
    createdAt?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
  }

  export type ProductInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductInteractionWhereInput | ProductInteractionWhereInput[]
    OR?: ProductInteractionWhereInput[]
    NOT?: ProductInteractionWhereInput | ProductInteractionWhereInput[]
    buyerId?: StringFilter<"ProductInteraction"> | string
    productoId?: StringFilter<"ProductInteraction"> | string
    productoName?: StringFilter<"ProductInteraction"> | string
    tipo?: EnumInteractionTypeFilter<"ProductInteraction"> | $Enums.InteractionType
    session_id?: StringNullableFilter<"ProductInteraction"> | string | null
    user_agent?: StringNullableFilter<"ProductInteraction"> | string | null
    ip_address?: StringNullableFilter<"ProductInteraction"> | string | null
    referrer?: StringNullableFilter<"ProductInteraction"> | string | null
    quantity?: IntNullableFilter<"ProductInteraction"> | number | null
    price_at_interaction?: FloatNullableFilter<"ProductInteraction"> | number | null
    createdAt?: DateTimeFilter<"ProductInteraction"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }, "id">

  export type ProductInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    tipo?: SortOrder
    session_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    quantity?: SortOrder
    price_at_interaction?: SortOrder
    createdAt?: SortOrder
    _count?: ProductInteractionCountOrderByAggregateInput
    _avg?: ProductInteractionAvgOrderByAggregateInput
    _max?: ProductInteractionMaxOrderByAggregateInput
    _min?: ProductInteractionMinOrderByAggregateInput
    _sum?: ProductInteractionSumOrderByAggregateInput
  }

  export type ProductInteractionScalarWhereWithAggregatesInput = {
    AND?: ProductInteractionScalarWhereWithAggregatesInput | ProductInteractionScalarWhereWithAggregatesInput[]
    OR?: ProductInteractionScalarWhereWithAggregatesInput[]
    NOT?: ProductInteractionScalarWhereWithAggregatesInput | ProductInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductInteraction"> | string
    buyerId?: StringWithAggregatesFilter<"ProductInteraction"> | string
    productoId?: StringWithAggregatesFilter<"ProductInteraction"> | string
    productoName?: StringWithAggregatesFilter<"ProductInteraction"> | string
    tipo?: EnumInteractionTypeWithAggregatesFilter<"ProductInteraction"> | $Enums.InteractionType
    session_id?: StringNullableWithAggregatesFilter<"ProductInteraction"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"ProductInteraction"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"ProductInteraction"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"ProductInteraction"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"ProductInteraction"> | number | null
    price_at_interaction?: FloatNullableWithAggregatesFilter<"ProductInteraction"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductInteraction"> | Date | string
  }

  export type BrowsingEventWhereInput = {
    AND?: BrowsingEventWhereInput | BrowsingEventWhereInput[]
    OR?: BrowsingEventWhereInput[]
    NOT?: BrowsingEventWhereInput | BrowsingEventWhereInput[]
    id?: StringFilter<"BrowsingEvent"> | string
    buyerId?: StringNullableFilter<"BrowsingEvent"> | string | null
    session_id?: StringFilter<"BrowsingEvent"> | string
    page_url?: StringFilter<"BrowsingEvent"> | string
    page_title?: StringNullableFilter<"BrowsingEvent"> | string | null
    time_spent?: IntNullableFilter<"BrowsingEvent"> | number | null
    user_agent?: StringNullableFilter<"BrowsingEvent"> | string | null
    ip_address?: StringNullableFilter<"BrowsingEvent"> | string | null
    referrer?: StringNullableFilter<"BrowsingEvent"> | string | null
    device_type?: StringNullableFilter<"BrowsingEvent"> | string | null
    createdAt?: DateTimeFilter<"BrowsingEvent"> | Date | string
    buyer?: XOR<BuyerNullableScalarRelationFilter, BuyerWhereInput> | null
  }

  export type BrowsingEventOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    session_id?: SortOrder
    page_url?: SortOrder
    page_title?: SortOrder
    time_spent?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    device_type?: SortOrder
    createdAt?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
  }

  export type BrowsingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BrowsingEventWhereInput | BrowsingEventWhereInput[]
    OR?: BrowsingEventWhereInput[]
    NOT?: BrowsingEventWhereInput | BrowsingEventWhereInput[]
    buyerId?: StringNullableFilter<"BrowsingEvent"> | string | null
    session_id?: StringFilter<"BrowsingEvent"> | string
    page_url?: StringFilter<"BrowsingEvent"> | string
    page_title?: StringNullableFilter<"BrowsingEvent"> | string | null
    time_spent?: IntNullableFilter<"BrowsingEvent"> | number | null
    user_agent?: StringNullableFilter<"BrowsingEvent"> | string | null
    ip_address?: StringNullableFilter<"BrowsingEvent"> | string | null
    referrer?: StringNullableFilter<"BrowsingEvent"> | string | null
    device_type?: StringNullableFilter<"BrowsingEvent"> | string | null
    createdAt?: DateTimeFilter<"BrowsingEvent"> | Date | string
    buyer?: XOR<BuyerNullableScalarRelationFilter, BuyerWhereInput> | null
  }, "id">

  export type BrowsingEventOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    session_id?: SortOrder
    page_url?: SortOrder
    page_title?: SortOrder
    time_spent?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    device_type?: SortOrder
    createdAt?: SortOrder
    _count?: BrowsingEventCountOrderByAggregateInput
    _avg?: BrowsingEventAvgOrderByAggregateInput
    _max?: BrowsingEventMaxOrderByAggregateInput
    _min?: BrowsingEventMinOrderByAggregateInput
    _sum?: BrowsingEventSumOrderByAggregateInput
  }

  export type BrowsingEventScalarWhereWithAggregatesInput = {
    AND?: BrowsingEventScalarWhereWithAggregatesInput | BrowsingEventScalarWhereWithAggregatesInput[]
    OR?: BrowsingEventScalarWhereWithAggregatesInput[]
    NOT?: BrowsingEventScalarWhereWithAggregatesInput | BrowsingEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BrowsingEvent"> | string
    buyerId?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    session_id?: StringWithAggregatesFilter<"BrowsingEvent"> | string
    page_url?: StringWithAggregatesFilter<"BrowsingEvent"> | string
    page_title?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    time_spent?: IntNullableWithAggregatesFilter<"BrowsingEvent"> | number | null
    user_agent?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    device_type?: StringNullableWithAggregatesFilter<"BrowsingEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BrowsingEvent"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    buyerId?: StringFilter<"Feedback"> | string
    tipo?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    rating?: IntNullableFilter<"Feedback"> | number | null
    comentario?: StringNullableFilter<"Feedback"> | string | null
    related_order_id?: StringNullableFilter<"Feedback"> | string | null
    related_service_id?: StringNullableFilter<"Feedback"> | string | null
    related_product_id?: StringNullableFilter<"Feedback"> | string | null
    respuesta?: StringNullableFilter<"Feedback"> | string | null
    respondido_por?: StringNullableFilter<"Feedback"> | string | null
    fecha_respuesta?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    tipo?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    related_order_id?: SortOrder
    related_service_id?: SortOrder
    related_product_id?: SortOrder
    respuesta?: SortOrder
    respondido_por?: SortOrder
    fecha_respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    buyerId?: StringFilter<"Feedback"> | string
    tipo?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    rating?: IntNullableFilter<"Feedback"> | number | null
    comentario?: StringNullableFilter<"Feedback"> | string | null
    related_order_id?: StringNullableFilter<"Feedback"> | string | null
    related_service_id?: StringNullableFilter<"Feedback"> | string | null
    related_product_id?: StringNullableFilter<"Feedback"> | string | null
    respuesta?: StringNullableFilter<"Feedback"> | string | null
    respondido_por?: StringNullableFilter<"Feedback"> | string | null
    fecha_respuesta?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    tipo?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    related_order_id?: SortOrder
    related_service_id?: SortOrder
    related_product_id?: SortOrder
    respuesta?: SortOrder
    respondido_por?: SortOrder
    fecha_respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    buyerId?: StringWithAggregatesFilter<"Feedback"> | string
    tipo?: EnumFeedbackTypeWithAggregatesFilter<"Feedback"> | $Enums.FeedbackType
    rating?: IntNullableWithAggregatesFilter<"Feedback"> | number | null
    comentario?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    related_order_id?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    related_service_id?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    related_product_id?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    respuesta?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    respondido_por?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    fecha_respuesta?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    buyerId?: StringFilter<"Order"> | string
    fecha_creacion?: DateTimeFilter<"Order"> | Date | string
    monto_total?: IntFilter<"Order"> | number
    estado?: StringFilter<"Order"> | string
    metodo_pago?: StringFilter<"Order"> | string
    info_envio?: JsonNullableFilter<"Order">
    id_transaccion_pasarela?: StringNullableFilter<"Order"> | string | null
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    detalles?: OrderDetailListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    info_envio?: SortOrder
    id_transaccion_pasarela?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
    detalles?: OrderDetailOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    buyerId?: StringFilter<"Order"> | string
    fecha_creacion?: DateTimeFilter<"Order"> | Date | string
    monto_total?: IntFilter<"Order"> | number
    estado?: StringFilter<"Order"> | string
    metodo_pago?: StringFilter<"Order"> | string
    info_envio?: JsonNullableFilter<"Order">
    id_transaccion_pasarela?: StringNullableFilter<"Order"> | string | null
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    detalles?: OrderDetailListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    info_envio?: SortOrder
    id_transaccion_pasarela?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    buyerId?: StringWithAggregatesFilter<"Order"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    monto_total?: IntWithAggregatesFilter<"Order"> | number
    estado?: StringWithAggregatesFilter<"Order"> | string
    metodo_pago?: StringWithAggregatesFilter<"Order"> | string
    info_envio?: JsonNullableWithAggregatesFilter<"Order">
    id_transaccion_pasarela?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderDetailWhereInput = {
    AND?: OrderDetailWhereInput | OrderDetailWhereInput[]
    OR?: OrderDetailWhereInput[]
    NOT?: OrderDetailWhereInput | OrderDetailWhereInput[]
    id?: StringFilter<"OrderDetail"> | string
    orderId?: StringFilter<"OrderDetail"> | string
    productoId?: StringFilter<"OrderDetail"> | string
    productoName?: StringFilter<"OrderDetail"> | string
    cantidad?: IntFilter<"OrderDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"OrderDetail"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderDetailOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderDetailWhereInput | OrderDetailWhereInput[]
    OR?: OrderDetailWhereInput[]
    NOT?: OrderDetailWhereInput | OrderDetailWhereInput[]
    orderId?: StringFilter<"OrderDetail"> | string
    productoId?: StringFilter<"OrderDetail"> | string
    productoName?: StringFilter<"OrderDetail"> | string
    cantidad?: IntFilter<"OrderDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"OrderDetail"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderDetailOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
    _count?: OrderDetailCountOrderByAggregateInput
    _avg?: OrderDetailAvgOrderByAggregateInput
    _max?: OrderDetailMaxOrderByAggregateInput
    _min?: OrderDetailMinOrderByAggregateInput
    _sum?: OrderDetailSumOrderByAggregateInput
  }

  export type OrderDetailScalarWhereWithAggregatesInput = {
    AND?: OrderDetailScalarWhereWithAggregatesInput | OrderDetailScalarWhereWithAggregatesInput[]
    OR?: OrderDetailScalarWhereWithAggregatesInput[]
    NOT?: OrderDetailScalarWhereWithAggregatesInput | OrderDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderDetail"> | string
    orderId?: StringWithAggregatesFilter<"OrderDetail"> | string
    productoId?: StringWithAggregatesFilter<"OrderDetail"> | string
    productoName?: StringWithAggregatesFilter<"OrderDetail"> | string
    cantidad?: IntWithAggregatesFilter<"OrderDetail"> | number
    precio_unitario_al_momento_de_compra?: IntWithAggregatesFilter<"OrderDetail"> | number
  }

  export type POSSaleWhereInput = {
    AND?: POSSaleWhereInput | POSSaleWhereInput[]
    OR?: POSSaleWhereInput[]
    NOT?: POSSaleWhereInput | POSSaleWhereInput[]
    id?: StringFilter<"POSSale"> | string
    buyerId?: StringFilter<"POSSale"> | string
    fecha_creacion?: DateTimeFilter<"POSSale"> | Date | string
    monto_total?: IntFilter<"POSSale"> | number
    estado?: StringFilter<"POSSale"> | string
    metodo_pago?: JsonNullableFilter<"POSSale">
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    detalles?: POSSaleDetailListRelationFilter
  }

  export type POSSaleOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
    detalles?: POSSaleDetailOrderByRelationAggregateInput
  }

  export type POSSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POSSaleWhereInput | POSSaleWhereInput[]
    OR?: POSSaleWhereInput[]
    NOT?: POSSaleWhereInput | POSSaleWhereInput[]
    buyerId?: StringFilter<"POSSale"> | string
    fecha_creacion?: DateTimeFilter<"POSSale"> | Date | string
    monto_total?: IntFilter<"POSSale"> | number
    estado?: StringFilter<"POSSale"> | string
    metodo_pago?: JsonNullableFilter<"POSSale">
    buyer?: XOR<BuyerScalarRelationFilter, BuyerWhereInput>
    detalles?: POSSaleDetailListRelationFilter
  }, "id">

  export type POSSaleOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    _count?: POSSaleCountOrderByAggregateInput
    _avg?: POSSaleAvgOrderByAggregateInput
    _max?: POSSaleMaxOrderByAggregateInput
    _min?: POSSaleMinOrderByAggregateInput
    _sum?: POSSaleSumOrderByAggregateInput
  }

  export type POSSaleScalarWhereWithAggregatesInput = {
    AND?: POSSaleScalarWhereWithAggregatesInput | POSSaleScalarWhereWithAggregatesInput[]
    OR?: POSSaleScalarWhereWithAggregatesInput[]
    NOT?: POSSaleScalarWhereWithAggregatesInput | POSSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POSSale"> | string
    buyerId?: StringWithAggregatesFilter<"POSSale"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"POSSale"> | Date | string
    monto_total?: IntWithAggregatesFilter<"POSSale"> | number
    estado?: StringWithAggregatesFilter<"POSSale"> | string
    metodo_pago?: JsonNullableWithAggregatesFilter<"POSSale">
  }

  export type POSSaleDetailWhereInput = {
    AND?: POSSaleDetailWhereInput | POSSaleDetailWhereInput[]
    OR?: POSSaleDetailWhereInput[]
    NOT?: POSSaleDetailWhereInput | POSSaleDetailWhereInput[]
    id?: StringFilter<"POSSaleDetail"> | string
    posSaleId?: StringFilter<"POSSaleDetail"> | string
    productoId?: StringFilter<"POSSaleDetail"> | string
    productoName?: StringFilter<"POSSaleDetail"> | string
    cantidad?: IntFilter<"POSSaleDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"POSSaleDetail"> | number
    posSale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }

  export type POSSaleDetailOrderByWithRelationInput = {
    id?: SortOrder
    posSaleId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
    posSale?: POSSaleOrderByWithRelationInput
  }

  export type POSSaleDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POSSaleDetailWhereInput | POSSaleDetailWhereInput[]
    OR?: POSSaleDetailWhereInput[]
    NOT?: POSSaleDetailWhereInput | POSSaleDetailWhereInput[]
    posSaleId?: StringFilter<"POSSaleDetail"> | string
    productoId?: StringFilter<"POSSaleDetail"> | string
    productoName?: StringFilter<"POSSaleDetail"> | string
    cantidad?: IntFilter<"POSSaleDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"POSSaleDetail"> | number
    posSale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }, "id">

  export type POSSaleDetailOrderByWithAggregationInput = {
    id?: SortOrder
    posSaleId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
    _count?: POSSaleDetailCountOrderByAggregateInput
    _avg?: POSSaleDetailAvgOrderByAggregateInput
    _max?: POSSaleDetailMaxOrderByAggregateInput
    _min?: POSSaleDetailMinOrderByAggregateInput
    _sum?: POSSaleDetailSumOrderByAggregateInput
  }

  export type POSSaleDetailScalarWhereWithAggregatesInput = {
    AND?: POSSaleDetailScalarWhereWithAggregatesInput | POSSaleDetailScalarWhereWithAggregatesInput[]
    OR?: POSSaleDetailScalarWhereWithAggregatesInput[]
    NOT?: POSSaleDetailScalarWhereWithAggregatesInput | POSSaleDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"POSSaleDetail"> | string
    posSaleId?: StringWithAggregatesFilter<"POSSaleDetail"> | string
    productoId?: StringWithAggregatesFilter<"POSSaleDetail"> | string
    productoName?: StringWithAggregatesFilter<"POSSaleDetail"> | string
    cantidad?: IntWithAggregatesFilter<"POSSaleDetail"> | number
    precio_unitario_al_momento_de_compra?: IntWithAggregatesFilter<"POSSaleDetail"> | number
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    buyerId?: StringNullableFilter<"Service"> | string | null
    customerDeviceId?: StringNullableFilter<"Service"> | string | null
    device?: JsonFilter<"Service">
    client?: JsonFilter<"Service">
    state?: StringFilter<"Service"> | string
    diagnostico?: StringNullableFilter<"Service"> | string | null
    estado_dispositivo_al_ingresar?: EnumDeviceStatusNullableFilter<"Service"> | $Enums.DeviceStatus | null
    observaciones?: StringNullableFilter<"Service"> | string | null
    repair?: StringFilter<"Service"> | string
    piezas?: JsonNullableFilter<"Service">
    total?: FloatFilter<"Service"> | number
    discount?: FloatNullableFilter<"Service"> | number | null
    date?: DateTimeFilter<"Service"> | Date | string
    dateOut?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_presupuesto?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_aprobacion?: DateTimeNullableFilter<"Service"> | Date | string | null
    garantia_hasta?: DateTimeNullableFilter<"Service"> | Date | string | null
    observaciones_garantia?: StringNullableFilter<"Service"> | string | null
    payments?: JsonNullableFilter<"Service">
    buyer?: XOR<BuyerNullableScalarRelationFilter, BuyerWhereInput> | null
    customerDevice?: XOR<CustomerDeviceNullableScalarRelationFilter, CustomerDeviceWhereInput> | null
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    customerDeviceId?: SortOrder
    device?: SortOrder
    client?: SortOrder
    state?: SortOrder
    diagnostico?: SortOrder
    estado_dispositivo_al_ingresar?: SortOrder
    observaciones?: SortOrder
    repair?: SortOrder
    piezas?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    date?: SortOrder
    dateOut?: SortOrder
    fecha_presupuesto?: SortOrder
    fecha_aprobacion?: SortOrder
    garantia_hasta?: SortOrder
    observaciones_garantia?: SortOrder
    payments?: SortOrder
    buyer?: BuyerOrderByWithRelationInput
    customerDevice?: CustomerDeviceOrderByWithRelationInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    buyerId?: StringNullableFilter<"Service"> | string | null
    customerDeviceId?: StringNullableFilter<"Service"> | string | null
    device?: JsonFilter<"Service">
    client?: JsonFilter<"Service">
    state?: StringFilter<"Service"> | string
    diagnostico?: StringNullableFilter<"Service"> | string | null
    estado_dispositivo_al_ingresar?: EnumDeviceStatusNullableFilter<"Service"> | $Enums.DeviceStatus | null
    observaciones?: StringNullableFilter<"Service"> | string | null
    repair?: StringFilter<"Service"> | string
    piezas?: JsonNullableFilter<"Service">
    total?: FloatFilter<"Service"> | number
    discount?: FloatNullableFilter<"Service"> | number | null
    date?: DateTimeFilter<"Service"> | Date | string
    dateOut?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_presupuesto?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_aprobacion?: DateTimeNullableFilter<"Service"> | Date | string | null
    garantia_hasta?: DateTimeNullableFilter<"Service"> | Date | string | null
    observaciones_garantia?: StringNullableFilter<"Service"> | string | null
    payments?: JsonNullableFilter<"Service">
    buyer?: XOR<BuyerNullableScalarRelationFilter, BuyerWhereInput> | null
    customerDevice?: XOR<CustomerDeviceNullableScalarRelationFilter, CustomerDeviceWhereInput> | null
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    customerDeviceId?: SortOrder
    device?: SortOrder
    client?: SortOrder
    state?: SortOrder
    diagnostico?: SortOrder
    estado_dispositivo_al_ingresar?: SortOrder
    observaciones?: SortOrder
    repair?: SortOrder
    piezas?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    date?: SortOrder
    dateOut?: SortOrder
    fecha_presupuesto?: SortOrder
    fecha_aprobacion?: SortOrder
    garantia_hasta?: SortOrder
    observaciones_garantia?: SortOrder
    payments?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    buyerId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    customerDeviceId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    device?: JsonWithAggregatesFilter<"Service">
    client?: JsonWithAggregatesFilter<"Service">
    state?: StringWithAggregatesFilter<"Service"> | string
    diagnostico?: StringNullableWithAggregatesFilter<"Service"> | string | null
    estado_dispositivo_al_ingresar?: EnumDeviceStatusNullableWithAggregatesFilter<"Service"> | $Enums.DeviceStatus | null
    observaciones?: StringNullableWithAggregatesFilter<"Service"> | string | null
    repair?: StringWithAggregatesFilter<"Service"> | string
    piezas?: JsonNullableWithAggregatesFilter<"Service">
    total?: FloatWithAggregatesFilter<"Service"> | number
    discount?: FloatNullableWithAggregatesFilter<"Service"> | number | null
    date?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    dateOut?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    fecha_presupuesto?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    fecha_aprobacion?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    garantia_hasta?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    observaciones_garantia?: StringNullableWithAggregatesFilter<"Service"> | string | null
    payments?: JsonNullableWithAggregatesFilter<"Service">
  }

  export type CashflowWhereInput = {
    AND?: CashflowWhereInput | CashflowWhereInput[]
    OR?: CashflowWhereInput[]
    NOT?: CashflowWhereInput | CashflowWhereInput[]
    id?: StringFilter<"Cashflow"> | string
    active?: BoolFilter<"Cashflow"> | boolean
    openDate?: DateTimeFilter<"Cashflow"> | Date | string
    closeDate?: DateTimeNullableFilter<"Cashflow"> | Date | string | null
    openingBalance?: FloatFilter<"Cashflow"> | number
    total?: FloatFilter<"Cashflow"> | number
    expenses?: FloatFilter<"Cashflow"> | number
    cashSales?: FloatFilter<"Cashflow"> | number
    cashServices?: FloatFilter<"Cashflow"> | number
    digitalSales?: FloatFilter<"Cashflow"> | number
    digitalServices?: FloatFilter<"Cashflow"> | number
    observations?: StringFilter<"Cashflow"> | string
  }

  export type CashflowOrderByWithRelationInput = {
    id?: SortOrder
    active?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
    observations?: SortOrder
  }

  export type CashflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashflowWhereInput | CashflowWhereInput[]
    OR?: CashflowWhereInput[]
    NOT?: CashflowWhereInput | CashflowWhereInput[]
    active?: BoolFilter<"Cashflow"> | boolean
    openDate?: DateTimeFilter<"Cashflow"> | Date | string
    closeDate?: DateTimeNullableFilter<"Cashflow"> | Date | string | null
    openingBalance?: FloatFilter<"Cashflow"> | number
    total?: FloatFilter<"Cashflow"> | number
    expenses?: FloatFilter<"Cashflow"> | number
    cashSales?: FloatFilter<"Cashflow"> | number
    cashServices?: FloatFilter<"Cashflow"> | number
    digitalSales?: FloatFilter<"Cashflow"> | number
    digitalServices?: FloatFilter<"Cashflow"> | number
    observations?: StringFilter<"Cashflow"> | string
  }, "id">

  export type CashflowOrderByWithAggregationInput = {
    id?: SortOrder
    active?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
    observations?: SortOrder
    _count?: CashflowCountOrderByAggregateInput
    _avg?: CashflowAvgOrderByAggregateInput
    _max?: CashflowMaxOrderByAggregateInput
    _min?: CashflowMinOrderByAggregateInput
    _sum?: CashflowSumOrderByAggregateInput
  }

  export type CashflowScalarWhereWithAggregatesInput = {
    AND?: CashflowScalarWhereWithAggregatesInput | CashflowScalarWhereWithAggregatesInput[]
    OR?: CashflowScalarWhereWithAggregatesInput[]
    NOT?: CashflowScalarWhereWithAggregatesInput | CashflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cashflow"> | string
    active?: BoolWithAggregatesFilter<"Cashflow"> | boolean
    openDate?: DateTimeWithAggregatesFilter<"Cashflow"> | Date | string
    closeDate?: DateTimeNullableWithAggregatesFilter<"Cashflow"> | Date | string | null
    openingBalance?: FloatWithAggregatesFilter<"Cashflow"> | number
    total?: FloatWithAggregatesFilter<"Cashflow"> | number
    expenses?: FloatWithAggregatesFilter<"Cashflow"> | number
    cashSales?: FloatWithAggregatesFilter<"Cashflow"> | number
    cashServices?: FloatWithAggregatesFilter<"Cashflow"> | number
    digitalSales?: FloatWithAggregatesFilter<"Cashflow"> | number
    digitalServices?: FloatWithAggregatesFilter<"Cashflow"> | number
    observations?: StringWithAggregatesFilter<"Cashflow"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    sucursal?: StringNullableFilter<"User"> | string | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    sucursal?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    sucursal?: StringNullableFilter<"User"> | string | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    sucursal?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    sucursal?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProductCreateInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock?: number
    images?: ProductCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    hasVariants?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock?: number
    images?: ProductCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    hasVariants?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock?: number
    images?: ProductCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    hasVariants?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id?: string
    productId: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyInput = {
    id?: string
    productId: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    address: InputJsonValue
    phone: string
    purchaseHistory?: CustomerCreatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerCreateserviceHistoryInput | string[]
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    address: InputJsonValue
    phone: string
    purchaseHistory?: CustomerCreatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerCreateserviceHistoryInput | string[]
  }

  export type CustomerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue
    phone?: StringFieldUpdateOperationsInput | string
    purchaseHistory?: CustomerUpdatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerUpdateserviceHistoryInput | string[]
  }

  export type CustomerUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue
    phone?: StringFieldUpdateOperationsInput | string
    purchaseHistory?: CustomerUpdatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerUpdateserviceHistoryInput | string[]
  }

  export type CustomerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    password: string
    address: InputJsonValue
    phone: string
    purchaseHistory?: CustomerCreatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerCreateserviceHistoryInput | string[]
  }

  export type CustomerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue
    phone?: StringFieldUpdateOperationsInput | string
    purchaseHistory?: CustomerUpdatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerUpdateserviceHistoryInput | string[]
  }

  export type CustomerUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue
    phone?: StringFieldUpdateOperationsInput | string
    purchaseHistory?: CustomerUpdatepurchaseHistoryInput | string[]
    serviceHistory?: CustomerUpdateserviceHistoryInput | string[]
  }

  export type SaleCreateInput = {
    id?: string
    customerId: string
    details: string
    date: Date | string
    products: InputJsonValue
    total: number
    discount: number
    payments?: InputJsonValue | null
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    customerId: string
    details: string
    date: Date | string
    products: InputJsonValue
    total: number
    discount: number
    payments?: InputJsonValue | null
  }

  export type SaleUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: InputJsonValue | InputJsonValue
    total?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type SaleUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: InputJsonValue | InputJsonValue
    total?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type SaleCreateManyInput = {
    id?: string
    customerId: string
    details: string
    date: Date | string
    products: InputJsonValue
    total: number
    discount: number
    payments?: InputJsonValue | null
  }

  export type SaleUpdateManyMutationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: InputJsonValue | InputJsonValue
    total?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type SaleUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: InputJsonValue | InputJsonValue
    total?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ExpenseCreateInput = {
    id?: string
    product: string
    details?: string | null
    amount: number
    method?: string | null
    date: Date | string
    category?: string | null
    categoryId?: number | null
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    product: string
    details?: string | null
    amount: number
    method?: string | null
    date: Date | string
    category?: string | null
    categoryId?: number | null
  }

  export type ExpenseUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUncheckedUpdateInput = {
    product?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseCreateManyInput = {
    id?: string
    product: string
    details?: string | null
    amount: number
    method?: string | null
    date: Date | string
    category?: string | null
    categoryId?: number | null
  }

  export type ExpenseUpdateManyMutationInput = {
    product?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    product?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    method?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuyerCreateInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerCreateManyInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
  }

  export type BuyerUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BuyerUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunicationPreferencesCreateInput = {
    id?: string
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: $Enums.CommunicationChannel
    best_contact_time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: BuyerCreateNestedOneWithoutCommunication_preferencesInput
  }

  export type CommunicationPreferencesUncheckedCreateInput = {
    id?: string
    buyerId: string
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: $Enums.CommunicationChannel
    best_contact_time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationPreferencesUpdateInput = {
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneRequiredWithoutCommunication_preferencesNestedInput
  }

  export type CommunicationPreferencesUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationPreferencesCreateManyInput = {
    id?: string
    buyerId: string
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: $Enums.CommunicationChannel
    best_contact_time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationPreferencesUpdateManyMutationInput = {
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationPreferencesUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeviceCreateInput = {
    id?: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: BuyerCreateNestedOneWithoutDevicesInput
    services?: ServiceCreateNestedManyWithoutCustomerDeviceInput
  }

  export type CustomerDeviceUncheckedCreateInput = {
    id?: string
    buyerId: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCustomerDeviceInput
  }

  export type CustomerDeviceUpdateInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneRequiredWithoutDevicesNestedInput
    services?: ServiceUpdateManyWithoutCustomerDeviceNestedInput
  }

  export type CustomerDeviceUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCustomerDeviceNestedInput
  }

  export type CustomerDeviceCreateManyInput = {
    id?: string
    buyerId: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerDeviceUpdateManyMutationInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerDeviceUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionCreateInput = {
    id?: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
    buyer: BuyerCreateNestedOneWithoutInteractionsInput
  }

  export type ProductInteractionUncheckedCreateInput = {
    id?: string
    buyerId: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
  }

  export type ProductInteractionUpdateInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type ProductInteractionUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionCreateManyInput = {
    id?: string
    buyerId: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
  }

  export type ProductInteractionUpdateManyMutationInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventCreateInput = {
    id?: string
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
    buyer?: BuyerCreateNestedOneWithoutBrowsingEventsInput
  }

  export type BrowsingEventUncheckedCreateInput = {
    id?: string
    buyerId?: string | null
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
  }

  export type BrowsingEventUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneWithoutBrowsingEventsNestedInput
  }

  export type BrowsingEventUncheckedUpdateInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventCreateManyInput = {
    id?: string
    buyerId?: string | null
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
  }

  export type BrowsingEventUpdateManyMutationInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventUncheckedUpdateManyInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: BuyerCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    buyerId: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    buyerId: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
    buyer: BuyerCreateNestedOneWithoutOrdersInput
    detalles?: OrderDetailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
    detalles?: OrderDetailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
    buyer?: BuyerUpdateOneRequiredWithoutOrdersNestedInput
    detalles?: OrderDetailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: OrderDetailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderDetailCreateInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    order: OrderCreateNestedOneWithoutDetallesInput
  }

  export type OrderDetailUncheckedCreateInput = {
    id?: string
    orderId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type OrderDetailUpdateInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type OrderDetailUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type OrderDetailCreateManyInput = {
    id?: string
    orderId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type OrderDetailUpdateManyMutationInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type OrderDetailUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleCreateInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
    buyer: BuyerCreateNestedOneWithoutPosSalesInput
    detalles?: POSSaleDetailCreateNestedManyWithoutPosSaleInput
  }

  export type POSSaleUncheckedCreateInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
    detalles?: POSSaleDetailUncheckedCreateNestedManyWithoutPosSaleInput
  }

  export type POSSaleUpdateInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
    buyer?: BuyerUpdateOneRequiredWithoutPosSalesNestedInput
    detalles?: POSSaleDetailUpdateManyWithoutPosSaleNestedInput
  }

  export type POSSaleUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
    detalles?: POSSaleDetailUncheckedUpdateManyWithoutPosSaleNestedInput
  }

  export type POSSaleCreateManyInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
  }

  export type POSSaleUpdateManyMutationInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
  }

  export type POSSaleUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
  }

  export type POSSaleDetailCreateInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
    posSale: POSSaleCreateNestedOneWithoutDetallesInput
  }

  export type POSSaleDetailUncheckedCreateInput = {
    id?: string
    posSaleId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type POSSaleDetailUpdateInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
    posSale?: POSSaleUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type POSSaleDetailUncheckedUpdateInput = {
    posSaleId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleDetailCreateManyInput = {
    id?: string
    posSaleId: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type POSSaleDetailUpdateManyMutationInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleDetailUncheckedUpdateManyInput = {
    posSaleId?: StringFieldUpdateOperationsInput | string
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceCreateInput = {
    id?: string
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
    buyer?: BuyerCreateNestedOneWithoutServicesInput
    customerDevice?: CustomerDeviceCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    buyerId?: string | null
    customerDeviceId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type ServiceUpdateInput = {
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
    buyer?: BuyerUpdateOneWithoutServicesNestedInput
    customerDevice?: CustomerDeviceUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ServiceCreateManyInput = {
    id?: string
    buyerId?: string | null
    customerDeviceId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type ServiceUpdateManyMutationInput = {
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type CashflowCreateInput = {
    id?: string
    active: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    openingBalance: number
    total: number
    expenses: number
    cashSales: number
    cashServices: number
    digitalSales: number
    digitalServices: number
    observations: string
  }

  export type CashflowUncheckedCreateInput = {
    id?: string
    active: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    openingBalance: number
    total: number
    expenses: number
    cashSales: number
    cashServices: number
    digitalSales: number
    digitalServices: number
    observations: string
  }

  export type CashflowUpdateInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    expenses?: FloatFieldUpdateOperationsInput | number
    cashSales?: FloatFieldUpdateOperationsInput | number
    cashServices?: FloatFieldUpdateOperationsInput | number
    digitalSales?: FloatFieldUpdateOperationsInput | number
    digitalServices?: FloatFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
  }

  export type CashflowUncheckedUpdateInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    expenses?: FloatFieldUpdateOperationsInput | number
    cashSales?: FloatFieldUpdateOperationsInput | number
    cashServices?: FloatFieldUpdateOperationsInput | number
    digitalSales?: FloatFieldUpdateOperationsInput | number
    digitalServices?: FloatFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
  }

  export type CashflowCreateManyInput = {
    id?: string
    active: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    openingBalance: number
    total: number
    expenses: number
    cashSales: number
    cashServices: number
    digitalSales: number
    digitalServices: number
    observations: string
  }

  export type CashflowUpdateManyMutationInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    expenses?: FloatFieldUpdateOperationsInput | number
    cashSales?: FloatFieldUpdateOperationsInput | number
    cashServices?: FloatFieldUpdateOperationsInput | number
    digitalSales?: FloatFieldUpdateOperationsInput | number
    digitalServices?: FloatFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
  }

  export type CashflowUncheckedUpdateManyInput = {
    active?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    expenses?: FloatFieldUpdateOperationsInput | number
    cashSales?: FloatFieldUpdateOperationsInput | number
    cashServices?: FloatFieldUpdateOperationsInput | number
    digitalSales?: FloatFieldUpdateOperationsInput | number
    digitalServices?: FloatFieldUpdateOperationsInput | number
    observations?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    username?: string | null
    email: string
    password: string
    avatar?: string | null
    sucursal?: string | null
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username?: string | null
    email: string
    password: string
    avatar?: string | null
    sucursal?: string | null
  }

  export type UserUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyInput = {
    id?: string
    username?: string | null
    email: string
    password: string
    avatar?: string | null
    sucursal?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    provider?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    hasVariants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    provider?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    hasVariants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    provider?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    hasVariants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    design?: SortOrder
    size?: SortOrder
    material?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    images?: SortOrder
    specifications?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    design?: SortOrder
    size?: SortOrder
    material?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    barcode?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    design?: SortOrder
    size?: SortOrder
    material?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    promoPrice?: SortOrder
    percentPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    purchaseHistory?: SortOrder
    serviceHistory?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    details?: SortOrder
    date?: SortOrder
    products?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    payments?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    details?: SortOrder
    date?: SortOrder
    total?: SortOrder
    discount?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    details?: SortOrder
    date?: SortOrder
    total?: SortOrder
    discount?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    details?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    category?: SortOrder
    categoryId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
    categoryId?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    details?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    category?: SortOrder
    categoryId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    product?: SortOrder
    details?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    category?: SortOrder
    categoryId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
    categoryId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type EnumCustomerSegmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentFilter<$PrismaModel> | $Enums.CustomerSegment
  }

  export type CommunicationPreferencesNullableScalarRelationFilter = {
    is?: CommunicationPreferencesWhereInput | null
    isNot?: CommunicationPreferencesWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type POSSaleListRelationFilter = {
    every?: POSSaleWhereInput
    some?: POSSaleWhereInput
    none?: POSSaleWhereInput
  }

  export type CustomerDeviceListRelationFilter = {
    every?: CustomerDeviceWhereInput
    some?: CustomerDeviceWhereInput
    none?: CustomerDeviceWhereInput
  }

  export type ProductInteractionListRelationFilter = {
    every?: ProductInteractionWhereInput
    some?: ProductInteractionWhereInput
    none?: ProductInteractionWhereInput
  }

  export type BrowsingEventListRelationFilter = {
    every?: BrowsingEventWhereInput
    some?: BrowsingEventWhereInput
    none?: BrowsingEventWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrowsingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuyerCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    dni?: SortOrder
    cuit?: SortOrder
    telefono?: SortOrder
    whatsapp?: SortOrder
    fecha_nacimiento?: SortOrder
    direccion?: SortOrder
    acquisition_channel?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_content?: SortOrder
    utm_term?: SortOrder
    segment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    last_interaction?: SortOrder
  }

  export type BuyerMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    dni?: SortOrder
    cuit?: SortOrder
    telefono?: SortOrder
    whatsapp?: SortOrder
    fecha_nacimiento?: SortOrder
    direccion?: SortOrder
    acquisition_channel?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_content?: SortOrder
    utm_term?: SortOrder
    segment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    last_interaction?: SortOrder
  }

  export type BuyerMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    dni?: SortOrder
    cuit?: SortOrder
    telefono?: SortOrder
    whatsapp?: SortOrder
    fecha_nacimiento?: SortOrder
    direccion?: SortOrder
    acquisition_channel?: SortOrder
    utm_source?: SortOrder
    utm_medium?: SortOrder
    utm_campaign?: SortOrder
    utm_content?: SortOrder
    utm_term?: SortOrder
    segment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    last_interaction?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumCustomerSegmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel> | $Enums.CustomerSegment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerSegmentFilter<$PrismaModel>
    _max?: NestedEnumCustomerSegmentFilter<$PrismaModel>
  }

  export type EnumCommunicationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelFilter<$PrismaModel> | $Enums.CommunicationChannel
  }

  export type BuyerScalarRelationFilter = {
    is?: BuyerWhereInput
    isNot?: BuyerWhereInput
  }

  export type CommunicationPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    email_marketing?: SortOrder
    email_transaccional?: SortOrder
    sms_marketing?: SortOrder
    sms_transaccional?: SortOrder
    whatsapp_marketing?: SortOrder
    whatsapp_transaccional?: SortOrder
    llamadas_comerciales?: SortOrder
    preferred_channel?: SortOrder
    best_contact_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    email_marketing?: SortOrder
    email_transaccional?: SortOrder
    sms_marketing?: SortOrder
    sms_transaccional?: SortOrder
    whatsapp_marketing?: SortOrder
    whatsapp_transaccional?: SortOrder
    llamadas_comerciales?: SortOrder
    preferred_channel?: SortOrder
    best_contact_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    email_marketing?: SortOrder
    email_transaccional?: SortOrder
    sms_marketing?: SortOrder
    sms_transaccional?: SortOrder
    whatsapp_marketing?: SortOrder
    whatsapp_transaccional?: SortOrder
    llamadas_comerciales?: SortOrder
    preferred_channel?: SortOrder
    best_contact_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommunicationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationChannelFilter<$PrismaModel>
    _max?: NestedEnumCommunicationChannelFilter<$PrismaModel>
  }

  export type CustomerDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    numero_serie?: SortOrder
    imei?: SortOrder
    color?: SortOrder
    capacidad?: SortOrder
    fecha_compra?: SortOrder
    lugar_compra?: SortOrder
    precio_compra?: SortOrder
    tiene_garantia?: SortOrder
    garantia_hasta?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerDeviceAvgOrderByAggregateInput = {
    precio_compra?: SortOrder
  }

  export type CustomerDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    numero_serie?: SortOrder
    imei?: SortOrder
    color?: SortOrder
    capacidad?: SortOrder
    fecha_compra?: SortOrder
    lugar_compra?: SortOrder
    precio_compra?: SortOrder
    tiene_garantia?: SortOrder
    garantia_hasta?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    numero_serie?: SortOrder
    imei?: SortOrder
    color?: SortOrder
    capacidad?: SortOrder
    fecha_compra?: SortOrder
    lugar_compra?: SortOrder
    precio_compra?: SortOrder
    tiene_garantia?: SortOrder
    garantia_hasta?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerDeviceSumOrderByAggregateInput = {
    precio_compra?: SortOrder
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type ProductInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    tipo?: SortOrder
    session_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    quantity?: SortOrder
    price_at_interaction?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductInteractionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price_at_interaction?: SortOrder
  }

  export type ProductInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    tipo?: SortOrder
    session_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    quantity?: SortOrder
    price_at_interaction?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    tipo?: SortOrder
    session_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    quantity?: SortOrder
    price_at_interaction?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductInteractionSumOrderByAggregateInput = {
    quantity?: SortOrder
    price_at_interaction?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type BuyerNullableScalarRelationFilter = {
    is?: BuyerWhereInput | null
    isNot?: BuyerWhereInput | null
  }

  export type BrowsingEventCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    session_id?: SortOrder
    page_url?: SortOrder
    page_title?: SortOrder
    time_spent?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    device_type?: SortOrder
    createdAt?: SortOrder
  }

  export type BrowsingEventAvgOrderByAggregateInput = {
    time_spent?: SortOrder
  }

  export type BrowsingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    session_id?: SortOrder
    page_url?: SortOrder
    page_title?: SortOrder
    time_spent?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    device_type?: SortOrder
    createdAt?: SortOrder
  }

  export type BrowsingEventMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    session_id?: SortOrder
    page_url?: SortOrder
    page_title?: SortOrder
    time_spent?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referrer?: SortOrder
    device_type?: SortOrder
    createdAt?: SortOrder
  }

  export type BrowsingEventSumOrderByAggregateInput = {
    time_spent?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    tipo?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    related_order_id?: SortOrder
    related_service_id?: SortOrder
    related_product_id?: SortOrder
    respuesta?: SortOrder
    respondido_por?: SortOrder
    fecha_respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    tipo?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    related_order_id?: SortOrder
    related_service_id?: SortOrder
    related_product_id?: SortOrder
    respuesta?: SortOrder
    respondido_por?: SortOrder
    fecha_respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    tipo?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    related_order_id?: SortOrder
    related_service_id?: SortOrder
    related_product_id?: SortOrder
    respuesta?: SortOrder
    respondido_por?: SortOrder
    fecha_respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type OrderDetailListRelationFilter = {
    every?: OrderDetailWhereInput
    some?: OrderDetailWhereInput
    none?: OrderDetailWhereInput
  }

  export type OrderDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    info_envio?: SortOrder
    id_transaccion_pasarela?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    monto_total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    id_transaccion_pasarela?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
    id_transaccion_pasarela?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    monto_total?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderDetailCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type OrderDetailAvgOrderByAggregateInput = {
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type OrderDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type OrderDetailMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type OrderDetailSumOrderByAggregateInput = {
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type POSSaleDetailListRelationFilter = {
    every?: POSSaleDetailWhereInput
    some?: POSSaleDetailWhereInput
    none?: POSSaleDetailWhereInput
  }

  export type POSSaleDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSSaleCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
    metodo_pago?: SortOrder
  }

  export type POSSaleAvgOrderByAggregateInput = {
    monto_total?: SortOrder
  }

  export type POSSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
  }

  export type POSSaleMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    fecha_creacion?: SortOrder
    monto_total?: SortOrder
    estado?: SortOrder
  }

  export type POSSaleSumOrderByAggregateInput = {
    monto_total?: SortOrder
  }

  export type POSSaleScalarRelationFilter = {
    is?: POSSaleWhereInput
    isNot?: POSSaleWhereInput
  }

  export type POSSaleDetailCountOrderByAggregateInput = {
    id?: SortOrder
    posSaleId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type POSSaleDetailAvgOrderByAggregateInput = {
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type POSSaleDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    posSaleId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type POSSaleDetailMinOrderByAggregateInput = {
    id?: SortOrder
    posSaleId?: SortOrder
    productoId?: SortOrder
    productoName?: SortOrder
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type POSSaleDetailSumOrderByAggregateInput = {
    cantidad?: SortOrder
    precio_unitario_al_momento_de_compra?: SortOrder
  }

  export type EnumDeviceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceStatusNullableFilter<$PrismaModel> | $Enums.DeviceStatus | null
    isSet?: boolean
  }

  export type CustomerDeviceNullableScalarRelationFilter = {
    is?: CustomerDeviceWhereInput | null
    isNot?: CustomerDeviceWhereInput | null
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    customerDeviceId?: SortOrder
    device?: SortOrder
    client?: SortOrder
    state?: SortOrder
    diagnostico?: SortOrder
    estado_dispositivo_al_ingresar?: SortOrder
    observaciones?: SortOrder
    repair?: SortOrder
    piezas?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    date?: SortOrder
    dateOut?: SortOrder
    fecha_presupuesto?: SortOrder
    fecha_aprobacion?: SortOrder
    garantia_hasta?: SortOrder
    observaciones_garantia?: SortOrder
    payments?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    customerDeviceId?: SortOrder
    state?: SortOrder
    diagnostico?: SortOrder
    estado_dispositivo_al_ingresar?: SortOrder
    observaciones?: SortOrder
    repair?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    date?: SortOrder
    dateOut?: SortOrder
    fecha_presupuesto?: SortOrder
    fecha_aprobacion?: SortOrder
    garantia_hasta?: SortOrder
    observaciones_garantia?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    customerDeviceId?: SortOrder
    state?: SortOrder
    diagnostico?: SortOrder
    estado_dispositivo_al_ingresar?: SortOrder
    observaciones?: SortOrder
    repair?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    date?: SortOrder
    dateOut?: SortOrder
    fecha_presupuesto?: SortOrder
    fecha_aprobacion?: SortOrder
    garantia_hasta?: SortOrder
    observaciones_garantia?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
  }

  export type EnumDeviceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type CashflowCountOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
    observations?: SortOrder
  }

  export type CashflowAvgOrderByAggregateInput = {
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
  }

  export type CashflowMaxOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
    observations?: SortOrder
  }

  export type CashflowMinOrderByAggregateInput = {
    id?: SortOrder
    active?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
    observations?: SortOrder
  }

  export type CashflowSumOrderByAggregateInput = {
    openingBalance?: SortOrder
    total?: SortOrder
    expenses?: SortOrder
    cashSales?: SortOrder
    cashServices?: SortOrder
    digitalSales?: SortOrder
    digitalServices?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    sucursal?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    sucursal?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    sucursal?: SortOrder
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductVariantCreateimagesInput = {
    set: string[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ProductVariantUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type CustomerCreatepurchaseHistoryInput = {
    set: string[]
  }

  export type CustomerCreateserviceHistoryInput = {
    set: string[]
  }

  export type CustomerUpdatepurchaseHistoryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomerUpdateserviceHistoryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type BuyerCreatetagsInput = {
    set: string[]
  }

  export type CommunicationPreferencesCreateNestedOneWithoutBuyerInput = {
    create?: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: CommunicationPreferencesCreateOrConnectWithoutBuyerInput
    connect?: CommunicationPreferencesWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutBuyerInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type POSSaleCreateNestedManyWithoutBuyerInput = {
    create?: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput> | POSSaleCreateWithoutBuyerInput[] | POSSaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutBuyerInput | POSSaleCreateOrConnectWithoutBuyerInput[]
    createMany?: POSSaleCreateManyBuyerInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type CustomerDeviceCreateNestedManyWithoutBuyerInput = {
    create?: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput> | CustomerDeviceCreateWithoutBuyerInput[] | CustomerDeviceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutBuyerInput | CustomerDeviceCreateOrConnectWithoutBuyerInput[]
    createMany?: CustomerDeviceCreateManyBuyerInputEnvelope
    connect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
  }

  export type ProductInteractionCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput> | ProductInteractionCreateWithoutBuyerInput[] | ProductInteractionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ProductInteractionCreateOrConnectWithoutBuyerInput | ProductInteractionCreateOrConnectWithoutBuyerInput[]
    createMany?: ProductInteractionCreateManyBuyerInputEnvelope
    connect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
  }

  export type BrowsingEventCreateNestedManyWithoutBuyerInput = {
    create?: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput> | BrowsingEventCreateWithoutBuyerInput[] | BrowsingEventUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: BrowsingEventCreateOrConnectWithoutBuyerInput | BrowsingEventCreateOrConnectWithoutBuyerInput[]
    createMany?: BrowsingEventCreateManyBuyerInputEnvelope
    connect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutBuyerInput = {
    create?: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput> | FeedbackCreateWithoutBuyerInput[] | FeedbackUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutBuyerInput | FeedbackCreateOrConnectWithoutBuyerInput[]
    createMany?: FeedbackCreateManyBuyerInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput> | ServiceCreateWithoutBuyerInput[] | ServiceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBuyerInput | ServiceCreateOrConnectWithoutBuyerInput[]
    createMany?: ServiceCreateManyBuyerInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput = {
    create?: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: CommunicationPreferencesCreateOrConnectWithoutBuyerInput
    connect?: CommunicationPreferencesWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput> | POSSaleCreateWithoutBuyerInput[] | POSSaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutBuyerInput | POSSaleCreateOrConnectWithoutBuyerInput[]
    createMany?: POSSaleCreateManyBuyerInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput> | CustomerDeviceCreateWithoutBuyerInput[] | CustomerDeviceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutBuyerInput | CustomerDeviceCreateOrConnectWithoutBuyerInput[]
    createMany?: CustomerDeviceCreateManyBuyerInputEnvelope
    connect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
  }

  export type ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput> | ProductInteractionCreateWithoutBuyerInput[] | ProductInteractionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ProductInteractionCreateOrConnectWithoutBuyerInput | ProductInteractionCreateOrConnectWithoutBuyerInput[]
    createMany?: ProductInteractionCreateManyBuyerInputEnvelope
    connect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
  }

  export type BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput> | BrowsingEventCreateWithoutBuyerInput[] | BrowsingEventUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: BrowsingEventCreateOrConnectWithoutBuyerInput | BrowsingEventCreateOrConnectWithoutBuyerInput[]
    createMany?: BrowsingEventCreateManyBuyerInputEnvelope
    connect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput> | FeedbackCreateWithoutBuyerInput[] | FeedbackUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutBuyerInput | FeedbackCreateOrConnectWithoutBuyerInput[]
    createMany?: FeedbackCreateManyBuyerInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput> | ServiceCreateWithoutBuyerInput[] | ServiceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBuyerInput | ServiceCreateOrConnectWithoutBuyerInput[]
    createMany?: ServiceCreateManyBuyerInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type EnumCustomerSegmentFieldUpdateOperationsInput = {
    set?: $Enums.CustomerSegment
  }

  export type BuyerUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationPreferencesUpdateOneWithoutBuyerNestedInput = {
    create?: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: CommunicationPreferencesCreateOrConnectWithoutBuyerInput
    upsert?: CommunicationPreferencesUpsertWithoutBuyerInput
    disconnect?: CommunicationPreferencesWhereInput | boolean
    delete?: CommunicationPreferencesWhereInput | boolean
    connect?: CommunicationPreferencesWhereUniqueInput
    update?: XOR<XOR<CommunicationPreferencesUpdateToOneWithWhereWithoutBuyerInput, CommunicationPreferencesUpdateWithoutBuyerInput>, CommunicationPreferencesUncheckedUpdateWithoutBuyerInput>
  }

  export type OrderUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBuyerInput | OrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBuyerInput | OrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBuyerInput | OrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type POSSaleUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput> | POSSaleCreateWithoutBuyerInput[] | POSSaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutBuyerInput | POSSaleCreateOrConnectWithoutBuyerInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutBuyerInput | POSSaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: POSSaleCreateManyBuyerInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutBuyerInput | POSSaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutBuyerInput | POSSaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type CustomerDeviceUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput> | CustomerDeviceCreateWithoutBuyerInput[] | CustomerDeviceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutBuyerInput | CustomerDeviceCreateOrConnectWithoutBuyerInput[]
    upsert?: CustomerDeviceUpsertWithWhereUniqueWithoutBuyerInput | CustomerDeviceUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: CustomerDeviceCreateManyBuyerInputEnvelope
    set?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    disconnect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    delete?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    connect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    update?: CustomerDeviceUpdateWithWhereUniqueWithoutBuyerInput | CustomerDeviceUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: CustomerDeviceUpdateManyWithWhereWithoutBuyerInput | CustomerDeviceUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: CustomerDeviceScalarWhereInput | CustomerDeviceScalarWhereInput[]
  }

  export type ProductInteractionUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput> | ProductInteractionCreateWithoutBuyerInput[] | ProductInteractionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ProductInteractionCreateOrConnectWithoutBuyerInput | ProductInteractionCreateOrConnectWithoutBuyerInput[]
    upsert?: ProductInteractionUpsertWithWhereUniqueWithoutBuyerInput | ProductInteractionUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ProductInteractionCreateManyBuyerInputEnvelope
    set?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    disconnect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    delete?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    connect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    update?: ProductInteractionUpdateWithWhereUniqueWithoutBuyerInput | ProductInteractionUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ProductInteractionUpdateManyWithWhereWithoutBuyerInput | ProductInteractionUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ProductInteractionScalarWhereInput | ProductInteractionScalarWhereInput[]
  }

  export type BrowsingEventUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput> | BrowsingEventCreateWithoutBuyerInput[] | BrowsingEventUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: BrowsingEventCreateOrConnectWithoutBuyerInput | BrowsingEventCreateOrConnectWithoutBuyerInput[]
    upsert?: BrowsingEventUpsertWithWhereUniqueWithoutBuyerInput | BrowsingEventUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: BrowsingEventCreateManyBuyerInputEnvelope
    set?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    disconnect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    delete?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    connect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    update?: BrowsingEventUpdateWithWhereUniqueWithoutBuyerInput | BrowsingEventUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: BrowsingEventUpdateManyWithWhereWithoutBuyerInput | BrowsingEventUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: BrowsingEventScalarWhereInput | BrowsingEventScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput> | FeedbackCreateWithoutBuyerInput[] | FeedbackUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutBuyerInput | FeedbackCreateOrConnectWithoutBuyerInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutBuyerInput | FeedbackUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: FeedbackCreateManyBuyerInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutBuyerInput | FeedbackUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutBuyerInput | FeedbackUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput> | ServiceCreateWithoutBuyerInput[] | ServiceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBuyerInput | ServiceCreateOrConnectWithoutBuyerInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutBuyerInput | ServiceUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ServiceCreateManyBuyerInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutBuyerInput | ServiceUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutBuyerInput | ServiceUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput = {
    create?: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
    connectOrCreate?: CommunicationPreferencesCreateOrConnectWithoutBuyerInput
    upsert?: CommunicationPreferencesUpsertWithoutBuyerInput
    disconnect?: CommunicationPreferencesWhereInput | boolean
    delete?: CommunicationPreferencesWhereInput | boolean
    connect?: CommunicationPreferencesWhereUniqueInput
    update?: XOR<XOR<CommunicationPreferencesUpdateToOneWithWhereWithoutBuyerInput, CommunicationPreferencesUpdateWithoutBuyerInput>, CommunicationPreferencesUncheckedUpdateWithoutBuyerInput>
  }

  export type OrderUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput> | OrderCreateWithoutBuyerInput[] | OrderUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutBuyerInput | OrderCreateOrConnectWithoutBuyerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutBuyerInput | OrderUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: OrderCreateManyBuyerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutBuyerInput | OrderUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutBuyerInput | OrderUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput> | POSSaleCreateWithoutBuyerInput[] | POSSaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutBuyerInput | POSSaleCreateOrConnectWithoutBuyerInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutBuyerInput | POSSaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: POSSaleCreateManyBuyerInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutBuyerInput | POSSaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutBuyerInput | POSSaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput> | CustomerDeviceCreateWithoutBuyerInput[] | CustomerDeviceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutBuyerInput | CustomerDeviceCreateOrConnectWithoutBuyerInput[]
    upsert?: CustomerDeviceUpsertWithWhereUniqueWithoutBuyerInput | CustomerDeviceUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: CustomerDeviceCreateManyBuyerInputEnvelope
    set?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    disconnect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    delete?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    connect?: CustomerDeviceWhereUniqueInput | CustomerDeviceWhereUniqueInput[]
    update?: CustomerDeviceUpdateWithWhereUniqueWithoutBuyerInput | CustomerDeviceUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: CustomerDeviceUpdateManyWithWhereWithoutBuyerInput | CustomerDeviceUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: CustomerDeviceScalarWhereInput | CustomerDeviceScalarWhereInput[]
  }

  export type ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput> | ProductInteractionCreateWithoutBuyerInput[] | ProductInteractionUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ProductInteractionCreateOrConnectWithoutBuyerInput | ProductInteractionCreateOrConnectWithoutBuyerInput[]
    upsert?: ProductInteractionUpsertWithWhereUniqueWithoutBuyerInput | ProductInteractionUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ProductInteractionCreateManyBuyerInputEnvelope
    set?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    disconnect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    delete?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    connect?: ProductInteractionWhereUniqueInput | ProductInteractionWhereUniqueInput[]
    update?: ProductInteractionUpdateWithWhereUniqueWithoutBuyerInput | ProductInteractionUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ProductInteractionUpdateManyWithWhereWithoutBuyerInput | ProductInteractionUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ProductInteractionScalarWhereInput | ProductInteractionScalarWhereInput[]
  }

  export type BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput> | BrowsingEventCreateWithoutBuyerInput[] | BrowsingEventUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: BrowsingEventCreateOrConnectWithoutBuyerInput | BrowsingEventCreateOrConnectWithoutBuyerInput[]
    upsert?: BrowsingEventUpsertWithWhereUniqueWithoutBuyerInput | BrowsingEventUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: BrowsingEventCreateManyBuyerInputEnvelope
    set?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    disconnect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    delete?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    connect?: BrowsingEventWhereUniqueInput | BrowsingEventWhereUniqueInput[]
    update?: BrowsingEventUpdateWithWhereUniqueWithoutBuyerInput | BrowsingEventUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: BrowsingEventUpdateManyWithWhereWithoutBuyerInput | BrowsingEventUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: BrowsingEventScalarWhereInput | BrowsingEventScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput> | FeedbackCreateWithoutBuyerInput[] | FeedbackUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutBuyerInput | FeedbackCreateOrConnectWithoutBuyerInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutBuyerInput | FeedbackUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: FeedbackCreateManyBuyerInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutBuyerInput | FeedbackUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutBuyerInput | FeedbackUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput> | ServiceCreateWithoutBuyerInput[] | ServiceUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutBuyerInput | ServiceCreateOrConnectWithoutBuyerInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutBuyerInput | ServiceUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: ServiceCreateManyBuyerInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutBuyerInput | ServiceUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutBuyerInput | ServiceUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BuyerCreateNestedOneWithoutCommunication_preferencesInput = {
    create?: XOR<BuyerCreateWithoutCommunication_preferencesInput, BuyerUncheckedCreateWithoutCommunication_preferencesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutCommunication_preferencesInput
    connect?: BuyerWhereUniqueInput
  }

  export type EnumCommunicationChannelFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationChannel
  }

  export type BuyerUpdateOneRequiredWithoutCommunication_preferencesNestedInput = {
    create?: XOR<BuyerCreateWithoutCommunication_preferencesInput, BuyerUncheckedCreateWithoutCommunication_preferencesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutCommunication_preferencesInput
    upsert?: BuyerUpsertWithoutCommunication_preferencesInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutCommunication_preferencesInput, BuyerUpdateWithoutCommunication_preferencesInput>, BuyerUncheckedUpdateWithoutCommunication_preferencesInput>
  }

  export type BuyerCreateNestedOneWithoutDevicesInput = {
    create?: XOR<BuyerCreateWithoutDevicesInput, BuyerUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutDevicesInput
    connect?: BuyerWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutCustomerDeviceInput = {
    create?: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput> | ServiceCreateWithoutCustomerDeviceInput[] | ServiceUncheckedCreateWithoutCustomerDeviceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomerDeviceInput | ServiceCreateOrConnectWithoutCustomerDeviceInput[]
    createMany?: ServiceCreateManyCustomerDeviceInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCustomerDeviceInput = {
    create?: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput> | ServiceCreateWithoutCustomerDeviceInput[] | ServiceUncheckedCreateWithoutCustomerDeviceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomerDeviceInput | ServiceCreateOrConnectWithoutCustomerDeviceInput[]
    createMany?: ServiceCreateManyCustomerDeviceInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type BuyerUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<BuyerCreateWithoutDevicesInput, BuyerUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutDevicesInput
    upsert?: BuyerUpsertWithoutDevicesInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutDevicesInput, BuyerUpdateWithoutDevicesInput>, BuyerUncheckedUpdateWithoutDevicesInput>
  }

  export type ServiceUpdateManyWithoutCustomerDeviceNestedInput = {
    create?: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput> | ServiceCreateWithoutCustomerDeviceInput[] | ServiceUncheckedCreateWithoutCustomerDeviceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomerDeviceInput | ServiceCreateOrConnectWithoutCustomerDeviceInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCustomerDeviceInput | ServiceUpsertWithWhereUniqueWithoutCustomerDeviceInput[]
    createMany?: ServiceCreateManyCustomerDeviceInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCustomerDeviceInput | ServiceUpdateWithWhereUniqueWithoutCustomerDeviceInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCustomerDeviceInput | ServiceUpdateManyWithWhereWithoutCustomerDeviceInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCustomerDeviceNestedInput = {
    create?: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput> | ServiceCreateWithoutCustomerDeviceInput[] | ServiceUncheckedCreateWithoutCustomerDeviceInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCustomerDeviceInput | ServiceCreateOrConnectWithoutCustomerDeviceInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCustomerDeviceInput | ServiceUpsertWithWhereUniqueWithoutCustomerDeviceInput[]
    createMany?: ServiceCreateManyCustomerDeviceInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCustomerDeviceInput | ServiceUpdateWithWhereUniqueWithoutCustomerDeviceInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCustomerDeviceInput | ServiceUpdateManyWithWhereWithoutCustomerDeviceInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BuyerCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<BuyerCreateWithoutInteractionsInput, BuyerUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutInteractionsInput
    connect?: BuyerWhereUniqueInput
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type BuyerUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<BuyerCreateWithoutInteractionsInput, BuyerUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutInteractionsInput
    upsert?: BuyerUpsertWithoutInteractionsInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutInteractionsInput, BuyerUpdateWithoutInteractionsInput>, BuyerUncheckedUpdateWithoutInteractionsInput>
  }

  export type BuyerCreateNestedOneWithoutBrowsingEventsInput = {
    create?: XOR<BuyerCreateWithoutBrowsingEventsInput, BuyerUncheckedCreateWithoutBrowsingEventsInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutBrowsingEventsInput
    connect?: BuyerWhereUniqueInput
  }

  export type BuyerUpdateOneWithoutBrowsingEventsNestedInput = {
    create?: XOR<BuyerCreateWithoutBrowsingEventsInput, BuyerUncheckedCreateWithoutBrowsingEventsInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutBrowsingEventsInput
    upsert?: BuyerUpsertWithoutBrowsingEventsInput
    disconnect?: boolean
    delete?: BuyerWhereInput | boolean
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutBrowsingEventsInput, BuyerUpdateWithoutBrowsingEventsInput>, BuyerUncheckedUpdateWithoutBrowsingEventsInput>
  }

  export type BuyerCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<BuyerCreateWithoutFeedbackInput, BuyerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutFeedbackInput
    connect?: BuyerWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type BuyerUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<BuyerCreateWithoutFeedbackInput, BuyerUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutFeedbackInput
    upsert?: BuyerUpsertWithoutFeedbackInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutFeedbackInput, BuyerUpdateWithoutFeedbackInput>, BuyerUncheckedUpdateWithoutFeedbackInput>
  }

  export type BuyerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BuyerCreateWithoutOrdersInput, BuyerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutOrdersInput
    connect?: BuyerWhereUniqueInput
  }

  export type OrderDetailCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput> | OrderDetailCreateWithoutOrderInput[] | OrderDetailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetailCreateOrConnectWithoutOrderInput | OrderDetailCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDetailCreateManyOrderInputEnvelope
    connect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
  }

  export type OrderDetailUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput> | OrderDetailCreateWithoutOrderInput[] | OrderDetailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetailCreateOrConnectWithoutOrderInput | OrderDetailCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDetailCreateManyOrderInputEnvelope
    connect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
  }

  export type BuyerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<BuyerCreateWithoutOrdersInput, BuyerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutOrdersInput
    upsert?: BuyerUpsertWithoutOrdersInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutOrdersInput, BuyerUpdateWithoutOrdersInput>, BuyerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderDetailUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput> | OrderDetailCreateWithoutOrderInput[] | OrderDetailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetailCreateOrConnectWithoutOrderInput | OrderDetailCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDetailUpsertWithWhereUniqueWithoutOrderInput | OrderDetailUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDetailCreateManyOrderInputEnvelope
    set?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    disconnect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    delete?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    connect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    update?: OrderDetailUpdateWithWhereUniqueWithoutOrderInput | OrderDetailUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDetailUpdateManyWithWhereWithoutOrderInput | OrderDetailUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDetailScalarWhereInput | OrderDetailScalarWhereInput[]
  }

  export type OrderDetailUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput> | OrderDetailCreateWithoutOrderInput[] | OrderDetailUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetailCreateOrConnectWithoutOrderInput | OrderDetailCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDetailUpsertWithWhereUniqueWithoutOrderInput | OrderDetailUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDetailCreateManyOrderInputEnvelope
    set?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    disconnect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    delete?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    connect?: OrderDetailWhereUniqueInput | OrderDetailWhereUniqueInput[]
    update?: OrderDetailUpdateWithWhereUniqueWithoutOrderInput | OrderDetailUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDetailUpdateManyWithWhereWithoutOrderInput | OrderDetailUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDetailScalarWhereInput | OrderDetailScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutDetallesInput = {
    create?: XOR<OrderCreateWithoutDetallesInput, OrderUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDetallesInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<OrderCreateWithoutDetallesInput, OrderUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDetallesInput
    upsert?: OrderUpsertWithoutDetallesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDetallesInput, OrderUpdateWithoutDetallesInput>, OrderUncheckedUpdateWithoutDetallesInput>
  }

  export type BuyerCreateNestedOneWithoutPosSalesInput = {
    create?: XOR<BuyerCreateWithoutPosSalesInput, BuyerUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutPosSalesInput
    connect?: BuyerWhereUniqueInput
  }

  export type POSSaleDetailCreateNestedManyWithoutPosSaleInput = {
    create?: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput> | POSSaleDetailCreateWithoutPosSaleInput[] | POSSaleDetailUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: POSSaleDetailCreateOrConnectWithoutPosSaleInput | POSSaleDetailCreateOrConnectWithoutPosSaleInput[]
    createMany?: POSSaleDetailCreateManyPosSaleInputEnvelope
    connect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
  }

  export type POSSaleDetailUncheckedCreateNestedManyWithoutPosSaleInput = {
    create?: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput> | POSSaleDetailCreateWithoutPosSaleInput[] | POSSaleDetailUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: POSSaleDetailCreateOrConnectWithoutPosSaleInput | POSSaleDetailCreateOrConnectWithoutPosSaleInput[]
    createMany?: POSSaleDetailCreateManyPosSaleInputEnvelope
    connect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
  }

  export type BuyerUpdateOneRequiredWithoutPosSalesNestedInput = {
    create?: XOR<BuyerCreateWithoutPosSalesInput, BuyerUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutPosSalesInput
    upsert?: BuyerUpsertWithoutPosSalesInput
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutPosSalesInput, BuyerUpdateWithoutPosSalesInput>, BuyerUncheckedUpdateWithoutPosSalesInput>
  }

  export type POSSaleDetailUpdateManyWithoutPosSaleNestedInput = {
    create?: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput> | POSSaleDetailCreateWithoutPosSaleInput[] | POSSaleDetailUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: POSSaleDetailCreateOrConnectWithoutPosSaleInput | POSSaleDetailCreateOrConnectWithoutPosSaleInput[]
    upsert?: POSSaleDetailUpsertWithWhereUniqueWithoutPosSaleInput | POSSaleDetailUpsertWithWhereUniqueWithoutPosSaleInput[]
    createMany?: POSSaleDetailCreateManyPosSaleInputEnvelope
    set?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    disconnect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    delete?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    connect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    update?: POSSaleDetailUpdateWithWhereUniqueWithoutPosSaleInput | POSSaleDetailUpdateWithWhereUniqueWithoutPosSaleInput[]
    updateMany?: POSSaleDetailUpdateManyWithWhereWithoutPosSaleInput | POSSaleDetailUpdateManyWithWhereWithoutPosSaleInput[]
    deleteMany?: POSSaleDetailScalarWhereInput | POSSaleDetailScalarWhereInput[]
  }

  export type POSSaleDetailUncheckedUpdateManyWithoutPosSaleNestedInput = {
    create?: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput> | POSSaleDetailCreateWithoutPosSaleInput[] | POSSaleDetailUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: POSSaleDetailCreateOrConnectWithoutPosSaleInput | POSSaleDetailCreateOrConnectWithoutPosSaleInput[]
    upsert?: POSSaleDetailUpsertWithWhereUniqueWithoutPosSaleInput | POSSaleDetailUpsertWithWhereUniqueWithoutPosSaleInput[]
    createMany?: POSSaleDetailCreateManyPosSaleInputEnvelope
    set?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    disconnect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    delete?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    connect?: POSSaleDetailWhereUniqueInput | POSSaleDetailWhereUniqueInput[]
    update?: POSSaleDetailUpdateWithWhereUniqueWithoutPosSaleInput | POSSaleDetailUpdateWithWhereUniqueWithoutPosSaleInput[]
    updateMany?: POSSaleDetailUpdateManyWithWhereWithoutPosSaleInput | POSSaleDetailUpdateManyWithWhereWithoutPosSaleInput[]
    deleteMany?: POSSaleDetailScalarWhereInput | POSSaleDetailScalarWhereInput[]
  }

  export type POSSaleCreateNestedOneWithoutDetallesInput = {
    create?: XOR<POSSaleCreateWithoutDetallesInput, POSSaleUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutDetallesInput
    connect?: POSSaleWhereUniqueInput
  }

  export type POSSaleUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<POSSaleCreateWithoutDetallesInput, POSSaleUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutDetallesInput
    upsert?: POSSaleUpsertWithoutDetallesInput
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutDetallesInput, POSSaleUpdateWithoutDetallesInput>, POSSaleUncheckedUpdateWithoutDetallesInput>
  }

  export type BuyerCreateNestedOneWithoutServicesInput = {
    create?: XOR<BuyerCreateWithoutServicesInput, BuyerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutServicesInput
    connect?: BuyerWhereUniqueInput
  }

  export type CustomerDeviceCreateNestedOneWithoutServicesInput = {
    create?: XOR<CustomerDeviceCreateWithoutServicesInput, CustomerDeviceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutServicesInput
    connect?: CustomerDeviceWhereUniqueInput
  }

  export type NullableEnumDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceStatus | null
    unset?: boolean
  }

  export type BuyerUpdateOneWithoutServicesNestedInput = {
    create?: XOR<BuyerCreateWithoutServicesInput, BuyerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BuyerCreateOrConnectWithoutServicesInput
    upsert?: BuyerUpsertWithoutServicesInput
    disconnect?: boolean
    delete?: BuyerWhereInput | boolean
    connect?: BuyerWhereUniqueInput
    update?: XOR<XOR<BuyerUpdateToOneWithWhereWithoutServicesInput, BuyerUpdateWithoutServicesInput>, BuyerUncheckedUpdateWithoutServicesInput>
  }

  export type CustomerDeviceUpdateOneWithoutServicesNestedInput = {
    create?: XOR<CustomerDeviceCreateWithoutServicesInput, CustomerDeviceUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CustomerDeviceCreateOrConnectWithoutServicesInput
    upsert?: CustomerDeviceUpsertWithoutServicesInput
    disconnect?: boolean
    delete?: CustomerDeviceWhereInput | boolean
    connect?: CustomerDeviceWhereUniqueInput
    update?: XOR<XOR<CustomerDeviceUpdateToOneWithWhereWithoutServicesInput, CustomerDeviceUpdateWithoutServicesInput>, CustomerDeviceUncheckedUpdateWithoutServicesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumCustomerSegmentFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentFilter<$PrismaModel> | $Enums.CustomerSegment
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerSegment | EnumCustomerSegmentFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerSegment[] | ListEnumCustomerSegmentFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerSegmentWithAggregatesFilter<$PrismaModel> | $Enums.CustomerSegment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerSegmentFilter<$PrismaModel>
    _max?: NestedEnumCustomerSegmentFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelFilter<$PrismaModel> | $Enums.CommunicationChannel
  }

  export type NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationChannel | EnumCommunicationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationChannel[] | ListEnumCommunicationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationChannelWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationChannelFilter<$PrismaModel>
    _max?: NestedEnumCommunicationChannelFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeviceStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceStatusNullableFilter<$PrismaModel> | $Enums.DeviceStatus | null
    isSet?: boolean
  }

  export type NestedEnumDeviceStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDeviceStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ProductVariantCreateWithoutProductInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    sku?: StringFilter<"ProductVariant"> | string
    name?: StringFilter<"ProductVariant"> | string
    description?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    design?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    costPrice?: FloatFilter<"ProductVariant"> | number
    salePrice?: FloatFilter<"ProductVariant"> | number
    promoPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    percentPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    stock?: IntFilter<"ProductVariant"> | number
    minStock?: IntFilter<"ProductVariant"> | number
    images?: StringNullableListFilter<"ProductVariant">
    specifications?: JsonNullableFilter<"ProductVariant">
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock?: number
    images?: ProductCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    hasVariants?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description: string
    category: string
    brand: string
    provider: string
    costPrice: number
    salePrice: number
    promoPrice: number
    percentPrice: number
    stock: number
    minStock?: number
    images?: ProductCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    hasVariants?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: FloatFieldUpdateOperationsInput | number
    percentPrice?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    hasVariants?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationPreferencesCreateWithoutBuyerInput = {
    id?: string
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: $Enums.CommunicationChannel
    best_contact_time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationPreferencesUncheckedCreateWithoutBuyerInput = {
    id?: string
    email_marketing?: boolean
    email_transaccional?: boolean
    sms_marketing?: boolean
    sms_transaccional?: boolean
    whatsapp_marketing?: boolean
    whatsapp_transaccional?: boolean
    llamadas_comerciales?: boolean
    preferred_channel?: $Enums.CommunicationChannel
    best_contact_time?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationPreferencesCreateOrConnectWithoutBuyerInput = {
    where: CommunicationPreferencesWhereUniqueInput
    create: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
  }

  export type OrderCreateWithoutBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
    detalles?: OrderDetailCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
    detalles?: OrderDetailUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput>
  }

  export type OrderCreateManyBuyerInputEnvelope = {
    data: OrderCreateManyBuyerInput | OrderCreateManyBuyerInput[]
  }

  export type POSSaleCreateWithoutBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
    detalles?: POSSaleDetailCreateNestedManyWithoutPosSaleInput
  }

  export type POSSaleUncheckedCreateWithoutBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
    detalles?: POSSaleDetailUncheckedCreateNestedManyWithoutPosSaleInput
  }

  export type POSSaleCreateOrConnectWithoutBuyerInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput>
  }

  export type POSSaleCreateManyBuyerInputEnvelope = {
    data: POSSaleCreateManyBuyerInput | POSSaleCreateManyBuyerInput[]
  }

  export type CustomerDeviceCreateWithoutBuyerInput = {
    id?: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCustomerDeviceInput
  }

  export type CustomerDeviceUncheckedCreateWithoutBuyerInput = {
    id?: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCustomerDeviceInput
  }

  export type CustomerDeviceCreateOrConnectWithoutBuyerInput = {
    where: CustomerDeviceWhereUniqueInput
    create: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput>
  }

  export type CustomerDeviceCreateManyBuyerInputEnvelope = {
    data: CustomerDeviceCreateManyBuyerInput | CustomerDeviceCreateManyBuyerInput[]
  }

  export type ProductInteractionCreateWithoutBuyerInput = {
    id?: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
  }

  export type ProductInteractionUncheckedCreateWithoutBuyerInput = {
    id?: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
  }

  export type ProductInteractionCreateOrConnectWithoutBuyerInput = {
    where: ProductInteractionWhereUniqueInput
    create: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput>
  }

  export type ProductInteractionCreateManyBuyerInputEnvelope = {
    data: ProductInteractionCreateManyBuyerInput | ProductInteractionCreateManyBuyerInput[]
  }

  export type BrowsingEventCreateWithoutBuyerInput = {
    id?: string
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
  }

  export type BrowsingEventUncheckedCreateWithoutBuyerInput = {
    id?: string
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
  }

  export type BrowsingEventCreateOrConnectWithoutBuyerInput = {
    where: BrowsingEventWhereUniqueInput
    create: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput>
  }

  export type BrowsingEventCreateManyBuyerInputEnvelope = {
    data: BrowsingEventCreateManyBuyerInput | BrowsingEventCreateManyBuyerInput[]
  }

  export type FeedbackCreateWithoutBuyerInput = {
    id?: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutBuyerInput = {
    id?: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutBuyerInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput>
  }

  export type FeedbackCreateManyBuyerInputEnvelope = {
    data: FeedbackCreateManyBuyerInput | FeedbackCreateManyBuyerInput[]
  }

  export type ServiceCreateWithoutBuyerInput = {
    id?: string
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
    customerDevice?: CustomerDeviceCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutBuyerInput = {
    id?: string
    customerDeviceId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type ServiceCreateOrConnectWithoutBuyerInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput>
  }

  export type ServiceCreateManyBuyerInputEnvelope = {
    data: ServiceCreateManyBuyerInput | ServiceCreateManyBuyerInput[]
  }

  export type CommunicationPreferencesUpsertWithoutBuyerInput = {
    update: XOR<CommunicationPreferencesUpdateWithoutBuyerInput, CommunicationPreferencesUncheckedUpdateWithoutBuyerInput>
    create: XOR<CommunicationPreferencesCreateWithoutBuyerInput, CommunicationPreferencesUncheckedCreateWithoutBuyerInput>
    where?: CommunicationPreferencesWhereInput
  }

  export type CommunicationPreferencesUpdateToOneWithWhereWithoutBuyerInput = {
    where?: CommunicationPreferencesWhereInput
    data: XOR<CommunicationPreferencesUpdateWithoutBuyerInput, CommunicationPreferencesUncheckedUpdateWithoutBuyerInput>
  }

  export type CommunicationPreferencesUpdateWithoutBuyerInput = {
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationPreferencesUncheckedUpdateWithoutBuyerInput = {
    email_marketing?: BoolFieldUpdateOperationsInput | boolean
    email_transaccional?: BoolFieldUpdateOperationsInput | boolean
    sms_marketing?: BoolFieldUpdateOperationsInput | boolean
    sms_transaccional?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_marketing?: BoolFieldUpdateOperationsInput | boolean
    whatsapp_transaccional?: BoolFieldUpdateOperationsInput | boolean
    llamadas_comerciales?: BoolFieldUpdateOperationsInput | boolean
    preferred_channel?: EnumCommunicationChannelFieldUpdateOperationsInput | $Enums.CommunicationChannel
    best_contact_time?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBuyerInput, OrderUncheckedUpdateWithoutBuyerInput>
    create: XOR<OrderCreateWithoutBuyerInput, OrderUncheckedCreateWithoutBuyerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBuyerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBuyerInput, OrderUncheckedUpdateWithoutBuyerInput>
  }

  export type OrderUpdateManyWithWhereWithoutBuyerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutBuyerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    buyerId?: StringFilter<"Order"> | string
    fecha_creacion?: DateTimeFilter<"Order"> | Date | string
    monto_total?: IntFilter<"Order"> | number
    estado?: StringFilter<"Order"> | string
    metodo_pago?: StringFilter<"Order"> | string
    info_envio?: JsonNullableFilter<"Order">
    id_transaccion_pasarela?: StringNullableFilter<"Order"> | string | null
  }

  export type POSSaleUpsertWithWhereUniqueWithoutBuyerInput = {
    where: POSSaleWhereUniqueInput
    update: XOR<POSSaleUpdateWithoutBuyerInput, POSSaleUncheckedUpdateWithoutBuyerInput>
    create: XOR<POSSaleCreateWithoutBuyerInput, POSSaleUncheckedCreateWithoutBuyerInput>
  }

  export type POSSaleUpdateWithWhereUniqueWithoutBuyerInput = {
    where: POSSaleWhereUniqueInput
    data: XOR<POSSaleUpdateWithoutBuyerInput, POSSaleUncheckedUpdateWithoutBuyerInput>
  }

  export type POSSaleUpdateManyWithWhereWithoutBuyerInput = {
    where: POSSaleScalarWhereInput
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyWithoutBuyerInput>
  }

  export type POSSaleScalarWhereInput = {
    AND?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
    OR?: POSSaleScalarWhereInput[]
    NOT?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
    id?: StringFilter<"POSSale"> | string
    buyerId?: StringFilter<"POSSale"> | string
    fecha_creacion?: DateTimeFilter<"POSSale"> | Date | string
    monto_total?: IntFilter<"POSSale"> | number
    estado?: StringFilter<"POSSale"> | string
    metodo_pago?: JsonNullableFilter<"POSSale">
  }

  export type CustomerDeviceUpsertWithWhereUniqueWithoutBuyerInput = {
    where: CustomerDeviceWhereUniqueInput
    update: XOR<CustomerDeviceUpdateWithoutBuyerInput, CustomerDeviceUncheckedUpdateWithoutBuyerInput>
    create: XOR<CustomerDeviceCreateWithoutBuyerInput, CustomerDeviceUncheckedCreateWithoutBuyerInput>
  }

  export type CustomerDeviceUpdateWithWhereUniqueWithoutBuyerInput = {
    where: CustomerDeviceWhereUniqueInput
    data: XOR<CustomerDeviceUpdateWithoutBuyerInput, CustomerDeviceUncheckedUpdateWithoutBuyerInput>
  }

  export type CustomerDeviceUpdateManyWithWhereWithoutBuyerInput = {
    where: CustomerDeviceScalarWhereInput
    data: XOR<CustomerDeviceUpdateManyMutationInput, CustomerDeviceUncheckedUpdateManyWithoutBuyerInput>
  }

  export type CustomerDeviceScalarWhereInput = {
    AND?: CustomerDeviceScalarWhereInput | CustomerDeviceScalarWhereInput[]
    OR?: CustomerDeviceScalarWhereInput[]
    NOT?: CustomerDeviceScalarWhereInput | CustomerDeviceScalarWhereInput[]
    id?: StringFilter<"CustomerDevice"> | string
    buyerId?: StringFilter<"CustomerDevice"> | string
    marca?: StringFilter<"CustomerDevice"> | string
    modelo?: StringFilter<"CustomerDevice"> | string
    numero_serie?: StringNullableFilter<"CustomerDevice"> | string | null
    imei?: StringNullableFilter<"CustomerDevice"> | string | null
    color?: StringNullableFilter<"CustomerDevice"> | string | null
    capacidad?: StringNullableFilter<"CustomerDevice"> | string | null
    fecha_compra?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    lugar_compra?: StringNullableFilter<"CustomerDevice"> | string | null
    precio_compra?: FloatNullableFilter<"CustomerDevice"> | number | null
    tiene_garantia?: BoolFilter<"CustomerDevice"> | boolean
    garantia_hasta?: DateTimeNullableFilter<"CustomerDevice"> | Date | string | null
    is_active?: BoolFilter<"CustomerDevice"> | boolean
    createdAt?: DateTimeFilter<"CustomerDevice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerDevice"> | Date | string
  }

  export type ProductInteractionUpsertWithWhereUniqueWithoutBuyerInput = {
    where: ProductInteractionWhereUniqueInput
    update: XOR<ProductInteractionUpdateWithoutBuyerInput, ProductInteractionUncheckedUpdateWithoutBuyerInput>
    create: XOR<ProductInteractionCreateWithoutBuyerInput, ProductInteractionUncheckedCreateWithoutBuyerInput>
  }

  export type ProductInteractionUpdateWithWhereUniqueWithoutBuyerInput = {
    where: ProductInteractionWhereUniqueInput
    data: XOR<ProductInteractionUpdateWithoutBuyerInput, ProductInteractionUncheckedUpdateWithoutBuyerInput>
  }

  export type ProductInteractionUpdateManyWithWhereWithoutBuyerInput = {
    where: ProductInteractionScalarWhereInput
    data: XOR<ProductInteractionUpdateManyMutationInput, ProductInteractionUncheckedUpdateManyWithoutBuyerInput>
  }

  export type ProductInteractionScalarWhereInput = {
    AND?: ProductInteractionScalarWhereInput | ProductInteractionScalarWhereInput[]
    OR?: ProductInteractionScalarWhereInput[]
    NOT?: ProductInteractionScalarWhereInput | ProductInteractionScalarWhereInput[]
    id?: StringFilter<"ProductInteraction"> | string
    buyerId?: StringFilter<"ProductInteraction"> | string
    productoId?: StringFilter<"ProductInteraction"> | string
    productoName?: StringFilter<"ProductInteraction"> | string
    tipo?: EnumInteractionTypeFilter<"ProductInteraction"> | $Enums.InteractionType
    session_id?: StringNullableFilter<"ProductInteraction"> | string | null
    user_agent?: StringNullableFilter<"ProductInteraction"> | string | null
    ip_address?: StringNullableFilter<"ProductInteraction"> | string | null
    referrer?: StringNullableFilter<"ProductInteraction"> | string | null
    quantity?: IntNullableFilter<"ProductInteraction"> | number | null
    price_at_interaction?: FloatNullableFilter<"ProductInteraction"> | number | null
    createdAt?: DateTimeFilter<"ProductInteraction"> | Date | string
  }

  export type BrowsingEventUpsertWithWhereUniqueWithoutBuyerInput = {
    where: BrowsingEventWhereUniqueInput
    update: XOR<BrowsingEventUpdateWithoutBuyerInput, BrowsingEventUncheckedUpdateWithoutBuyerInput>
    create: XOR<BrowsingEventCreateWithoutBuyerInput, BrowsingEventUncheckedCreateWithoutBuyerInput>
  }

  export type BrowsingEventUpdateWithWhereUniqueWithoutBuyerInput = {
    where: BrowsingEventWhereUniqueInput
    data: XOR<BrowsingEventUpdateWithoutBuyerInput, BrowsingEventUncheckedUpdateWithoutBuyerInput>
  }

  export type BrowsingEventUpdateManyWithWhereWithoutBuyerInput = {
    where: BrowsingEventScalarWhereInput
    data: XOR<BrowsingEventUpdateManyMutationInput, BrowsingEventUncheckedUpdateManyWithoutBuyerInput>
  }

  export type BrowsingEventScalarWhereInput = {
    AND?: BrowsingEventScalarWhereInput | BrowsingEventScalarWhereInput[]
    OR?: BrowsingEventScalarWhereInput[]
    NOT?: BrowsingEventScalarWhereInput | BrowsingEventScalarWhereInput[]
    id?: StringFilter<"BrowsingEvent"> | string
    buyerId?: StringNullableFilter<"BrowsingEvent"> | string | null
    session_id?: StringFilter<"BrowsingEvent"> | string
    page_url?: StringFilter<"BrowsingEvent"> | string
    page_title?: StringNullableFilter<"BrowsingEvent"> | string | null
    time_spent?: IntNullableFilter<"BrowsingEvent"> | number | null
    user_agent?: StringNullableFilter<"BrowsingEvent"> | string | null
    ip_address?: StringNullableFilter<"BrowsingEvent"> | string | null
    referrer?: StringNullableFilter<"BrowsingEvent"> | string | null
    device_type?: StringNullableFilter<"BrowsingEvent"> | string | null
    createdAt?: DateTimeFilter<"BrowsingEvent"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutBuyerInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutBuyerInput, FeedbackUncheckedUpdateWithoutBuyerInput>
    create: XOR<FeedbackCreateWithoutBuyerInput, FeedbackUncheckedCreateWithoutBuyerInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutBuyerInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutBuyerInput, FeedbackUncheckedUpdateWithoutBuyerInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutBuyerInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutBuyerInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    buyerId?: StringFilter<"Feedback"> | string
    tipo?: EnumFeedbackTypeFilter<"Feedback"> | $Enums.FeedbackType
    rating?: IntNullableFilter<"Feedback"> | number | null
    comentario?: StringNullableFilter<"Feedback"> | string | null
    related_order_id?: StringNullableFilter<"Feedback"> | string | null
    related_service_id?: StringNullableFilter<"Feedback"> | string | null
    related_product_id?: StringNullableFilter<"Feedback"> | string | null
    respuesta?: StringNullableFilter<"Feedback"> | string | null
    respondido_por?: StringNullableFilter<"Feedback"> | string | null
    fecha_respuesta?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutBuyerInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutBuyerInput, ServiceUncheckedUpdateWithoutBuyerInput>
    create: XOR<ServiceCreateWithoutBuyerInput, ServiceUncheckedCreateWithoutBuyerInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutBuyerInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutBuyerInput, ServiceUncheckedUpdateWithoutBuyerInput>
  }

  export type ServiceUpdateManyWithWhereWithoutBuyerInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutBuyerInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    buyerId?: StringNullableFilter<"Service"> | string | null
    customerDeviceId?: StringNullableFilter<"Service"> | string | null
    device?: JsonFilter<"Service">
    client?: JsonFilter<"Service">
    state?: StringFilter<"Service"> | string
    diagnostico?: StringNullableFilter<"Service"> | string | null
    estado_dispositivo_al_ingresar?: EnumDeviceStatusNullableFilter<"Service"> | $Enums.DeviceStatus | null
    observaciones?: StringNullableFilter<"Service"> | string | null
    repair?: StringFilter<"Service"> | string
    piezas?: JsonNullableFilter<"Service">
    total?: FloatFilter<"Service"> | number
    discount?: FloatNullableFilter<"Service"> | number | null
    date?: DateTimeFilter<"Service"> | Date | string
    dateOut?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_presupuesto?: DateTimeNullableFilter<"Service"> | Date | string | null
    fecha_aprobacion?: DateTimeNullableFilter<"Service"> | Date | string | null
    garantia_hasta?: DateTimeNullableFilter<"Service"> | Date | string | null
    observaciones_garantia?: StringNullableFilter<"Service"> | string | null
    payments?: JsonNullableFilter<"Service">
  }

  export type BuyerCreateWithoutCommunication_preferencesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutCommunication_preferencesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutCommunication_preferencesInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutCommunication_preferencesInput, BuyerUncheckedCreateWithoutCommunication_preferencesInput>
  }

  export type BuyerUpsertWithoutCommunication_preferencesInput = {
    update: XOR<BuyerUpdateWithoutCommunication_preferencesInput, BuyerUncheckedUpdateWithoutCommunication_preferencesInput>
    create: XOR<BuyerCreateWithoutCommunication_preferencesInput, BuyerUncheckedCreateWithoutCommunication_preferencesInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutCommunication_preferencesInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutCommunication_preferencesInput, BuyerUncheckedUpdateWithoutCommunication_preferencesInput>
  }

  export type BuyerUpdateWithoutCommunication_preferencesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutCommunication_preferencesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerCreateWithoutDevicesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutDevicesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutDevicesInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutDevicesInput, BuyerUncheckedCreateWithoutDevicesInput>
  }

  export type ServiceCreateWithoutCustomerDeviceInput = {
    id?: string
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
    buyer?: BuyerCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutCustomerDeviceInput = {
    id?: string
    buyerId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type ServiceCreateOrConnectWithoutCustomerDeviceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput>
  }

  export type ServiceCreateManyCustomerDeviceInputEnvelope = {
    data: ServiceCreateManyCustomerDeviceInput | ServiceCreateManyCustomerDeviceInput[]
  }

  export type BuyerUpsertWithoutDevicesInput = {
    update: XOR<BuyerUpdateWithoutDevicesInput, BuyerUncheckedUpdateWithoutDevicesInput>
    create: XOR<BuyerCreateWithoutDevicesInput, BuyerUncheckedCreateWithoutDevicesInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutDevicesInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutDevicesInput, BuyerUncheckedUpdateWithoutDevicesInput>
  }

  export type BuyerUpdateWithoutDevicesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutDevicesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type ServiceUpsertWithWhereUniqueWithoutCustomerDeviceInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCustomerDeviceInput, ServiceUncheckedUpdateWithoutCustomerDeviceInput>
    create: XOR<ServiceCreateWithoutCustomerDeviceInput, ServiceUncheckedCreateWithoutCustomerDeviceInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCustomerDeviceInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCustomerDeviceInput, ServiceUncheckedUpdateWithoutCustomerDeviceInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCustomerDeviceInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCustomerDeviceInput>
  }

  export type BuyerCreateWithoutInteractionsInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutInteractionsInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutInteractionsInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutInteractionsInput, BuyerUncheckedCreateWithoutInteractionsInput>
  }

  export type BuyerUpsertWithoutInteractionsInput = {
    update: XOR<BuyerUpdateWithoutInteractionsInput, BuyerUncheckedUpdateWithoutInteractionsInput>
    create: XOR<BuyerCreateWithoutInteractionsInput, BuyerUncheckedCreateWithoutInteractionsInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutInteractionsInput, BuyerUncheckedUpdateWithoutInteractionsInput>
  }

  export type BuyerUpdateWithoutInteractionsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutInteractionsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerCreateWithoutBrowsingEventsInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutBrowsingEventsInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutBrowsingEventsInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutBrowsingEventsInput, BuyerUncheckedCreateWithoutBrowsingEventsInput>
  }

  export type BuyerUpsertWithoutBrowsingEventsInput = {
    update: XOR<BuyerUpdateWithoutBrowsingEventsInput, BuyerUncheckedUpdateWithoutBrowsingEventsInput>
    create: XOR<BuyerCreateWithoutBrowsingEventsInput, BuyerUncheckedCreateWithoutBrowsingEventsInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutBrowsingEventsInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutBrowsingEventsInput, BuyerUncheckedUpdateWithoutBrowsingEventsInput>
  }

  export type BuyerUpdateWithoutBrowsingEventsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutBrowsingEventsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerCreateWithoutFeedbackInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutFeedbackInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutFeedbackInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutFeedbackInput, BuyerUncheckedCreateWithoutFeedbackInput>
  }

  export type BuyerUpsertWithoutFeedbackInput = {
    update: XOR<BuyerUpdateWithoutFeedbackInput, BuyerUncheckedUpdateWithoutFeedbackInput>
    create: XOR<BuyerCreateWithoutFeedbackInput, BuyerUncheckedCreateWithoutFeedbackInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutFeedbackInput, BuyerUncheckedUpdateWithoutFeedbackInput>
  }

  export type BuyerUpdateWithoutFeedbackInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutFeedbackInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerCreateWithoutOrdersInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutOrdersInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutOrdersInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutOrdersInput, BuyerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderDetailCreateWithoutOrderInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type OrderDetailUncheckedCreateWithoutOrderInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type OrderDetailCreateOrConnectWithoutOrderInput = {
    where: OrderDetailWhereUniqueInput
    create: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput>
  }

  export type OrderDetailCreateManyOrderInputEnvelope = {
    data: OrderDetailCreateManyOrderInput | OrderDetailCreateManyOrderInput[]
  }

  export type BuyerUpsertWithoutOrdersInput = {
    update: XOR<BuyerUpdateWithoutOrdersInput, BuyerUncheckedUpdateWithoutOrdersInput>
    create: XOR<BuyerCreateWithoutOrdersInput, BuyerUncheckedCreateWithoutOrdersInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutOrdersInput, BuyerUncheckedUpdateWithoutOrdersInput>
  }

  export type BuyerUpdateWithoutOrdersInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutOrdersInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type OrderDetailUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderDetailWhereUniqueInput
    update: XOR<OrderDetailUpdateWithoutOrderInput, OrderDetailUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderDetailCreateWithoutOrderInput, OrderDetailUncheckedCreateWithoutOrderInput>
  }

  export type OrderDetailUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderDetailWhereUniqueInput
    data: XOR<OrderDetailUpdateWithoutOrderInput, OrderDetailUncheckedUpdateWithoutOrderInput>
  }

  export type OrderDetailUpdateManyWithWhereWithoutOrderInput = {
    where: OrderDetailScalarWhereInput
    data: XOR<OrderDetailUpdateManyMutationInput, OrderDetailUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderDetailScalarWhereInput = {
    AND?: OrderDetailScalarWhereInput | OrderDetailScalarWhereInput[]
    OR?: OrderDetailScalarWhereInput[]
    NOT?: OrderDetailScalarWhereInput | OrderDetailScalarWhereInput[]
    id?: StringFilter<"OrderDetail"> | string
    orderId?: StringFilter<"OrderDetail"> | string
    productoId?: StringFilter<"OrderDetail"> | string
    productoName?: StringFilter<"OrderDetail"> | string
    cantidad?: IntFilter<"OrderDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"OrderDetail"> | number
  }

  export type OrderCreateWithoutDetallesInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
    buyer: BuyerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutDetallesInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
  }

  export type OrderCreateOrConnectWithoutDetallesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDetallesInput, OrderUncheckedCreateWithoutDetallesInput>
  }

  export type OrderUpsertWithoutDetallesInput = {
    update: XOR<OrderUpdateWithoutDetallesInput, OrderUncheckedUpdateWithoutDetallesInput>
    create: XOR<OrderCreateWithoutDetallesInput, OrderUncheckedCreateWithoutDetallesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDetallesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDetallesInput, OrderUncheckedUpdateWithoutDetallesInput>
  }

  export type OrderUpdateWithoutDetallesInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
    buyer?: BuyerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutDetallesInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuyerCreateWithoutPosSalesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
    services?: ServiceCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutPosSalesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
    services?: ServiceUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutPosSalesInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutPosSalesInput, BuyerUncheckedCreateWithoutPosSalesInput>
  }

  export type POSSaleDetailCreateWithoutPosSaleInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type POSSaleDetailUncheckedCreateWithoutPosSaleInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type POSSaleDetailCreateOrConnectWithoutPosSaleInput = {
    where: POSSaleDetailWhereUniqueInput
    create: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput>
  }

  export type POSSaleDetailCreateManyPosSaleInputEnvelope = {
    data: POSSaleDetailCreateManyPosSaleInput | POSSaleDetailCreateManyPosSaleInput[]
  }

  export type BuyerUpsertWithoutPosSalesInput = {
    update: XOR<BuyerUpdateWithoutPosSalesInput, BuyerUncheckedUpdateWithoutPosSalesInput>
    create: XOR<BuyerCreateWithoutPosSalesInput, BuyerUncheckedCreateWithoutPosSalesInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutPosSalesInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutPosSalesInput, BuyerUncheckedUpdateWithoutPosSalesInput>
  }

  export type BuyerUpdateWithoutPosSalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
    services?: ServiceUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutPosSalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
    services?: ServiceUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type POSSaleDetailUpsertWithWhereUniqueWithoutPosSaleInput = {
    where: POSSaleDetailWhereUniqueInput
    update: XOR<POSSaleDetailUpdateWithoutPosSaleInput, POSSaleDetailUncheckedUpdateWithoutPosSaleInput>
    create: XOR<POSSaleDetailCreateWithoutPosSaleInput, POSSaleDetailUncheckedCreateWithoutPosSaleInput>
  }

  export type POSSaleDetailUpdateWithWhereUniqueWithoutPosSaleInput = {
    where: POSSaleDetailWhereUniqueInput
    data: XOR<POSSaleDetailUpdateWithoutPosSaleInput, POSSaleDetailUncheckedUpdateWithoutPosSaleInput>
  }

  export type POSSaleDetailUpdateManyWithWhereWithoutPosSaleInput = {
    where: POSSaleDetailScalarWhereInput
    data: XOR<POSSaleDetailUpdateManyMutationInput, POSSaleDetailUncheckedUpdateManyWithoutPosSaleInput>
  }

  export type POSSaleDetailScalarWhereInput = {
    AND?: POSSaleDetailScalarWhereInput | POSSaleDetailScalarWhereInput[]
    OR?: POSSaleDetailScalarWhereInput[]
    NOT?: POSSaleDetailScalarWhereInput | POSSaleDetailScalarWhereInput[]
    id?: StringFilter<"POSSaleDetail"> | string
    posSaleId?: StringFilter<"POSSaleDetail"> | string
    productoId?: StringFilter<"POSSaleDetail"> | string
    productoName?: StringFilter<"POSSaleDetail"> | string
    cantidad?: IntFilter<"POSSaleDetail"> | number
    precio_unitario_al_momento_de_compra?: IntFilter<"POSSaleDetail"> | number
  }

  export type POSSaleCreateWithoutDetallesInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
    buyer: BuyerCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutDetallesInput = {
    id?: string
    buyerId: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
  }

  export type POSSaleCreateOrConnectWithoutDetallesInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutDetallesInput, POSSaleUncheckedCreateWithoutDetallesInput>
  }

  export type POSSaleUpsertWithoutDetallesInput = {
    update: XOR<POSSaleUpdateWithoutDetallesInput, POSSaleUncheckedUpdateWithoutDetallesInput>
    create: XOR<POSSaleCreateWithoutDetallesInput, POSSaleUncheckedCreateWithoutDetallesInput>
    where?: POSSaleWhereInput
  }

  export type POSSaleUpdateToOneWithWhereWithoutDetallesInput = {
    where?: POSSaleWhereInput
    data: XOR<POSSaleUpdateWithoutDetallesInput, POSSaleUncheckedUpdateWithoutDetallesInput>
  }

  export type POSSaleUpdateWithoutDetallesInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
    buyer?: BuyerUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutDetallesInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
  }

  export type BuyerCreateWithoutServicesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesCreateNestedOneWithoutBuyerInput
    orders?: OrderCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackCreateNestedManyWithoutBuyerInput
  }

  export type BuyerUncheckedCreateWithoutServicesInput = {
    id?: string
    nombre: string
    apellido?: string | null
    email: string
    dni?: string | null
    cuit?: string | null
    telefono?: string | null
    whatsapp?: string | null
    fecha_nacimiento?: Date | string | null
    direccion: string
    acquisition_channel?: string | null
    utm_source?: string | null
    utm_medium?: string | null
    utm_campaign?: string | null
    utm_content?: string | null
    utm_term?: string | null
    segment?: $Enums.CustomerSegment
    tags?: BuyerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    last_interaction?: Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedCreateNestedOneWithoutBuyerInput
    orders?: OrderUncheckedCreateNestedManyWithoutBuyerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutBuyerInput
    devices?: CustomerDeviceUncheckedCreateNestedManyWithoutBuyerInput
    interactions?: ProductInteractionUncheckedCreateNestedManyWithoutBuyerInput
    browsingEvents?: BrowsingEventUncheckedCreateNestedManyWithoutBuyerInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutBuyerInput
  }

  export type BuyerCreateOrConnectWithoutServicesInput = {
    where: BuyerWhereUniqueInput
    create: XOR<BuyerCreateWithoutServicesInput, BuyerUncheckedCreateWithoutServicesInput>
  }

  export type CustomerDeviceCreateWithoutServicesInput = {
    id?: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: BuyerCreateNestedOneWithoutDevicesInput
  }

  export type CustomerDeviceUncheckedCreateWithoutServicesInput = {
    id?: string
    buyerId: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerDeviceCreateOrConnectWithoutServicesInput = {
    where: CustomerDeviceWhereUniqueInput
    create: XOR<CustomerDeviceCreateWithoutServicesInput, CustomerDeviceUncheckedCreateWithoutServicesInput>
  }

  export type BuyerUpsertWithoutServicesInput = {
    update: XOR<BuyerUpdateWithoutServicesInput, BuyerUncheckedUpdateWithoutServicesInput>
    create: XOR<BuyerCreateWithoutServicesInput, BuyerUncheckedCreateWithoutServicesInput>
    where?: BuyerWhereInput
  }

  export type BuyerUpdateToOneWithWhereWithoutServicesInput = {
    where?: BuyerWhereInput
    data: XOR<BuyerUpdateWithoutServicesInput, BuyerUncheckedUpdateWithoutServicesInput>
  }

  export type BuyerUpdateWithoutServicesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUpdateOneWithoutBuyerNestedInput
    orders?: OrderUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUpdateManyWithoutBuyerNestedInput
  }

  export type BuyerUncheckedUpdateWithoutServicesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    dni?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    direccion?: StringFieldUpdateOperationsInput | string
    acquisition_channel?: NullableStringFieldUpdateOperationsInput | string | null
    utm_source?: NullableStringFieldUpdateOperationsInput | string | null
    utm_medium?: NullableStringFieldUpdateOperationsInput | string | null
    utm_campaign?: NullableStringFieldUpdateOperationsInput | string | null
    utm_content?: NullableStringFieldUpdateOperationsInput | string | null
    utm_term?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: EnumCustomerSegmentFieldUpdateOperationsInput | $Enums.CustomerSegment
    tags?: BuyerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    last_interaction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    communication_preferences?: CommunicationPreferencesUncheckedUpdateOneWithoutBuyerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutBuyerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutBuyerNestedInput
    devices?: CustomerDeviceUncheckedUpdateManyWithoutBuyerNestedInput
    interactions?: ProductInteractionUncheckedUpdateManyWithoutBuyerNestedInput
    browsingEvents?: BrowsingEventUncheckedUpdateManyWithoutBuyerNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutBuyerNestedInput
  }

  export type CustomerDeviceUpsertWithoutServicesInput = {
    update: XOR<CustomerDeviceUpdateWithoutServicesInput, CustomerDeviceUncheckedUpdateWithoutServicesInput>
    create: XOR<CustomerDeviceCreateWithoutServicesInput, CustomerDeviceUncheckedCreateWithoutServicesInput>
    where?: CustomerDeviceWhereInput
  }

  export type CustomerDeviceUpdateToOneWithWhereWithoutServicesInput = {
    where?: CustomerDeviceWhereInput
    data: XOR<CustomerDeviceUpdateWithoutServicesInput, CustomerDeviceUncheckedUpdateWithoutServicesInput>
  }

  export type CustomerDeviceUpdateWithoutServicesInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: BuyerUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type CustomerDeviceUncheckedUpdateWithoutServicesInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id?: string
    barcode?: string | null
    sku: string
    name: string
    description?: string | null
    color?: string | null
    design?: string | null
    size?: string | null
    material?: string | null
    costPrice: number
    salePrice: number
    promoPrice?: number | null
    percentPrice?: number | null
    stock: number
    minStock?: number
    images?: ProductVariantCreateimagesInput | string[]
    specifications?: InputJsonValue | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    design?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    salePrice?: FloatFieldUpdateOperationsInput | number
    promoPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    percentPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    images?: ProductVariantUpdateimagesInput | string[]
    specifications?: InputJsonValue | InputJsonValue | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago: string
    info_envio?: InputJsonValue | null
    id_transaccion_pasarela?: string | null
  }

  export type POSSaleCreateManyBuyerInput = {
    id?: string
    fecha_creacion?: Date | string
    monto_total: number
    estado: string
    metodo_pago?: InputJsonValue | null
  }

  export type CustomerDeviceCreateManyBuyerInput = {
    id?: string
    marca: string
    modelo: string
    numero_serie?: string | null
    imei?: string | null
    color?: string | null
    capacidad?: string | null
    fecha_compra?: Date | string | null
    lugar_compra?: string | null
    precio_compra?: number | null
    tiene_garantia?: boolean
    garantia_hasta?: Date | string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductInteractionCreateManyBuyerInput = {
    id?: string
    productoId: string
    productoName: string
    tipo: $Enums.InteractionType
    session_id?: string | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    quantity?: number | null
    price_at_interaction?: number | null
    createdAt?: Date | string
  }

  export type BrowsingEventCreateManyBuyerInput = {
    id?: string
    session_id: string
    page_url: string
    page_title?: string | null
    time_spent?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referrer?: string | null
    device_type?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateManyBuyerInput = {
    id?: string
    tipo: $Enums.FeedbackType
    rating?: number | null
    comentario?: string | null
    related_order_id?: string | null
    related_service_id?: string | null
    related_product_id?: string | null
    respuesta?: string | null
    respondido_por?: string | null
    fecha_respuesta?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateManyBuyerInput = {
    id?: string
    customerDeviceId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type OrderUpdateWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: OrderDetailUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: OrderDetailUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    info_envio?: InputJsonValue | InputJsonValue | null
    id_transaccion_pasarela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type POSSaleUpdateWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
    detalles?: POSSaleDetailUpdateManyWithoutPosSaleNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
    detalles?: POSSaleDetailUncheckedUpdateManyWithoutPosSaleNestedInput
  }

  export type POSSaleUncheckedUpdateManyWithoutBuyerInput = {
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    monto_total?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    metodo_pago?: InputJsonValue | InputJsonValue | null
  }

  export type CustomerDeviceUpdateWithoutBuyerInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCustomerDeviceNestedInput
  }

  export type CustomerDeviceUncheckedUpdateWithoutBuyerInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCustomerDeviceNestedInput
  }

  export type CustomerDeviceUncheckedUpdateManyWithoutBuyerInput = {
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    numero_serie?: NullableStringFieldUpdateOperationsInput | string | null
    imei?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    capacidad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_compra?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_compra?: NullableStringFieldUpdateOperationsInput | string | null
    precio_compra?: NullableFloatFieldUpdateOperationsInput | number | null
    tiene_garantia?: BoolFieldUpdateOperationsInput | boolean
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionUpdateWithoutBuyerInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionUncheckedUpdateWithoutBuyerInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInteractionUncheckedUpdateManyWithoutBuyerInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    tipo?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price_at_interaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventUpdateWithoutBuyerInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventUncheckedUpdateWithoutBuyerInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrowsingEventUncheckedUpdateManyWithoutBuyerInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    page_url?: StringFieldUpdateOperationsInput | string
    page_title?: NullableStringFieldUpdateOperationsInput | string | null
    time_spent?: NullableIntFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    device_type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutBuyerInput = {
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutBuyerInput = {
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutBuyerInput = {
    tipo?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    related_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_service_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_product_id?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    respondido_por?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_respuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutBuyerInput = {
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
    customerDevice?: CustomerDeviceUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBuyerInput = {
    customerDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ServiceUncheckedUpdateManyWithoutBuyerInput = {
    customerDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ServiceCreateManyCustomerDeviceInput = {
    id?: string
    buyerId?: string | null
    device: InputJsonValue
    client: InputJsonValue
    state: string
    diagnostico?: string | null
    estado_dispositivo_al_ingresar?: $Enums.DeviceStatus | null
    observaciones?: string | null
    repair: string
    piezas?: InputJsonValue | null
    total: number
    discount?: number | null
    date: Date | string
    dateOut?: Date | string | null
    fecha_presupuesto?: Date | string | null
    fecha_aprobacion?: Date | string | null
    garantia_hasta?: Date | string | null
    observaciones_garantia?: string | null
    payments?: InputJsonValue | null
  }

  export type ServiceUpdateWithoutCustomerDeviceInput = {
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
    buyer?: BuyerUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCustomerDeviceInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type ServiceUncheckedUpdateManyWithoutCustomerDeviceInput = {
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    device?: InputJsonValue | InputJsonValue
    client?: InputJsonValue | InputJsonValue
    state?: StringFieldUpdateOperationsInput | string
    diagnostico?: NullableStringFieldUpdateOperationsInput | string | null
    estado_dispositivo_al_ingresar?: NullableEnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    repair?: StringFieldUpdateOperationsInput | string
    piezas?: InputJsonValue | InputJsonValue | null
    total?: FloatFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_presupuesto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    garantia_hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones_garantia?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: InputJsonValue | InputJsonValue | null
  }

  export type OrderDetailCreateManyOrderInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type OrderDetailUpdateWithoutOrderInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type OrderDetailUncheckedUpdateWithoutOrderInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type OrderDetailUncheckedUpdateManyWithoutOrderInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleDetailCreateManyPosSaleInput = {
    id?: string
    productoId: string
    productoName: string
    cantidad: number
    precio_unitario_al_momento_de_compra: number
  }

  export type POSSaleDetailUpdateWithoutPosSaleInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleDetailUncheckedUpdateWithoutPosSaleInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleDetailUncheckedUpdateManyWithoutPosSaleInput = {
    productoId?: StringFieldUpdateOperationsInput | string
    productoName?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    precio_unitario_al_momento_de_compra?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}